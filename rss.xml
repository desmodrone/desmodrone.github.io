<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>desmo</title>
      <link>https://desmodrone.github.io</link>
      <description>Random Ideas</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://desmodrone.github.io/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Tue, 14 Mar 2023 00:00:00 +0000</lastBuildDate>
      <item>
          <title>Notes on Traits and You: A Deep Dive Part 1</title>
          <pubDate>Tue, 14 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/traits-101/</link>
          <guid>https://desmodrone.github.io/posts/traits-101/</guid>
          <description>&lt;h4 id=&quot;original-content-by-nell-shamrell-harrington&quot;&gt;Original content by Nell Shamrell-Harrington&lt;&#x2F;h4&gt;
&lt;p&gt;When looking for resources to help me better understand Rust Traits, I found &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;grU-4u0Okto&quot;&gt;this video&lt;&#x2F;a&gt;from &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;nellshamrell?s=21&amp;amp;t=EhxGdIZ2VJ9HIqIS1LXcpw&quot;&gt;Nell Shamrell-Harrington&lt;&#x2F;a&gt;. It&#x27;s a great intro and overview into using Traits, which can be a little confusing when you first start learning Rust. &lt;&#x2F;p&gt;
&lt;p&gt;So these are my notes on this talk, if you haven&#x27;t watched it and are struggling with learning Traits, I strongly suggest that you watch the video above before you do anything else. But if you&#x27;re short on time and just want to reference my notes -- here they are. Disclaimer: these notes are my own interpretation of the talk and may not necessarily reflect the views of the original speaker. These note are primarily for me to learn these concepts, and I publish them for others to see and maybe benefit from. Feel free to let me know if I have errors or have misrepresentations. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;The talk goes covers 3 different ways that we can use Traits&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Traits 101 Introduction&lt;&#x2F;li&gt;
&lt;li&gt;Traits 201 Trait Bounds&lt;&#x2F;li&gt;
&lt;li&gt;Traits 301 Trait Objects&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Nell brilliantly uses D&amp;amp;D as a metaphor to help explain Traits. It should be clear that the use of D&amp;amp;D is just to help grasp some concepts, and the D&amp;amp;D rules do not strictly apply in these concepts, so now that we have that out of the way let&#x27;s begin.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits-101&quot;&gt;Traits: 101&lt;&#x2F;h2&gt;
&lt;p&gt;On this post we will cover Traits 101, this will keep each post shorter and easier to digest.&lt;&#x2F;p&gt;
&lt;p&gt;In D&amp;amp;D there are many different races, but we&#x27;ll start by using these 4 different races:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Dwarves&lt;&#x2F;li&gt;
&lt;li&gt;Elf&lt;&#x2F;li&gt;
&lt;li&gt;HalfOrc&lt;&#x2F;li&gt;
&lt;li&gt;Human&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;creating-our-structs&quot;&gt;Creating our Structs&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s create these races as structs in Rust&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct Dwarf {
	name:String
}

struct Elf {
	name:String
}

struct HalfOrc {
	name:String
}

struct Human {
	name:String
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see this is pretty straight forward code where we define the struct name (&lt;code&gt;Dwarf&lt;&#x2F;code&gt;, &lt;code&gt;Elf&lt;&#x2F;code&gt; etc.) and then add the &lt;code&gt;name:String&lt;&#x2F;code&gt; to allow our characters to be named.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-our-dwarf&quot;&gt;Creating our Dwarf&lt;&#x2F;h2&gt;
&lt;p&gt;First, let&#x27;s create a Dwarf character.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_dwarf = Dwarf {
	name: String::from(&amp;quot;DanDwarf&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A variable &lt;code&gt;my_dwarf&lt;&#x2F;code&gt; that stores our &lt;code&gt;Dwarf&lt;&#x2F;code&gt; type and we name him &lt;code&gt;DanDwarf&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;d-d-core-traits&quot;&gt;D&amp;amp;D Core Traits&lt;&#x2F;h2&gt;
&lt;p&gt;In D&amp;amp;D each character has core traits:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Strength&lt;&#x2F;li&gt;
&lt;li&gt;Dexterity&lt;&#x2F;li&gt;
&lt;li&gt;Constitution&lt;&#x2F;li&gt;
&lt;li&gt;Intelligence&lt;&#x2F;li&gt;
&lt;li&gt;Wisdom&lt;&#x2F;li&gt;
&lt;li&gt;Charisma&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;If you are not familiar in D&amp;amp;D, character&#x27;s core traits are defined in numbers, so an example would be that a character could have a Strength of: 8, a Dexterity of: 4, and a Constitution of 2, etc. as a base and depending on equipment or spells cast these traits could be boosted (or lowered).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;defining-a-trait&quot;&gt;Defining a Trait&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s first define a &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait that we can use on our soon to be defined Characters&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Let&amp;#x27;s make a constitution trait
&amp;#x2F;&amp;#x2F; where we define one function `constitution_bonus`
pub triat Constitution {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;implementing-constitution-for-dwarf&quot;&gt;Implementing &lt;code&gt;Constitution&lt;&#x2F;code&gt; for &lt;code&gt;Dwarf&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;So let&#x27;s take one of these traits, in our case Constitution and define it in Rust for our Dwarf.  We&#x27;ll say that Dwarves have a Constitution bonus of 2.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F;implemeting the trait
impl Constitution for Dwarf {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	2 &amp;#x2F;&amp;#x2F; this returns 2, anytime the instance of a dwarf is called.
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now that we&#x27;ve defined our trait we go back to our Dwarf, using our just defined  &lt;code&gt;constitution_bounus&lt;&#x2F;code&gt; that we can call on &lt;code&gt;my_dwarf&lt;&#x2F;code&gt; as shown below. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; back to making the character 
let my_dwarf = Dwarf {
	name: String::from(&amp;quot;DanDwarf&amp;quot;)
};

my_dwarf.constitution_bonus(); &amp;#x2F;&amp;#x2F; Returns 2
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this way no matter how many Dwarves we create, every single one of them will have the &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; of &lt;code&gt;2&lt;&#x2F;code&gt; attached.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-a-halforc&quot;&gt;Creating a HalfOrc&lt;&#x2F;h2&gt;
&lt;p&gt;Now, let&#x27;s create a &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; and we&#x27;ll start by implementing the &lt;code&gt;constituion_bonus&lt;&#x2F;code&gt;, the Constitution bonus for a HalfOrc is &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl Constitution for HalfOrc {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	1
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the same as our Dwarf &lt;code&gt;impl&lt;&#x2F;code&gt; but instead returning a 2, it returns 1&lt;&#x2F;p&gt;
&lt;p&gt;Now we create the HalfOrc with:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_half_orc = HalfOrc {
	name: String::from(&amp;quot;OscarOrc&amp;quot;)
}

my_half_orc.constitution_bonus();&amp;#x2F;&amp;#x2F; Returns 1
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Pretty straightforward right? We bind &lt;code&gt;my_half_orc&lt;&#x2F;code&gt; to our &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; and name him &lt;code&gt;OscarOrc&lt;&#x2F;code&gt; and when we call the &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; and we know that it will return &lt;code&gt;1&lt;&#x2F;code&gt;, as we have defined in the &lt;code&gt;impl&lt;&#x2F;code&gt; block above.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;humans-and-elves&quot;&gt;Humans and Elves&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s define our last 2 races of Humans and Elves, but let&#x27;s say that both of these races have a constitution bonus of &lt;code&gt;0&lt;&#x2F;code&gt;.
Our first instinct might be to do the same as we did above and do this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; we can implement like this but this is repetitive 
impl Constitution for Elf {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	0
	}
}

impl Constitution for Human {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	0
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is clearly repetitive and not ideal. Another thing to note is that most races actually have a constitution bonus of &lt;code&gt;0&lt;&#x2F;code&gt;
So how do we deal with this? &lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s add a default value the &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait we first created.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; making `0` the default
pub triat Constitution {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	0
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this way unless we have a struct that implements this trait and overrides this default value it will always return &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We still have to implement the traits on the struct, but we don&#x27;t have to define how the constitution bonus works since it&#x27;s default value is &lt;code&gt;0&lt;&#x2F;code&gt; and Humans and Elves&#x27; &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; matches the default value.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
impl Constitution for Elf{
}

impl Constitution for Human{
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;creating-our-elf-and-human&quot;&gt;Creating our Elf and Human&lt;&#x2F;h2&gt;
&lt;p&gt;We know the drill here, we define both of these in the same way that we did for our &lt;code&gt;my_dwarf&lt;&#x2F;code&gt; and &lt;code&gt;my_half_orc&lt;&#x2F;code&gt;, the only difference is that since we have defined a default value on the &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait we have access to it automatically unless we further define the &lt;code&gt;consitution_bonus&lt;&#x2F;code&gt; like we did previously.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_elf = Elf{
	name:String::from(&amp;quot;ElleElf&amp;quot;)
};

my_elf.constituion_bonus(); &amp;#x2F;&amp;#x2F; Retuns 0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_human = Human {
	name:String::from(&amp;quot;HarryHuman&amp;quot;)
};

my_human.constitution_bonus(); &amp;#x2F;&amp;#x2F; Returns 0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There it is, we have created 4 D&amp;amp;D characters and defined their &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; in a couple of different ways using Triats.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s summarize what we did here, in a quick step-by-step so we can see how easy it actually is to use traits in this way.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Create a &lt;code&gt;struct&lt;&#x2F;code&gt; for each of the races.&lt;&#x2F;li&gt;
&lt;li&gt;Create a character with a variable &lt;code&gt;my_&amp;lt;race&amp;gt;&lt;&#x2F;code&gt;  and defined it&#x27;s type and name.&lt;&#x2F;li&gt;
&lt;li&gt;Create a &lt;code&gt;trait&lt;&#x2F;code&gt;, in our case &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Implement the &lt;code&gt;triat&lt;&#x2F;code&gt; on the &lt;code&gt;Dwarf&lt;&#x2F;code&gt; struct 
&lt;ul&gt;
&lt;li&gt;define constitution bonus as &lt;code&gt;2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;calling &lt;code&gt;constitution_bonus()&lt;&#x2F;code&gt; on our character it returns &lt;code&gt;2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;if we create more &lt;code&gt;Dwarf&lt;&#x2F;code&gt; characters they&#x27;d all have a constitution bonus of &lt;code&gt;2&lt;&#x2F;code&gt; &lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Implement the &lt;code&gt;trait&lt;&#x2F;code&gt; on the &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; struct 
&lt;ul&gt;
&lt;li&gt;define constitution bonus as &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;calling &lt;code&gt;constitution_bonus()&lt;&#x2F;code&gt; on our character returns &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;if we create more &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; characters they&#x27;d all have a constitution bonus of &lt;code&gt;1&lt;&#x2F;code&gt; &lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Add a default value to our &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait&lt;&#x2F;li&gt;
&lt;li&gt;Implement the &lt;code&gt;trait&lt;&#x2F;code&gt; on &lt;code&gt;Elves&lt;&#x2F;code&gt; and &lt;code&gt;Humans&lt;&#x2F;code&gt;(with no additional definition)&lt;&#x2F;li&gt;
&lt;li&gt;Created our &lt;code&gt;Elves&lt;&#x2F;code&gt; and &lt;code&gt;Humans&lt;&#x2F;code&gt; 
&lt;ul&gt;
&lt;li&gt;calling &lt;code&gt;constitution_bonus()&lt;&#x2F;code&gt; on our elf and human characters returns &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;creating other races with no function definition in their implementation will always return &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Alright, as you can see there&#x27;s not a lot of tricky parts here, it&#x27;s all pretty straight forward, especially when laid out in this way where we can see how easy it is, in a few easy steps start using Traits in Rust. &lt;&#x2F;p&gt;
&lt;p&gt;Next we&#x27;ll dive into Traits 201, it will build on what we&#x27;ve learned here with Trait bounds. See you next time. &lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Rust Closures</title>
          <pubDate>Wed, 08 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/rust-closures/</link>
          <guid>https://desmodrone.github.io/posts/rust-closures/</guid>
          <description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;&#x2F;h2&gt;
&lt;p&gt;I&#x27;m new to Rust and programming in general, and while I&#x27;ve dabbled in different languages and technologies, I&#x27;ve never gone headfirst into any language to become proficient. I&#x27;m trying to change that now with Rust. Please forgive my inaccuracies or lack of understanding of more complex topics, but I&#x27;ll get there eventually. For now, I thought closures were an interesting topic, so I decided to write about this this topic first.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-are-closures&quot;&gt;What are closures?&lt;&#x2F;h2&gt;
&lt;p&gt;A closure can be thought of as a quick function that doesn&#x27;t need a name, or an anonymous function that can be saved in a variable or passed into other functions as arguments. A unique thing about closures is that they can capture their environment and this makes them a versatile tool that can be fun and efficient to use.&lt;&#x2F;p&gt;
&lt;p&gt;Closures are easy to identify because they use pipes &lt;code&gt;||&lt;&#x2F;code&gt; instead of the typical parentheses &lt;code&gt;()&lt;&#x2F;code&gt; that functions use. There are a few different ways you can use closures in Rust, but first, let&#x27;s look at how a closure is created.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;how-are-closures-created-in-rust&quot;&gt;How are closures created in Rust?&lt;&#x2F;h2&gt;
&lt;p&gt;Before we look at closures let us take a quick look at the syntax of how a function is defined in Rust. Below is a simple function definition that adds 1 to its parameter.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; function definition syntax
fn plus_one_v1 (x: u32) -&amp;gt; u32 { x + 1 }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you&#x27;re familiar with Rust&#x27;s functions this should be pretty easy to understand, so we won&#x27;t go through the details, if you&#x27;re not familiar with creating a function in Rust here&#x27;s a &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;2V0JaMVjzws?t=465&quot;&gt;Let&#x27;s Get Rusty&lt;&#x2F;a&gt; tutorial on functions that will bring you up to speed.  Now let&#x27;s look at how we&#x27;d create a closure using similar syntax to a function. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F;closure definition syntax
let plus_one_v2 = | x: u32| -&amp;gt; u32 { x + 1 };
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see the syntax is very similar to a function other than we use the &lt;code&gt;let&lt;&#x2F;code&gt;  keyword to bind the closure to &lt;code&gt;plus_one_v2&lt;&#x2F;code&gt; , and use the equal sign before the pipes &lt;code&gt;||&lt;&#x2F;code&gt;.  One thing to note is that a lot of this syntax is optional for closure definitions, the Rust compiler is usually able to infer the types in closures. Keep in mind that when the Rust compiler infers the type, it will take the first type we pass through as the type it uses. So you can&#x27;t change the type later in your code and expect it to work. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;simplifying-syntax&quot;&gt;Simplifying Syntax&lt;&#x2F;h2&gt;
&lt;p&gt;Since the Rust compiler can infer the types, to declare this closure in the most succinct manner you could do so like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; closure definition stripped down
let plus_one_v2 = |x| x + 1;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s go step by step and see what we removed.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; closure syntax defined
let plus_one_v2 = | x: u32| -&amp;gt; u32 { x + 1 };

&amp;#x2F;&amp;#x2F; removing the return type and curly braces
let plus_one_v2 = | x: u32| -&amp;gt; x + 1;

&amp;#x2F;&amp;#x2F; removing the u32 type in closure
let plus_one_v2 = |x| x + 1;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again because the rust compiler can infer the type we can make this line of code much cleaner.&lt;&#x2F;p&gt;
&lt;p&gt;Just like in functions where the parentheses &lt;code&gt;()&lt;&#x2F;code&gt;  can be empty, we can leave the &lt;code&gt;||&lt;&#x2F;code&gt; empty or add variables and types.  Let&#x27;s look at another example.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; empty `||`
fn main() {
	let simple_closure = || println!(&amp;quot;A simple closure&amp;quot;);
	simple_closure();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we define a closure to the variable &lt;code&gt;simple_closure&lt;&#x2F;code&gt; and this has nothing in between &lt;code&gt;||&lt;&#x2F;code&gt;.  If we run this code it prints: &lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;A simple closure.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;passing-in-parameters&quot;&gt;Passing in Parameters&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at what happens when we add something in between the pipes &lt;code&gt;||&lt;&#x2F;code&gt; similar to how we would to the parenthesis &lt;code&gt;()&lt;&#x2F;code&gt; of a function. We define &lt;code&gt;x&lt;&#x2F;code&gt; as and &lt;code&gt;i32&lt;&#x2F;code&gt; which means that when we call &lt;code&gt;simple_closure&lt;&#x2F;code&gt; we can pass in an &lt;code&gt;i32&lt;&#x2F;code&gt; into it.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; pipes with an i32
fn main() {
	let simple_closure = |x: i32| println!(&amp;quot;{}&amp;quot;, x);

	simple_closure(3);
	simple_closure(3+16);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;3
19
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So far so good, I hope. This behavior here is just like a function, we&#x27;re not doing anything too different. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;capturing-the-environment&quot;&gt;Capturing the Environment&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at what makes closures special, &amp;quot;capture their environment&amp;quot;, meaning they can take variables that are outside of the closure.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Capturing the environment
fn main() {
	let first = 12
	let second = 3

	let capture_closure = || println!(&amp;quot;{}&amp;quot;, first + second);
	capture_closure();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;15
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So what is going on here? We didn&#x27;t put anything in between the &lt;code&gt;||&lt;&#x2F;code&gt; but closures can just &#x27;take&#x27; the variables &lt;code&gt;first&lt;&#x2F;code&gt; and &lt;code&gt;second&lt;&#x2F;code&gt; and add them because closures can capture their environment -- pretty cool huh?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-3-closure-traits-fn-fnmut-and-fnonce&quot;&gt;The 3 closure traits (Fn, FnMut,  and FnOnce)&lt;&#x2F;h2&gt;
&lt;p&gt;Now, let&#x27;s dive a little deeper and take a look at the &lt;code&gt;Fn&lt;&#x2F;code&gt;, &lt;code&gt;FnMut&lt;&#x2F;code&gt;, and &lt;code&gt;FnOnce&lt;&#x2F;code&gt; traits and how they work with closures. This happens behind the scenes when using closures with variables but in order to understand closures and be able to use them to their full potential we must understand what is happening with these 3 traits.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fn&lt;&#x2F;code&gt;: using this with an upper case &lt;code&gt;F&lt;&#x2F;code&gt; means we are not mutating the captured variables and they are read-only.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;FnMut&lt;&#x2F;code&gt;: allows us to change captured variables, creating a mutable borrow of these captured variables.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;FnOnce&lt;&#x2F;code&gt;: this lets us move ownership into the closure. In essence, consuming the variable. &lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Again, Rust infers these traits when using closures with variables, different than when they&#x27;re being used with functions where they have to be explicitly defined, but we&#x27;ll look at that later. &lt;&#x2F;p&gt;
&lt;h3 id=&quot;fn-trait&quot;&gt;&lt;code&gt;Fn&lt;&#x2F;code&gt; Trait&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s take a quick look at what each of these looks like in code.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; using `Fn` trait
fn main() {
	let str1 = &amp;quot;Hello&amp;quot;.to_string();
	let closure = |x| println!(&amp;quot;{} {}&amp;quot;, str1, x);
	closure(&amp;quot;rustaceans!&amp;quot;)

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we capturing the variable and printing it with the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait because we are immutably borrowing that variable and printing it to screen. which prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Hello rustaceans!
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can tell we didn&#x27;t actually have to define the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait it was implied by how it the code is constructed. &lt;&#x2F;p&gt;
&lt;h3 id=&quot;fnmut-trait&quot;&gt;&lt;code&gt;FnMut&lt;&#x2F;code&gt; Trait&lt;&#x2F;h3&gt;
&lt;p&gt;Here in the 2nd block of code with &lt;code&gt;clsr2&lt;&#x2F;code&gt; we are declaring a closure that actually mutates the &lt;code&gt;str1&lt;&#x2F;code&gt; variable, so here we are using the &lt;code&gt;FnMut&lt;&#x2F;code&gt; trait because we are mutating our variable. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {
	&amp;#x2F;&amp;#x2F; using Fn trait
	let mut str1 = &amp;quot;Hello&amp;quot;.to_string();
	let closure = |x| println!(&amp;quot;{} {}&amp;quot;, str1, x);
	closure(&amp;quot;rustaceans!&amp;quot;);

	&amp;#x2F;&amp;#x2F; using FnMut trait
	let mut closure2 = |x| str1.push_str(x);
	closure2(&amp;quot; welcome back, rustaceans!&amp;quot;); 
	println!(&amp;quot;{}&amp;quot;, str1);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This now prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Hello rustaceans!
Hello welcome back, rustaceans!
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;fnonce-trait&quot;&gt;&lt;code&gt;FnOnce&lt;&#x2F;code&gt; Trait&lt;&#x2F;h3&gt;
&lt;p&gt;In this last example, we take a look at the &lt;code&gt;FnOnce&lt;&#x2F;code&gt; trait&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {
	&amp;#x2F;&amp;#x2F; using Fn trait
	let mut str1 = &amp;quot;Hello&amp;quot;.to_string();
	let closure = |x| println!(&amp;quot;{} {}&amp;quot;, str1, x);
	closure(&amp;quot;rustaceans!&amp;quot;);

	&amp;#x2F;&amp;#x2F; using FnMut trait
	let mut closure2 = |x| str1.push_str(x);
	closure2(&amp;quot; welcome back, rustaceans!&amp;quot;);
	println!(&amp;quot;{}&amp;quot;, str1);

	&amp;#x2F;&amp;#x2F; using FnOnce trait
	let closure3 = || drop(str1);
    println!(&amp;quot;before dropping str1&amp;quot;);
    closure3();
    println!(&amp;quot;str1 has been dropped&amp;quot;);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see the &lt;code&gt;FnOnce&lt;&#x2F;code&gt; trait in action here when using  &lt;code&gt;drop(str1)&lt;&#x2F;code&gt;.  However, if we try to call &lt;code&gt;str1&lt;&#x2F;code&gt; again, our code would not compile and give us an error message, so we don&#x27;t call it in this instance.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-move-keyword&quot;&gt;&lt;strong&gt;The &lt;code&gt;move&lt;&#x2F;code&gt; keyword&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;move&lt;&#x2F;code&gt; keyword comes in handy when you want to force a closure to take ownership of the values it captures, even though the closure doesn&#x27;t need it. &lt;code&gt;move&lt;&#x2F;code&gt; can specifically come into action when passing a closure into a new thread and thus moving the data so it&#x27;s owned by this new thread. Threads are something we can cover at a different time, but let&#x27;s look at this example on how to use the &lt;code&gt;move&lt;&#x2F;code&gt; keyword with closures:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!(&amp;quot;Before defining closure: {:?}&amp;quot;, list);

    thread::spawn(move || println!(&amp;quot;From thread: {:?}&amp;quot;, list))
        .join()
        .unwrap();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A new thread is spawned and we force the closure to take ownership of the &lt;code&gt;list&lt;&#x2F;code&gt; by using the &lt;code&gt;move&lt;&#x2F;code&gt;  keyword.  In this way even if we implement the &lt;code&gt;Fn&lt;&#x2F;code&gt; or &lt;code&gt;FnMut&lt;&#x2F;code&gt; traits, ownership is moved to the closure allowing more flexibility in the closure. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;passing-closures-or-other-functions-as-inputs-to-functions&quot;&gt;&lt;strong&gt;Passing closures(or other functions) as inputs to functions&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at a couple of different ways we can use closures as inputs to functions, building on what we saw above with the &lt;code&gt;Fn&lt;&#x2F;code&gt;, &lt;code&gt;FnMut&lt;&#x2F;code&gt;. &lt;&#x2F;p&gt;
&lt;p&gt;As mentioned outside of a function, a closure can decide by itself which trait to use, but inside of a function, you have to be explicit and define one of these traits. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; using `Fn`
fn add_num&amp;lt;F&amp;gt;(func: F)
	where F: Fn(i32){
		func(7)
	}

fn main(){
	let num = 6;
	add_num(|x|println!(&amp;quot;{}&amp;quot;, num + x));
	
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;13
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we are defining the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait to add two numbers and since we are not changing the number in the &lt;code&gt;add_num&lt;&#x2F;code&gt;  function and simply passing it through we can define the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait without major fuss. &lt;&#x2F;p&gt;
&lt;p&gt;However, if we try to make our &lt;code&gt;num&lt;&#x2F;code&gt; mutable by incrementing it, we might run into some problems. Let&#x27;s see what happens.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn add_num&amp;lt;F&amp;gt;(func: F)
	where F: Fn(i32){
		func(7)
	}

fn main(){
	let mut num = 6; &amp;#x2F;&amp;#x2F; mutable to allow incrementation
	add_num(|x|{num +=x; println!(&amp;quot;{}&amp;quot;, num + x)}); 
	
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As expected we get an error message:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;error[E0594]: cannot assign to `num`, as it is a captured variable in a `Fn` closure
 --&amp;gt; src&amp;#x2F;main.rs:8:14
  |
1 | fn add_num&amp;lt;F&amp;gt;(func: F)
  |                     - change this to accept `FnMut` instead of `Fn`
...
8 |     add_num(|x|{num +=x; println!(&amp;quot;{}&amp;quot;, num + x)});
  |     ------- --- ^^^^^^^ cannot assign
  |     |       |
  |     |       in this closure
  |     expects `Fn` instead of `FnMut`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler actually tells us what we should be doing here (very nice), changing the &lt;code&gt;Fn&lt;&#x2F;code&gt; to &lt;code&gt;FnMut&lt;&#x2F;code&gt; .&lt;&#x2F;p&gt;
&lt;p&gt;If we update our code to in the &lt;code&gt;add_num&lt;&#x2F;code&gt; function to what is shown below, our problems will be solved:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn add_num&amp;lt;F&amp;gt;(mut func: F) &amp;#x2F;&amp;#x2F; add mut here
	where F: FnMut(i32){ &amp;#x2F;&amp;#x2F; change Fn to FnMut here
		func(7) 
	}

fn main(){
	let mut num = 6;
	add_num(|x|{num +=x; println!(&amp;quot;{}&amp;quot;, num + x)}); 	
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This now compiles and prints:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;20
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Phew, we covered a lot but there&#x27;s still more we can do with closures, like storing them in structs and using them in conjunction with iterators, but we&#x27;ll leave that for another time. For now, I hope I have been able to explain what a closure is, how to create a closure, and how to use its traits. This should help you get started with getting familiar with closures and understanding how to use them in your own code. &lt;&#x2F;p&gt;
&lt;p&gt;Please let me know if I got something wrong or was unclear on anything, I&#x27;m doing this to help me better learn these concepts, so any feedback is appreciated. &lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Hello World</title>
          <pubDate>Tue, 07 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/hello-world/</link>
          <guid>https://desmodrone.github.io/posts/hello-world/</guid>
          <description>&lt;p&gt;Yes, the obligatory Hello World post...and code.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main(){
    println!(&amp;quot;hello world!&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
      </item>
    </channel>
</rss>
