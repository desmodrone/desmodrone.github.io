<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>desmo</title>
      <link>https://desmodrone.github.io</link>
      <description>Random Ideas</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://desmodrone.github.io/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Tue, 12 Mar 2024 00:00:00 +0000</lastBuildDate>
      <item>
          <title>Embarking on a New Journey</title>
          <pubDate>Tue, 12 Mar 2024 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/new-journey-at-extropy-io/</link>
          <guid>https://desmodrone.github.io/posts/new-journey-at-extropy-io/</guid>
          <description xml:base="https://desmodrone.github.io/posts/new-journey-at-extropy-io/">&lt;h2 id=&quot;joining-extropy-io&quot;&gt;Joining Extropy.io&lt;&#x2F;h2&gt;
&lt;p&gt;It&#x27;s been a while since I last updated my blog, and I&#x27;m thrilled to break the silence with some exciting news. I&#x27;ve recently accepted a position as a Blockchain Engineer at &lt;a href=&quot;http:&#x2F;&#x2F;extropy.io&quot;&gt;Extropy.io&lt;&#x2F;a&gt;, and I can&#x27;t wait to embark on this new chapter of my professional journey.&lt;&#x2F;p&gt;
&lt;p&gt;What really got me excited about Extropy.io is their commitment to breaking down the barriers to blockchain understanding. They&#x27;ve got this awesome mix of services â€” from consulting on the nuts and bolts of Distributed Ledger Technology (DLT) and Cryptography, to hands-on workshops and deep-dives into software development and security auditing.&lt;&#x2F;p&gt;
&lt;p&gt;But here&#x27;s the kicker for me: their vibe is all about opening up the world of blockchain to everyone, not just the tech nerds. Their mission to spread knowledge, ensure security, and push the envelope on innovation. That&#x27;s exactly where I want to be, working alongside some incredibly smart folks.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;m ready to dive in headfirst. Think of me as a bit of a blockchain Swiss Army knife â€“ from tightening up our security protocols to bringing our blockchain applications to life. I&#x27;m also stepping up to lead the charge on the tech training front, sharing the ins and outs with everyone who&#x27;s as psyched about this stuff as we are.&lt;&#x2F;p&gt;
&lt;p&gt;And hereâ€™s where it gets even more interesting: Iâ€™ll be bridging the gap between our tech advancements and the rest of the world. I&#x27;m on a mission to decode the complex lingo of blockchain for everyone to understand. It&#x27;s about igniting that same excitement for blockchain&#x27;s potential in everyone, and I&#x27;m here for it.&lt;&#x2F;p&gt;
&lt;p&gt;Stay tuned for updates on our projects, technical deep dives, and the occasional reflection on the blockchain landscape. I&#x27;ll be diving into more Zero Knowledge projects involving Rust and Cairo soon.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s to new beginnings and making a positive impact in the world of blockchain!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>LeetCode: 9. Palindrome Number</title>
          <pubDate>Tue, 16 Jan 2024 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/leetcode-palindrome-number/</link>
          <guid>https://desmodrone.github.io/posts/leetcode-palindrome-number/</guid>
          <description xml:base="https://desmodrone.github.io/posts/leetcode-palindrome-number/">&lt;h2 id=&quot;problem-statment&quot;&gt;Problem Statment&lt;&#x2F;h2&gt;
&lt;p&gt;Given an integerÂ &lt;code&gt;x&lt;&#x2F;code&gt;, returnÂ &lt;code&gt;true&lt;&#x2F;code&gt;Â &lt;em&gt;if&lt;&#x2F;em&gt;Â &lt;code&gt;x&lt;&#x2F;code&gt;Â &lt;em&gt;is a&lt;&#x2F;em&gt;Â &lt;strong&gt;palindrome&lt;&#x2F;strong&gt;, and_Â &lt;code&gt;false&lt;&#x2F;code&gt;Â &lt;em&gt;otherwise&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Example 3:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;&#x2F;strong&gt;Â Could you solve it without converting the integer to a string?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;intuition&quot;&gt;Intuition&lt;&#x2F;h2&gt;
&lt;p&gt;The core intuition behind solving the palindrome number problem lies in understanding what a palindrome is: a sequence that reads the same backward as forward. For an integer, this means that if we reverse the digits of the number, it should remain the same as the original number.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s the thought process:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Negative Numbers:&lt;&#x2F;strong&gt; Any negative number cannot be a palindrome due to the presence of the minus sign &lt;code&gt;-&lt;&#x2F;code&gt;, which cannot be at the end of a number.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Reversal and Comparison:&lt;&#x2F;strong&gt; If we can reverse the number and it remains unchanged, it&#x27;s a palindrome.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Efficiency Considerations:&lt;&#x2F;strong&gt; While converting the number to a string and reversing it is straightforward, doing so increases the space complexity. An in-place mathematical reversal could be more efficient.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;approach&quot;&gt;Approach&lt;&#x2F;h2&gt;
&lt;p&gt;Our approach starts by handling the simplest and most intuitive method: converting the number to a string and then comparing the original string with its reversed version. This method is easy to understand and implement but uses extra space for the string conversion.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;imperative-approach-using-string-conversion&quot;&gt;Imperative Approach Using String Conversion&lt;&#x2F;h4&gt;
&lt;p&gt;This approach converts the integer to a string and then uses two pointers to compare characters from both ends of the string, moving towards the center. It&#x27;s imperative because it uses loops and manual index manipulation. This method is straightforward and readable, but it involves additional space for the string.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;functional-approach-using-string-conversion&quot;&gt;Functional Approach Using String Conversion&lt;&#x2F;h4&gt;
&lt;p&gt;This approach also converts the number to a string but then leverages Rust&#x27;s functional programming capabilities to check for palindromicity. By using &lt;code&gt;chars().eq(chars().rev())&lt;&#x2F;code&gt;, it compares the character sequence directly with its reversed version. This method is concise and leverages Rust&#x27;s iterator and functional capabilities, providing a clear and elegant solution.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;extra-challenge-imperative-version-using-math&quot;&gt;Extra Challenge: Imperative Version Using Math&lt;&#x2F;h4&gt;
&lt;p&gt;The mathematical approach avoids converting the integer to a string, thus saving space. The idea is to construct the reversed number digit by digit from the original number. By repeatedly extracting the last digit of the original number (&lt;code&gt;original % 10&lt;&#x2F;code&gt;) and adding it to the reversed number (&lt;code&gt;reversed = reversed * 10 + last_digit&lt;&#x2F;code&gt;), we effectively build the reversed number. Then, we compare the reversed number with the original number to check for palindromicity. This approach is more efficient in terms of space but requires a good understanding of numerical manipulations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;code&quot;&gt;Code&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;imperative-approach-using-string-conversion-1&quot;&gt;Imperative Approach Using String Conversion&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    pub fn is_palindrome(x: i32) -&amp;gt; bool {
        	if x &amp;lt; 0 {
		return false;
	}

	let s = x.to_string();
	let bytes = s.as_bytes();
	let mut i = 0;
	let mut j = s.len() -1;

	while i &amp;lt; j {
		if bytes[i] != bytes[j] {
			return false;
		}
		i += 1;
		j -= 1;
	}
	true
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;functional-approach-using-string-conversion-1&quot;&gt;Functional Approach Using String Conversion&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn is_palindrome(x: i32) -&amp;gt; bool {
	if x &amp;lt; 0 {
		return false;
	}

    let x = x.to_string();
    x.chars().eq(x.chars().rev())
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;extra-challenge-imperative-version-using-math-1&quot;&gt;Extra Challenge: Imperative Version using Math&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn is_palindrome(x: i32) -&amp;gt; bool {
    if x &amp;lt; 0 {
        return false;
    }

    let mut original = x;
    let mut reversed = 0;

    while original &amp;gt; 0 {
        reversed = reversed * 10 + original % 10;
        original &amp;#x2F;= 10;
    }

    x == reversed
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;explanation&quot;&gt;Explanation&lt;&#x2F;h2&gt;
&lt;p&gt;Each approach to determining whether an integer is a palindrome highlights different programming techniques and considerations. Let&#x27;s delve into the details of each version:&lt;&#x2F;p&gt;
&lt;h3 id=&quot;imperative-approach-using-string-conversion-2&quot;&gt;Imperative Approach Using String Conversion&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn is_palindrome(x: i32) -&amp;gt; bool {
    &amp;#x2F;&amp;#x2F; negative check
    if x &amp;lt; 0 {
        return false;
    }

	&amp;#x2F;&amp;#x2F; string converion
    let s = x.to_string();
    &amp;#x2F;&amp;#x2F; byte conversion
    let bytes = s.as_bytes();
    &amp;#x2F;&amp;#x2F; two pointers
    let mut i = 0;
    let mut j = s.len() - 1;

	&amp;#x2F;&amp;#x2F; compare number pairs
    while i &amp;lt; j {
        if bytes[i] != bytes[j] {
            return false;
        }
        i += 1;
        j -= 1;
    }
    true
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Negative Check:&lt;&#x2F;strong&gt; The function immediately returns &lt;code&gt;false&lt;&#x2F;code&gt; for negative numbers since the minus sign would invalidate palindrome properties.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;String Conversion:&lt;&#x2F;strong&gt; The number is converted to a string to utilize character comparison. This allows an easy check from both ends towards the center.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Byte Array:&lt;&#x2F;strong&gt; Conversion to a byte array (&lt;code&gt;as_bytes()&lt;&#x2F;code&gt;) allows for efficient indexing and comparison of characters.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Two-Pointer Technique:&lt;&#x2F;strong&gt; Two indices (&lt;code&gt;i&lt;&#x2F;code&gt; and &lt;code&gt;j&lt;&#x2F;code&gt;) are used to compare characters from opposite ends of the string. If any pair of characters doesn&#x27;t match, the function returns &lt;code&gt;false&lt;&#x2F;code&gt;. The loop continues until the indices meet or cross, confirming the number is a palindrome.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;functional-approach-using-string-conversion-2&quot;&gt;Functional Approach Using String Conversion&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn is_palindrome(x: i32) -&amp;gt; bool {
    &amp;#x2F;&amp;#x2F; negative check

    if x &amp;lt; 0 {
        return false;
    }
    &amp;#x2F;&amp;#x2F; convert x to a string
    let x = x.to_string();
    &amp;#x2F;&amp;#x2F; compare `x` with `eq()` and reversed version of `x` with `rev()`
    x.chars().eq(x.chars().rev())
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Simplicity:&lt;&#x2F;strong&gt; This approach is more succinct, leveraging Rust&#x27;s powerful iterator and functional programming features.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Character Iterator:&lt;&#x2F;strong&gt; &lt;code&gt;x.chars()&lt;&#x2F;code&gt; creates an iterator over the characters of the string.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Reverse Iterator:&lt;&#x2F;strong&gt; &lt;code&gt;x.chars().rev()&lt;&#x2F;code&gt; creates a reverse iterator, allowing direct comparison of the original character sequence with its reversed version.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Equality Check:&lt;&#x2F;strong&gt; The &lt;code&gt;eq&lt;&#x2F;code&gt; method compares two iterators element by element. If all corresponding characters match, it confirms the palindrome property.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;follow-up-challenge-imperative-version-using-math&quot;&gt;Follow-Up Challenge: Imperative Version Using Math&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn is_palindrome(x: i32) -&amp;gt; bool {
    &amp;#x2F;&amp;#x2F; negative check
    if x &amp;lt; 0 {
        return false;
    }

    &amp;#x2F;&amp;#x2F; define our variables to hold
    &amp;#x2F;&amp;#x2F; our original version to manipulate
    &amp;#x2F;&amp;#x2F; and our reveresed version to compare to
    let mut original = x;
    let mut reversed = 0;

    &amp;#x2F;&amp;#x2F; while our original version is
    &amp;#x2F;&amp;#x2F; greater than 0 we continue with
    &amp;#x2F;&amp;#x2F; mathematical calculations
    while original &amp;gt; 0 {
        reversed = reversed * 10 + original % 10;
        original &amp;#x2F;= 10;
    }
    &amp;#x2F;&amp;#x2F; compare `x` to the `reversed` version
    x == reversed
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;In-Place Reversal:&lt;&#x2F;strong&gt; This method avoids string conversion, instead reversing the number mathematically. This is efficient in terms of memory usage.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Digit Extraction and Reversal:&lt;&#x2F;strong&gt; The last digit of &lt;code&gt;original&lt;&#x2F;code&gt; is appended to &lt;code&gt;reversed&lt;&#x2F;code&gt; by first multiplying &lt;code&gt;reversed&lt;&#x2F;code&gt; by 10 (shifting it one decimal place up) and then adding the last digit of &lt;code&gt;original&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Original Number Modification:&lt;&#x2F;strong&gt; &lt;code&gt;original&lt;&#x2F;code&gt; is divided by 10 to remove the last digit, progressively shortening the number until all digits have been processed.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Palindrome Check:&lt;&#x2F;strong&gt; The function compares the original number with the reversed number. If they match, the number is a palindrome.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;complexity-analysis&quot;&gt;Complexity Analysis&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;imperative-approach-using-string-conversion-3&quot;&gt;Imperative Approach Using String Conversion&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time Complexity:&lt;&#x2F;strong&gt; (O(n)), where (n) is the number of digits in the integer. This is because the function iterates over each character of the string representation of the integer once.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Space Complexity:&lt;&#x2F;strong&gt; (O(n)). The additional space comes from converting the integer to a string, which requires space proportional to the number of digits in the integer.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;functional-approach-using-string-conversion-3&quot;&gt;Functional Approach Using String Conversion&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time Complexity:&lt;&#x2F;strong&gt; (O(n)). Similar to the imperative approach, it needs to iterate over each character to compare them.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Space Complexity:&lt;&#x2F;strong&gt; (O(n)). The conversion of the integer to a string and the creation of the reverse iterator both contribute to the space used.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;imperative-version-using-math&quot;&gt;Imperative Version Using Math&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time Complexity:&lt;&#x2F;strong&gt; (O(\log_{10}(x))), where (x) is the value of the integer. The number of digits in (x) is proportional to the logarithm of (x), and the loop iterates once for each digit.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Space Complexity:&lt;&#x2F;strong&gt; (O(1)). This approach uses a fixed amount of space, only a few integers, regardless of the size of the input number.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;additional-information&quot;&gt;Additional Information&lt;&#x2F;h2&gt;
&lt;p&gt;When choosing between these approaches, consider the context of your application. If space efficiency is paramount, the mathematical approach is preferable. For readability and ease of understanding, string conversion methods might be more suitable.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;further-reading-references&quot;&gt;Further Reading &#x2F; References&lt;&#x2F;h3&gt;
&lt;p&gt;To deepen your understanding of the concepts used in these solutions, you might explore the following topics:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;std&#x2F;str.html&quot;&gt;String Manipulation in Rust:&lt;&#x2F;a&gt;&lt;&#x2F;strong&gt; Learn more about how strings work in Rust, including ownership, borrowing, and methods associated with string manipulation.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch13-00-functional-features.html&quot;&gt;Iterators and Closures in Rust&lt;&#x2F;a&gt;:&lt;&#x2F;strong&gt; These are powerful features that allow for concise and expressive code, especially in functional-style programming.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;brilliant.org&#x2F;number-theory&#x2F;?subtopic=integers&amp;amp;utm_medium=cpc&amp;amp;utm_source=performancemax&amp;amp;utm_campaign=Mixed_Performance_Max&amp;amp;gad_source=1&amp;amp;gclid=Cj0KCQiAqsitBhDlARIsAGMR1RiDtPeLQ4liz3oNNs2ZEArvw5Z0FBemQ6X2r6O6T2Tg5yYTy9kgqykaAslSEALw_wcB&quot;&gt;Number Theory Basics&lt;&#x2F;a&gt;:&lt;&#x2F;strong&gt; Understanding how numbers can be manipulated, reversed, and analyzed is crucial in many algorithmic problems.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we explored three different approaches to solving the palindrome number problem in Rust, each illustrating a unique aspect of Rust&#x27;s capabilities. From simple string manipulation to more complex mathematical solutions, Rust provides the tools and features to implement efficient and readable solutions. Whether you prefer the imperative or functional programming paradigm, Rust accommodates both styles, allowing us to leverage its powerful type system and safety guarantees to write high-quality code.&lt;&#x2F;p&gt;
&lt;p&gt;Remember, the best solution often depends on the specific requirements and constraints of your project. By understanding the trade-offs between different approaches, we can make informed decisions that balance performance, readability, and Rust&#x27;s idiomatic practices.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>LeetCode: 13. Roman to Integer</title>
          <pubDate>Tue, 16 Jan 2024 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/leetcode-roman-to-integer/</link>
          <guid>https://desmodrone.github.io/posts/leetcode-roman-to-integer/</guid>
          <description xml:base="https://desmodrone.github.io/posts/leetcode-roman-to-integer/">&lt;h2 id=&quot;decoding-roman-numerals-two-rust-approaches-to-a-classic-problem&quot;&gt;Decoding Roman Numerals: Two Rust Approaches to a Classic Problem&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;roman-to-integer&#x2F;description&#x2F;&quot;&gt;13. Roman to Integer on LeetCode&lt;&#x2F;a&gt;
Roman numerals are represented by seven different symbols:Â &lt;code&gt;I&lt;&#x2F;code&gt;,Â &lt;code&gt;V&lt;&#x2F;code&gt;,Â &lt;code&gt;X&lt;&#x2F;code&gt;,Â &lt;code&gt;L&lt;&#x2F;code&gt;,Â &lt;code&gt;C&lt;&#x2F;code&gt;,Â &lt;code&gt;D&lt;&#x2F;code&gt;Â andÂ &lt;code&gt;M&lt;&#x2F;code&gt;.
&lt;strong&gt;Symbol&lt;&#x2F;strong&gt;                       &lt;strong&gt;Value&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;I             1
V             5
X             10
L             50
C             100
D             500
M             1000
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For example,Â &lt;code&gt;2&lt;&#x2F;code&gt;Â is written asÂ &lt;code&gt;II&lt;&#x2F;code&gt;Â in Roman numeral, just two ones added together.Â &lt;code&gt;12&lt;&#x2F;code&gt;Â is written asÂ &lt;code&gt;XII&lt;&#x2F;code&gt;, which is simplyÂ &lt;code&gt;X + II&lt;&#x2F;code&gt;. The numberÂ &lt;code&gt;27&lt;&#x2F;code&gt;Â is written asÂ &lt;code&gt;XXVII&lt;&#x2F;code&gt;, which isÂ &lt;code&gt;XX + V + II&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is notÂ &lt;code&gt;IIII&lt;&#x2F;code&gt;. Instead, the number four is written asÂ &lt;code&gt;IV&lt;&#x2F;code&gt;. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written asÂ &lt;code&gt;IX&lt;&#x2F;code&gt;. There are six instances where subtraction is used:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;I&lt;&#x2F;code&gt;Â can be placed beforeÂ &lt;code&gt;V&lt;&#x2F;code&gt;Â (5) andÂ &lt;code&gt;X&lt;&#x2F;code&gt;Â (10) to make 4 and 9.Â &lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;X&lt;&#x2F;code&gt;Â can be placed beforeÂ &lt;code&gt;L&lt;&#x2F;code&gt;Â (50) andÂ &lt;code&gt;C&lt;&#x2F;code&gt;Â (100) to make 40 and 90.Â &lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;C&lt;&#x2F;code&gt;Â can be placed beforeÂ &lt;code&gt;D&lt;&#x2F;code&gt;Â (500) andÂ &lt;code&gt;M&lt;&#x2F;code&gt;Â (1000) to make 400 and 900.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Given a roman numeral, convert it to an integer.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Input: s = &amp;quot;III&amp;quot;
Output: 3
Explanation: III = 3.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Input: s = &amp;quot;LVIII&amp;quot;
Output: 58
Explanation: L = 50, V= 5, III = 3.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Example 3:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Input: s = &amp;quot;MCMXCIV&amp;quot;
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;&#x2F;h2&gt;
&lt;p&gt;Roman numerals, the numerical system of ancient Rome, have been used for centuries, from monumental Roman architecture to the pages of classical literature. Today, while our modern digital world primarily operates on the decimal system, the echoes of Roman numerals still resound in various areas, such as clock faces, book chapter titles, and annual events like the Super Bowl. Understanding and converting these numerals to integers is not just an exercise in historical linguistics but also finds its relevance in modern computing, where translating different numeral systems forms a foundational aspect of data processing and software development.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;intuition&quot;&gt;Intuition&lt;&#x2F;h2&gt;
&lt;p&gt;At first glance, Roman numerals might seem straightforward, with each symbol representing a fixed value. However, the intriguing aspect lies in their lack of a positional value system, unlike our familiar decimal system where the position of a digit significantly changes its value. In Roman numerals, the value is often dictated by the sequence and combination of symbols, leading to a unique set of rules for interpretation. This absence of positional values presents an interesting challenge in designing algorithms for conversion, as one must carefully interpret the order and combination of numerals to accurately derive the corresponding integer.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;approach&quot;&gt;Approach&lt;&#x2F;h2&gt;
&lt;p&gt;In exploring the conversion of Roman numerals to integers, two distinct approaches in Rust offer insights into the language&#x27;s capabilities and the trade-offs in programming styles. The imperative approach, utilizing a &lt;code&gt;match&lt;&#x2F;code&gt; statement, aligns with a straightforward, step-by-step process of decision making, echoing traditional procedural programming. It&#x27;s generally easier to understand, especially for those new to Rust or programming in general. On the other hand, the functional approach, employing a &lt;code&gt;HashMap&lt;&#x2F;code&gt;, embraces Rust&#x27;s powerful features in functional programming. This method shines in code readability and maintainability, especially in scenarios where the mapping might evolve or expand, offering a more scalable solution. However, it might introduce a slight overhead due to the creation and management of the &lt;code&gt;HashMap&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;code&quot;&gt;Code&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;imperative-approach-with-match&quot;&gt;Imperative Approach with &lt;code&gt;match&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn roman_to_int(s: String) -&amp;gt; i32 {

    let mut result = 0;
    let mut prev = 0;

    for c in s.chars() {
        let current = match c {
            &amp;#x27;I&amp;#x27; =&amp;gt; 1,
            &amp;#x27;V&amp;#x27; =&amp;gt; 5,
            &amp;#x27;X&amp;#x27; =&amp;gt; 10,
            &amp;#x27;L&amp;#x27; =&amp;gt; 50,
            &amp;#x27;C&amp;#x27; =&amp;gt; 100,
            &amp;#x27;D&amp;#x27; =&amp;gt; 500,
            &amp;#x27;M&amp;#x27; =&amp;gt; 1000,
            _ =&amp;gt; 0,
        };

        result += current;
        if current &amp;gt; prev {
            result -= 2 * prev
        }
        prev = current
    }
    result
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;functional-approach-using-hashmap&quot;&gt;Functional Approach using &lt;code&gt;HashMap&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::collections::HashMap;

fn roman_to_int(s: String) -&amp;gt; i32 {

    let translation: HashMap&amp;lt;char, i32&amp;gt; = [
        (&amp;#x27;I&amp;#x27;, 1),
        (&amp;#x27;V&amp;#x27;, 5),
        (&amp;#x27;X&amp;#x27;, 10),
        (&amp;#x27;L&amp;#x27;, 50),
        (&amp;#x27;C&amp;#x27;, 100),
        (&amp;#x27;D&amp;#x27;, 500),
        (&amp;#x27;M&amp;#x27;, 1000),
    ].iter().cloned().collect();

    s.chars().enumerate().fold(0, |acc, (i, c)| {


        let current_value = translation[&amp;amp;c];

        if let Some(next_char) = s.chars().nth(i+1) {

            let next_value = translation[&amp;amp;next_char];

            if next_value &amp;gt; current_value {
                acc - current_value
            } else {
                acc + current_value
            }
        } else {
            acc + current_value
        }
    })
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;explanation&quot;&gt;Explanation&lt;&#x2F;h2&gt;
&lt;p&gt;To illustrate these approaches, let&#x27;s consider converting &amp;quot;IX&amp;quot; to 9. In the imperative method, as we iterate through the string, we first encounter &#x27;I&#x27; (1), followed by &#x27;X&#x27; (10). Recognizing that &#x27;I&#x27; is less than &#x27;X&#x27;, the algorithm adapts by subtracting twice the value of &#x27;I&#x27; (once to negate the initial addition and once more for the actual subtraction). In the functional approach, the &lt;code&gt;HashMap&lt;&#x2F;code&gt; provides a quick lookup for each numeral&#x27;s value. When processing &#x27;I&#x27; and then &#x27;X&#x27;, the algorithm checks if the value of the next numeral (&#x27;X&#x27;) is greater than the current (&#x27;I&#x27;), leading to a subtraction of &#x27;I&#x27;. Both methods effectively capture the essence of Roman numeral logic but through different computational lenses.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;imperative-approach-with-match-1&quot;&gt;Imperative Approach with &lt;code&gt;match&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;In this approach, each Roman numeral character is converted to its integer value using a &lt;code&gt;match&lt;&#x2F;code&gt; statement. The function iterates over each character of the input string, and for each character, it checks its value and adds it to the cumulative result. If the current value is greater than the previous value (indicating a subtractive notation like IV or IX), the function subtracts twice the previous value from the result. This adjustment is necessary because the previous value was added before knowing that a subtractive notation was in use.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;functional-approach-using-hashmap-1&quot;&gt;Functional Approach using &lt;code&gt;HashMap&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;This version uses a &lt;code&gt;HashMap&lt;&#x2F;code&gt; to store the mappings from Roman numerals to integers. The &lt;code&gt;fold&lt;&#x2F;code&gt; function iterates over each character of the string, accumulating the total value. The lambda function inside &lt;code&gt;fold&lt;&#x2F;code&gt; checks the current and next character&#x27;s value. If the next character&#x27;s value is larger (indicating a subtractive combination), the current value is subtracted from the accumulator. Otherwise, it&#x27;s added. The use of &lt;code&gt;enumerate&lt;&#x2F;code&gt; along with &lt;code&gt;nth&lt;&#x2F;code&gt; allows access to the current and next characters in the string.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;complexity-analysis&quot;&gt;Complexity Analysis&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Time Complexity:&lt;&#x2F;strong&gt; Both implementations operate in O(n) time complexity, where n is the length of the input string. Each character is processed once in the loop.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Space Complexity:&lt;&#x2F;strong&gt; The space complexity is O(1) for both approaches, as the storage used does not grow with the size of the input. In the case of the functional approach, although a &lt;code&gt;HashMap&lt;&#x2F;code&gt; is used, its size remains constant regardless of the input.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;additional-information&quot;&gt;Additional Information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rust&#x27;s Ownership and Borrowing:&lt;&#x2F;strong&gt; Rust&#x27;s ownership model ensures memory safety without a garbage collector. The functional approach demonstrates how Rust can elegantly handle data without explicit memory management.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Idiomatic Rust:&lt;&#x2F;strong&gt; Using &lt;code&gt;fold&lt;&#x2F;code&gt; and &lt;code&gt;HashMap&lt;&#x2F;code&gt; for the functional approach is more idiomatic in Rust and showcases the language&#x27;s capabilities in functional programming.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Error Handling:&lt;&#x2F;strong&gt; Both implementations assume valid Roman numeral input. If invalid characters are possible, additional error handling would be needed.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Choosing between the imperative and functional approaches in Rust can depend on various factors, such as the programmer&#x27;s familiarity with Rust, the specific project requirements, and the preference for a particular programming paradigm. For beginners or those preferring straightforward logic, the imperative method with &lt;code&gt;match&lt;&#x2F;code&gt; might be more appealing. Conversely, for those who appreciate the elegance and scalability of functional programming, especially in a language like Rust that excellently supports it, the &lt;code&gt;HashMap&lt;&#x2F;code&gt; approach could be more suitable. Ultimately, both methods offer valuable insights into solving problems efficiently and idiomatically in Rust.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>LeetCode: 1. Two Sum</title>
          <pubDate>Mon, 08 Jan 2024 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/leetcode-two-sum/</link>
          <guid>https://desmodrone.github.io/posts/leetcode-two-sum/</guid>
          <description xml:base="https://desmodrone.github.io/posts/leetcode-two-sum/">&lt;h1 id=&quot;1-two-sum&quot;&gt;1. Two Sum&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;description-on-leetcode&quot;&gt;&lt;a href=&quot;https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;two-sum&#x2F;description&#x2F;&quot;&gt;Description on LeetCode&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Given an array of integersÂ &lt;code&gt;nums&lt;&#x2F;code&gt;Â and an integerÂ &lt;code&gt;target&lt;&#x2F;code&gt;, returnÂ &lt;em&gt;indices of the two numbers such that they add up toÂ &lt;code&gt;target&lt;&#x2F;code&gt;&lt;&#x2F;em&gt;.
You may assume that each input would haveÂ &lt;strong&gt;&lt;em&gt;exactly&lt;&#x2F;em&gt;Â one solution&lt;&#x2F;strong&gt;, and you may not use theÂ &lt;em&gt;same&lt;&#x2F;em&gt;Â element twice.&lt;&#x2F;p&gt;
&lt;p&gt;You can return the answer in any order.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Input: nums = [3,2,4], target = 6
Output: [1,2]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Example 3:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Input: nums = [3,3], target = 6
Output: [0,1]`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Constraints:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;2 &amp;lt;= nums.length &amp;lt;= 104&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;-109 &amp;lt;= nums[i] &amp;lt;= 109&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;-109 &amp;lt;= target &amp;lt;= 109&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Only one valid answer exists.&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Follow-up:&lt;&#x2F;strong&gt;Â Can you come up with an algorithm that is less thanÂ &lt;code&gt;O(n2)&lt;&#x2F;code&gt;Â time complexity?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;breakdown&quot;&gt;Breakdown&lt;&#x2F;h2&gt;
&lt;p&gt;Although this problem is not overly complex, breaking it down can provide further insight. Essentially we have  to find two numbers in an array that add up to a given target value. Our task is to return the indices of these two numbers. If no such pair exists in our array, we return an empty array (or Vector in Rust)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;approach&quot;&gt;Approach&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;ll try two different approaches for this exercise a &lt;em&gt;brute force&lt;&#x2F;em&gt; and a &lt;em&gt;hashmap&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;The brute force version uses nested loops to iterate through the pair of elements. Although it&#x27;s a simple and straightforward approach it&#x27;s not the most efficient.&lt;&#x2F;li&gt;
&lt;li&gt;The HashMap version is more efficient as we only need to iterate through the array once, and check if the target minus the current element is in the array.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;code&quot;&gt;Code&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;brute-force-approach&quot;&gt;Brute Force Approach&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Function to find two numbers in the array that add up to the target
fn two_sum(nums: Vec&amp;lt;i32&amp;gt;, target: i32) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    &amp;#x2F;&amp;#x2F; Iterate over each element in the array with its index
    for (i, num1) in nums.iter().enumerate() {
        &amp;#x2F;&amp;#x2F; Iterate over the rest of the array starting from the next element
        for (j, num2) in nums.iter().skip(i + 1).enumerate() {
            &amp;#x2F;&amp;#x2F; Check if the sum of the current pair equals the target
            if num1 + num2 == target {
                &amp;#x2F;&amp;#x2F; If a pair is found, return their indices
                return vec![i as i32, (j + i + 1) as i32];
            }
        }
    }
    &amp;#x2F;&amp;#x2F; Return an empty array if no pair is found
    vec![]
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;hashmap-approach&quot;&gt;HashMap Approach&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::collections::HashMap; &amp;#x2F;&amp;#x2F; Import the HashMap from the standard library

&amp;#x2F;&amp;#x2F; Function to find two numbers in the array that add up to the target
fn two_sum(nums: Vec&amp;lt;i32&amp;gt;, target: i32) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut hm = HashMap::new(); &amp;#x2F;&amp;#x2F; Create a new, empty HashMap

    &amp;#x2F;&amp;#x2F; Iterate over each element in the array with its index
    for (i, num) in nums.iter().enumerate() {
        let complement = target - num; &amp;#x2F;&amp;#x2F; Calculate the complement of the current number

        &amp;#x2F;&amp;#x2F; Check if the complement is already in the HashMap
        if let Some(&amp;amp;index) = hm.get(&amp;amp;complement){
            &amp;#x2F;&amp;#x2F; If found, return the indices of the complement and the current number
            return vec![index as i32, i as i32];
        }
        &amp;#x2F;&amp;#x2F; Insert the current number and its index into the HashMap
        hm.insert(*num, i);
    }
    &amp;#x2F;&amp;#x2F; Return an empty array if no pair is found
    vec![]
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;explanation&quot;&gt;Explanation&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;strong&gt;Brute Force Approach&lt;&#x2F;strong&gt; iteratively checks each pair of numbers in the array to see if they sum up to the target. This is done by using two nested loops: the outer loop iterates through each element, and the inner loop checks all subsequent elements to find a pair that adds up to the target.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;strong&gt;HashMap Approach&lt;&#x2F;strong&gt; is more efficient. It iterates through the array once, using a HashMap to store elements already traversed. For each element, we calculate its complement (target - current element) and check if this complement is already in the HashMap. If it is, we found a pair; if not, we add the current element to the HashMap. This approach significantly reduces the time complexity as it avoids the need for nested iteration.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;complexity-analysis&quot;&gt;Complexity Analysis&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Brute Force Approach&lt;&#x2F;strong&gt;:
&lt;ul&gt;
&lt;li&gt;Time Complexity: O(n^2) where n is the number of elements in the array. This is because we need to check each pair of elements.&lt;&#x2F;li&gt;
&lt;li&gt;Space Complexity: O(1), as it only uses a few extra variables for iteration and no additional data structures.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;HashMap Approach&lt;&#x2F;strong&gt;:
&lt;ul&gt;
&lt;li&gt;Time Complexity: O(n), as we traverse the list containing n elements only once. Each look up in the table costs only O(1) time.&lt;&#x2F;li&gt;
&lt;li&gt;Space Complexity: O(n), to store the elements and their indices in the HashMap.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;additional-information&quot;&gt;Additional Information&lt;&#x2F;h2&gt;
&lt;p&gt;When implementing solutions like the HashMap approach, it&#x27;s crucial to consider possible edge cases, such as duplicate elements in the array, and ensure your implementation correctly handles these cases. We can dive deeper into some examples in other problems, for now it&#x27;s good to just think about the potiental of these cases.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;follow-up-question&quot;&gt;Follow-up Question&lt;&#x2F;h4&gt;
&lt;p&gt;The follow up question challenged us to come up with a better solution &lt;em&gt;Can you come up with an algorithm that is less thanÂ &lt;code&gt;O(n2)&lt;&#x2F;code&gt;Â time complexity?&lt;&#x2F;em&gt;
and we did so with the &lt;em&gt;HashMap&lt;&#x2F;em&gt; solution so let&#x27;s dive down a little bit more as to why it&#x27;s better and how it does it.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;hashmap-approach-details&quot;&gt;HashMap Approach Details&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Initialize a HashMap&lt;&#x2F;strong&gt;: This map will store elements from the array as keys and their indices as values.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Iterate through the Array&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;For each element, calculate its complement by subtracting it from the target (i.e., &lt;code&gt;complement = target - num&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;Check if the complement is already in the HashMap.
&lt;ul&gt;
&lt;li&gt;If it is, it means we have found a pair of numbers that add up to the target. Return their indices.&lt;&#x2F;li&gt;
&lt;li&gt;If not, add the current element and its index to the HashMap.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Return&lt;&#x2F;strong&gt;: If no pair is found by the end of the iteration, return an indication that no solution exists (e.g., an empty array).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;time-complexity&quot;&gt;Time Complexity:&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HashMap Lookups&lt;&#x2F;strong&gt;: The time complexity of looking up keys in a HashMap is ( O(1) ) on average.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Single Iteration&lt;&#x2F;strong&gt;: The algorithm iterates through the array only once.&lt;&#x2F;li&gt;
&lt;li&gt;Therefore, the overall time complexity is ( O(n) ), where ( n ) is the number of elements in the array.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;space-complexity&quot;&gt;Space Complexity:&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;The space complexity is ( O(n) ), as in the worst case, we might need to add every element to the HashMap.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This HashMap approach is significantly more efficient than a brute-force method with nested loops, which has a time complexity of ( O(n^2) ). By utilizing a HashMap to store and quickly look up complements, we reduce the problem to a single pass through the array, achieving the desired time complexity of less than ( O(n^2) ).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In solving the &amp;quot;Two Sum&amp;quot; problem, we explored both a brute force and a HashMap approach, illustrating the trade-offs between time and space complexity. While the brute force method is straightforward, the HashMap approach offers a more efficient solution, highlighting the importance of understanding data structures and algorithms in problem-solving. Practicing such problems enhances not only coding skills but also analytical thinking, which is vital in tackling real-world challenges.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Hello LeetCode</title>
          <pubDate>Sun, 07 Jan 2024 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/00-hello-leetcode/</link>
          <guid>https://desmodrone.github.io/posts/00-hello-leetcode/</guid>
          <description xml:base="https://desmodrone.github.io/posts/00-hello-leetcode/">&lt;p&gt;Happy New Year!ðŸ¥³&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ve been writing about my journey with the &lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;hello-rustlings&#x2F;&quot;&gt;Rustlings exercises&lt;&#x2F;a&gt; for some time now, and these exercises are excellent for mastering the fundamentals of Rust.&lt;&#x2F;p&gt;
&lt;p&gt;If you&#x27;re not familiar with the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rustlings&#x2F;&quot;&gt;Rustlings project&lt;&#x2F;a&gt;, it&#x27;s a fantastic starting point for learning Rust. It&#x27;s interactive and quickly gets you familiar with Rust&#x27;s syntax and compiler errors. Each section also includes a README that directs you to further reading on each problem you encounter.&lt;&#x2F;p&gt;
&lt;p&gt;Having completed these exercises, I thought it would be interesting to elevate my learning by tackling LeetCode problems in Rust. I recognize that there are many solutions out there; some offer great explanations, while others do not. I also understand that there are many ways to solve these problems, so my goal is to approach each problem with both a simpler, more &amp;quot;imperative&amp;quot; style, and a more &amp;quot;functional&amp;quot; or idiomatic Rust solution.&lt;&#x2F;p&gt;
&lt;p&gt;As always, here&#x27;s my disclaimer: I&#x27;m not an expert, but I am continuing my journey of learning. I mostly do this for my own development, but if it helps others, that&#x27;s even better. I welcome your feedback and suggestions for improvement.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s start with the most basic, or at least the first question numerically on LeetCode, the literal first problem: &lt;strong&gt;1. Two Sum&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;leetcode-problem-index&quot;&gt;LeetCode Problem Index&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;01-leetcode-two-sum&#x2F;&quot;&gt;01. Two Sum&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;leetcode-roman-to-integer&#x2F;&quot;&gt;13. Roman to Integer&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;leetcode-palindrome-number&#x2F;&quot;&gt;9. Palindrome Number&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
      </item>
      <item>
          <title>26 Rustlings Conversions</title>
          <pubDate>Wed, 13 Dec 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/26-rustlings-conversions/</link>
          <guid>https://desmodrone.github.io/posts/26-rustlings-conversions/</guid>
          <description xml:base="https://desmodrone.github.io/posts/26-rustlings-conversions/">&lt;h1 id=&quot;type-conversions&quot;&gt;Type conversions&lt;&#x2F;h1&gt;
&lt;p&gt;Rust offers a multitude of ways to convert a value of a given type into another type.&lt;&#x2F;p&gt;
&lt;p&gt;The simplest form of type conversion is a type cast expression. It is denoted with the binary operator &lt;code&gt;as&lt;&#x2F;code&gt;. For instance, &lt;code&gt;println!(&amp;quot;{}&amp;quot;, 1 + 1.0);&lt;&#x2F;code&gt; would not compile, since &lt;code&gt;1&lt;&#x2F;code&gt; is an integer while &lt;code&gt;1.0&lt;&#x2F;code&gt; is a float. However, &lt;code&gt;println!(&amp;quot;{}&amp;quot;, 1 as f32 + 1.0)&lt;&#x2F;code&gt; should compile. The exercise &lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;26-rustlings-conversions&#x2F;using_as.rs&quot;&gt;&lt;code&gt;using_as&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; tries to cover this.&lt;&#x2F;p&gt;
&lt;p&gt;Rust also offers traits that facilitate type conversions upon implementation. These traits can be found under the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;convert&#x2F;index.html&quot;&gt;&lt;code&gt;convert&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; module.
The traits are the following:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;From&lt;&#x2F;code&gt; and &lt;code&gt;Into&lt;&#x2F;code&gt; covered in &lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;26-rustlings-conversions&#x2F;from_into.rs&quot;&gt;&lt;code&gt;from_into&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;TryFrom&lt;&#x2F;code&gt; and &lt;code&gt;TryInto&lt;&#x2F;code&gt; covered in &lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;26-rustlings-conversions&#x2F;try_from_into.rs&quot;&gt;&lt;code&gt;try_from_into&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;AsRef&lt;&#x2F;code&gt; and &lt;code&gt;AsMut&lt;&#x2F;code&gt; covered in &lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;26-rustlings-conversions&#x2F;as_ref_mut.rs&quot;&gt;&lt;code&gt;as_ref_mut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Furthermore, the &lt;code&gt;std::str&lt;&#x2F;code&gt; module offers a trait called &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;str&#x2F;trait.FromStr.html&quot;&gt;&lt;code&gt;FromStr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; which helps with converting strings into target types via the &lt;code&gt;parse&lt;&#x2F;code&gt; method on strings. If properly implemented for a given type &lt;code&gt;Person&lt;&#x2F;code&gt;, then &lt;code&gt;let p: Person = &amp;quot;Mark,20&amp;quot;.parse().unwrap()&lt;&#x2F;code&gt; should both compile and run without panicking.&lt;&#x2F;p&gt;
&lt;p&gt;These should be the main ways &lt;em&gt;&lt;strong&gt;within the standard library&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt; to convert data into your desired types.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;p&gt;These are not directly covered in the book, but the standard library has a great documentation for it.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;convert&#x2F;index.html&quot;&gt;conversions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;str&#x2F;trait.FromStr.html&quot;&gt;&lt;code&gt;FromStr&lt;&#x2F;code&gt; trait&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Let&#x27;s get started!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;using-as-rs&quot;&gt;Using_as.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Type casting in Rust is done via the usage of the `as` operator.
&amp;#x2F;&amp;#x2F; Please note that the `as` operator is not only used when type casting.
&amp;#x2F;&amp;#x2F; It also helps with renaming imports.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; The goal is to make sure that the division does not fail to compile
&amp;#x2F;&amp;#x2F; and returns the proper type.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint using_as` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn average(values: &amp;amp;[f64]) -&amp;gt; f64 {
    let total = values.iter().sum::&amp;lt;f64&amp;gt;();
    total &amp;#x2F; values.len()
}

fn main() {
    let values = [3.5, 0.3, 13.0, 11.7];
    println!(&amp;quot;{}&amp;quot;, average(&amp;amp;values));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn returns_proper_type_and_value() {
        assert_eq!(average(&amp;amp;[3.5, 0.3, 13.0, 11.7]), 7.125);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;our instructions tell us we can use &lt;code&gt;as&lt;&#x2F;code&gt; in a couple of different ways but in this case we&#x27;re trying to make sure that the division doesn&#x27;t fail to compile. Let&#x27;s look at the errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;using-as-rs-errors&quot;&gt;Using_as.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;error[E0277]: cannot divide `f64` by `usize`
  --&amp;gt; exercises&amp;#x2F;conversions&amp;#x2F;using_as.rs:13:11
   |
13 |     total &amp;#x2F; values.len()
   |           ^ no implementation for `f64 &amp;#x2F; usize`
   |
   = help: the trait `Div&amp;lt;usize&amp;gt;` is not implemented for `f64`
   = help: the following other types implement trait `Div&amp;lt;Rhs&amp;gt;`:
             &amp;lt;f64 as Div&amp;gt;
             &amp;lt;f64 as Div&amp;lt;&amp;amp;f64&amp;gt;&amp;gt;
             &amp;lt;&amp;amp;&amp;#x27;a f64 as Div&amp;lt;f64&amp;gt;&amp;gt;
             &amp;lt;&amp;amp;f64 as Div&amp;lt;&amp;amp;f64&amp;gt;&amp;gt;

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we&#x27;re told that the trait&lt;code&gt;Div&amp;lt;usize&amp;gt;&lt;&#x2F;code&gt; is not implemented for &lt;code&gt;f64&lt;&#x2F;code&gt;, so I think I understand why this is happening and what the solution is but let&#x27;s break it down a bit further.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;using-as-rs-solution&quot;&gt;Using_as.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;Rust is a strongly typed language, which means that it is very strict about how different types interact with each other. In this specific case, we have &lt;code&gt;total&lt;&#x2F;code&gt;, which is a &lt;code&gt;f64&lt;&#x2F;code&gt;, and &lt;code&gt;values.len()&lt;&#x2F;code&gt;, which is a &lt;code&gt;usize&lt;&#x2F;code&gt;. Rust does not implicitly convert between these types, as doing so can sometimes lead to unexpected behavior or loss of precision. Therefore, we need to explicitly convert types when they are not the same.&lt;&#x2F;p&gt;
&lt;p&gt;If we look again at &lt;code&gt;values&lt;&#x2F;code&gt; you might be thinking, &lt;em&gt;but all the values in defined in the array are &lt;code&gt;f64&lt;&#x2F;code&gt; so how does it end up a &lt;code&gt;usize&lt;&#x2F;code&gt;?&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Well, when you call the &lt;code&gt;.len()&lt;&#x2F;code&gt; method on a slice (or an array), the returned type is &lt;code&gt;usize&lt;&#x2F;code&gt;, not &lt;code&gt;f64&lt;&#x2F;code&gt;. Let&#x27;s break this down:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;What is &lt;code&gt;usize&lt;&#x2F;code&gt;?&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;usize&lt;&#x2F;code&gt; is a type in Rust that is primarily used for indexing and for sizes. Its size is determined by the architecture of the machine on which your program is running. On a 32-bit system, &lt;code&gt;usize&lt;&#x2F;code&gt; is 32 bits, and on a 64-bit system, it&#x27;s 64 bits.&lt;&#x2F;li&gt;
&lt;li&gt;It&#x27;s the type returned by the &lt;code&gt;.len()&lt;&#x2F;code&gt; method because the length of a slice or an array (or any collection, generally) is logically a count of items, which is an integer, not a floating point.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Why &lt;code&gt;.len()&lt;&#x2F;code&gt; Returns &lt;code&gt;usize&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;.len()&lt;&#x2F;code&gt; method is designed to return the number of elements in a slice or an array. Since this is essentially a count of items and is used for indexing, it returns a &lt;code&gt;usize&lt;&#x2F;code&gt;. This is a design choice in Rust to ensure type safety in memory indexing and counting operations.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;So, the solution is simple we simply add &lt;code&gt;as f64&lt;&#x2F;code&gt; to &lt;code&gt;values.len()&lt;&#x2F;code&gt; to convert the &lt;code&gt;usize&lt;&#x2F;code&gt; as &lt;code&gt;f64&lt;&#x2F;code&gt; and code should compile.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn average(values: &amp;amp;[f64]) -&amp;gt; f64 {
    let total = values.iter().sum::&amp;lt;f64&amp;gt;();
    total &amp;#x2F; values.len() as f64 &amp;#x2F;&amp;#x2F; add `as f64`
}

fn main() {
    let values = [3.5, 0.3, 13.0, 11.7];
    println!(&amp;quot;{}&amp;quot;, average(&amp;amp;values));
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;from-into-rs&quot;&gt;From_into.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; The From trait is used for value-to-value conversions.
&amp;#x2F;&amp;#x2F; If From is implemented correctly for a type, the Into trait should work conversely.
&amp;#x2F;&amp;#x2F; You can read more about it at https:&amp;#x2F;&amp;#x2F;doc.rust-lang.org&amp;#x2F;std&amp;#x2F;convert&amp;#x2F;trait.From.html
&amp;#x2F;&amp;#x2F; Execute `rustlings hint from_into` or use the `hint` watch subcommand for a hint.

#[derive(Debug)]
struct Person {
    name: String,
    age: usize,
}

&amp;#x2F;&amp;#x2F; We implement the Default trait to use it as a fallback
&amp;#x2F;&amp;#x2F; when the provided string is not convertible into a Person object
impl Default for Person {
    fn default() -&amp;gt; Person {
        Person {
            name: String::from(&amp;quot;John&amp;quot;),
            age: 30,
        }
    }
}

&amp;#x2F;&amp;#x2F; Your task is to complete this implementation
&amp;#x2F;&amp;#x2F; in order for the line `let p = Person::from(&amp;quot;Mark,20&amp;quot;)` to compile
&amp;#x2F;&amp;#x2F; Please note that you&amp;#x27;ll need to parse the age component into a `usize`
&amp;#x2F;&amp;#x2F; with something like `&amp;quot;4&amp;quot;.parse::&amp;lt;usize&amp;gt;()`. The outcome of this needs to
&amp;#x2F;&amp;#x2F; be handled appropriately.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Steps:
&amp;#x2F;&amp;#x2F; 1. If the length of the provided string is 0, then return the default of Person
&amp;#x2F;&amp;#x2F; 2. Split the given string on the commas present in it
&amp;#x2F;&amp;#x2F; 3. Extract the first element from the split operation and use it as the name
&amp;#x2F;&amp;#x2F; 4. If the name is empty, then return the default of Person
&amp;#x2F;&amp;#x2F; 5. Extract the other element from the split operation and parse it into a `usize` as the age
&amp;#x2F;&amp;#x2F; If while parsing the age, something goes wrong, then return the default of Person
&amp;#x2F;&amp;#x2F; Otherwise, then return an instantiated Person object with the results

&amp;#x2F;&amp;#x2F; I AM NOT DONE

impl From&amp;lt;&amp;amp;str&amp;gt; for Person {
    fn from(s: &amp;amp;str) -&amp;gt; Person {
    }
}

fn main() {
    &amp;#x2F;&amp;#x2F; Use the `from` function
    let p1 = Person::from(&amp;quot;Mark,20&amp;quot;);
    &amp;#x2F;&amp;#x2F; Since From is implemented for Person, we should be able to use Into
    let p2: Person = &amp;quot;Gerald,70&amp;quot;.into();
    println!(&amp;quot;{:?}&amp;quot;, p1);
    println!(&amp;quot;{:?}&amp;quot;, p2);
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_default() {
        &amp;#x2F;&amp;#x2F; Test that the default person is 30 year old John
        let dp = Person::default();
        assert_eq!(dp.name, &amp;quot;John&amp;quot;);
        assert_eq!(dp.age, 30);
    }
    #[test]
    fn test_bad_convert() {
        &amp;#x2F;&amp;#x2F; Test that John is returned when bad string is provided
        let p = Person::from(&amp;quot;&amp;quot;);
        assert_eq!(p.name, &amp;quot;John&amp;quot;);
        assert_eq!(p.age, 30);
    }
    #[test]
    fn test_good_convert() {
        &amp;#x2F;&amp;#x2F; Test that &amp;quot;Mark,20&amp;quot; works
        let p = Person::from(&amp;quot;Mark,20&amp;quot;);
        assert_eq!(p.name, &amp;quot;Mark&amp;quot;);
        assert_eq!(p.age, 20);
    }
    #[test]
    fn test_bad_age() {
        &amp;#x2F;&amp;#x2F; Test that &amp;quot;Mark,twenty&amp;quot; will return the default person due to an error in parsing age
        let p = Person::from(&amp;quot;Mark,twenty&amp;quot;);
        assert_eq!(p.name, &amp;quot;John&amp;quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_comma_and_age() {
        let p: Person = Person::from(&amp;quot;Mark&amp;quot;);
        assert_eq!(p.name, &amp;quot;John&amp;quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_age() {
        let p: Person = Person::from(&amp;quot;Mark,&amp;quot;);
        assert_eq!(p.name, &amp;quot;John&amp;quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name() {
        let p: Person = Person::from(&amp;quot;,1&amp;quot;);
        assert_eq!(p.name, &amp;quot;John&amp;quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_age() {
        let p: Person = Person::from(&amp;quot;,&amp;quot;);
        assert_eq!(p.name, &amp;quot;John&amp;quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_invalid_age() {
        let p: Person = Person::from(&amp;quot;,one&amp;quot;);
        assert_eq!(p.name, &amp;quot;John&amp;quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma() {
        let p: Person = Person::from(&amp;quot;Mike,32,&amp;quot;);
        assert_eq!(p.name, &amp;quot;John&amp;quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma_and_some_string() {
        let p: Person = Person::from(&amp;quot;Mike,32,man&amp;quot;);
        assert_eq!(p.name, &amp;quot;John&amp;quot;);
        assert_eq!(p.age, 30);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have clear instructions in the comments that tell us to complete the implementation and we even have specific steps, we&#x27;ll review those later, for now let&#x27;s look at the errors, to make sure we&#x27;re not missing anything.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;from-into-rs-errors&quot;&gt;From_into.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;conversions&amp;#x2F;from_into.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;conversions&amp;#x2F;from_into.rs:41:25
   |
41 |     fn from(s: &amp;amp;str) -&amp;gt; Person {
   |        ----             ^^^^^^ expected `Person`, found `()`
   |        |
   |        implicitly returns `()` as its body has no tail or `return` expression

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These errors are not providing much insight as we have a missing implementation&lt;&#x2F;p&gt;
&lt;h2 id=&quot;from-into-rs-solution&quot;&gt;From_into.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;To solve this exercise, we need to implement the &lt;code&gt;From&amp;lt;&amp;amp;str&amp;gt;&lt;&#x2F;code&gt; trait for the &lt;code&gt;Person&lt;&#x2F;code&gt; struct. The trait implementation should convert a string in the format &lt;code&gt;&amp;quot;Name,Age&amp;quot;&lt;&#x2F;code&gt; into a &lt;code&gt;Person&lt;&#x2F;code&gt; object. Let&#x27;s go through the steps required:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Check if the provided string is empty. If it is, return the default &lt;code&gt;Person&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Split the string on commas.&lt;&#x2F;li&gt;
&lt;li&gt;Extract the name and age from the split string.&lt;&#x2F;li&gt;
&lt;li&gt;Handle any parsing errors for the age.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Here&#x27;s the complete implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl From&amp;lt;&amp;amp;str&amp;gt; for Person {
    fn from(s: &amp;amp;str) -&amp;gt; Person {
        &amp;#x2F;&amp;#x2F; Step 1: Check if the string is empty
        if s.is_empty() {
            return Person::default();
        }

        &amp;#x2F;&amp;#x2F; Step 2: Split the string on the comma
        let parts: Vec&amp;lt;&amp;amp;str&amp;gt; = s.split(&amp;#x27;,&amp;#x27;).collect();

        &amp;#x2F;&amp;#x2F; Check for the correct number of parts (name and age)
        if parts.len() != 2 {
            return Person::default();
        }

        &amp;#x2F;&amp;#x2F; Step 3: Extract name and age
        let name = parts[0].to_string();
        let age_str = parts[1];

        &amp;#x2F;&amp;#x2F; Step 4: Handle parsing errors for age
        if name.is_empty() || age_str.is_empty() {
            return Person::default();
        }

        match age_str.parse::&amp;lt;usize&amp;gt;() {
            Ok(age) =&amp;gt; Person { name, age },
            Err(_) =&amp;gt; Person::default(),
        }
    }
}

fn main() {
    let p1 = Person::from(&amp;quot;Mark,20&amp;quot;);
    let p2: Person = &amp;quot;Gerald,70&amp;quot;.into();
    println!(&amp;quot;{:?}&amp;quot;, p1);
    println!(&amp;quot;{:?}&amp;quot;, p2);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this implementation:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The string is split into two parts based on the comma.&lt;&#x2F;li&gt;
&lt;li&gt;If the number of parts isn&#x27;t exactly 2 (name and age), or if either part is empty, the default &lt;code&gt;Person&lt;&#x2F;code&gt; is returned.&lt;&#x2F;li&gt;
&lt;li&gt;If the age part can&#x27;t be parsed into a &lt;code&gt;usize&lt;&#x2F;code&gt;, the default &lt;code&gt;Person&lt;&#x2F;code&gt; is returned.&lt;&#x2F;li&gt;
&lt;li&gt;If all conditions are met, a new &lt;code&gt;Person&lt;&#x2F;code&gt; instance is created and returned.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;With these changes our code compiles! On to the next one.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;from-str-rs&quot;&gt;From_str.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; from_str.rs
&amp;#x2F;&amp;#x2F; This is similar to from_into.rs, but this time we&amp;#x27;ll implement `FromStr`
&amp;#x2F;&amp;#x2F; and return errors instead of falling back to a default value.
&amp;#x2F;&amp;#x2F; Additionally, upon implementing FromStr, you can use the `parse` method
&amp;#x2F;&amp;#x2F; on strings to generate an object of the implementor type.
&amp;#x2F;&amp;#x2F; You can read more about it at https:&amp;#x2F;&amp;#x2F;doc.rust-lang.org&amp;#x2F;std&amp;#x2F;str&amp;#x2F;trait.FromStr.html
&amp;#x2F;&amp;#x2F; Execute `rustlings hint from_str` or use the `hint` watch subcommand for a hint.

use std::num::ParseIntError;
use std::str::FromStr;

#[derive(Debug, PartialEq)]
struct Person {
    name: String,
    age: usize,
}

&amp;#x2F;&amp;#x2F; We will use this error type for the `FromStr` implementation.
#[derive(Debug, PartialEq)]
enum ParsePersonError {
    &amp;#x2F;&amp;#x2F; Empty input string
    Empty,
    &amp;#x2F;&amp;#x2F; Incorrect number of fields
    BadLen,
    &amp;#x2F;&amp;#x2F; Empty name field
    NoName,
    &amp;#x2F;&amp;#x2F; Wrapped error from parse::&amp;lt;usize&amp;gt;()
    ParseInt(ParseIntError),
}

&amp;#x2F;&amp;#x2F; I AM NOT DONE

&amp;#x2F;&amp;#x2F; Steps:
&amp;#x2F;&amp;#x2F; 1. If the length of the provided string is 0, an error should be returned
&amp;#x2F;&amp;#x2F; 2. Split the given string on the commas present in it
&amp;#x2F;&amp;#x2F; 3. Only 2 elements should be returned from the split, otherwise return an error
&amp;#x2F;&amp;#x2F; 4. Extract the first element from the split operation and use it as the name
&amp;#x2F;&amp;#x2F; 5. Extract the other element from the split operation and parse it into a `usize` as the age
&amp;#x2F;&amp;#x2F;    with something like `&amp;quot;4&amp;quot;.parse::&amp;lt;usize&amp;gt;()`
&amp;#x2F;&amp;#x2F; 6. If while extracting the name and the age something goes wrong, an error should be returned
&amp;#x2F;&amp;#x2F; If everything goes well, then return a Result of a Person object
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; As an aside: `Box&amp;lt;dyn Error&amp;gt;` implements `From&amp;lt;&amp;amp;&amp;#x27;_ str&amp;gt;`. This means that if you want to return a
&amp;#x2F;&amp;#x2F; string error message, you can do so via just using return `Err(&amp;quot;my error message&amp;quot;.into())`.

impl FromStr for Person {
    type Err = ParsePersonError;
    fn from_str(s: &amp;amp;str) -&amp;gt; Result&amp;lt;Person, Self::Err&amp;gt; {
    }
}

fn main() {
    let p = &amp;quot;Mark,20&amp;quot;.parse::&amp;lt;Person&amp;gt;().unwrap();
    println!(&amp;quot;{:?}&amp;quot;, p);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn empty_input() {
        assert_eq!(&amp;quot;&amp;quot;.parse::&amp;lt;Person&amp;gt;(), Err(ParsePersonError::Empty));
    }
    #[test]
    fn good_input() {
        let p = &amp;quot;John,32&amp;quot;.parse::&amp;lt;Person&amp;gt;();
        assert!(p.is_ok());
        let p = p.unwrap();
        assert_eq!(p.name, &amp;quot;John&amp;quot;);
        assert_eq!(p.age, 32);
    }
    #[test]
    fn missing_age() {
        assert!(matches!(
            &amp;quot;John,&amp;quot;.parse::&amp;lt;Person&amp;gt;(),
            Err(ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn invalid_age() {
        assert!(matches!(
            &amp;quot;John,twenty&amp;quot;.parse::&amp;lt;Person&amp;gt;(),
            Err(ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn missing_comma_and_age() {
        assert_eq!(&amp;quot;John&amp;quot;.parse::&amp;lt;Person&amp;gt;(), Err(ParsePersonError::BadLen));
    }

    #[test]
    fn missing_name() {
        assert_eq!(&amp;quot;,1&amp;quot;.parse::&amp;lt;Person&amp;gt;(), Err(ParsePersonError::NoName));
    }

    #[test]
    fn missing_name_and_age() {
        assert!(matches!(
            &amp;quot;,&amp;quot;.parse::&amp;lt;Person&amp;gt;(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn missing_name_and_invalid_age() {
        assert!(matches!(
            &amp;quot;,one&amp;quot;.parse::&amp;lt;Person&amp;gt;(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn trailing_comma() {
        assert_eq!(&amp;quot;John,32,&amp;quot;.parse::&amp;lt;Person&amp;gt;(), Err(ParsePersonError::BadLen));
    }

    #[test]
    fn trailing_comma_and_some_string() {
        assert_eq!(
            &amp;quot;John,32,man&amp;quot;.parse::&amp;lt;Person&amp;gt;(),
            Err(ParsePersonError::BadLen)
        );
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have a similar exercise as before except that instead of using &lt;code&gt;from_into&lt;&#x2F;code&gt; we&#x27;ll be we&#x27;ll be using &lt;code&gt;FromStr&lt;&#x2F;code&gt;, similarly we have the instructions in the comments that tell us exactly what we need to be doing, and again we&#x27;ll look at those in detail after we look at the errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;from-str-rs-errors&quot;&gt;From_str.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;conversions&amp;#x2F;from_str.rs:48:29
   |
48 |     fn from_str(s: &amp;amp;str) -&amp;gt; Result&amp;lt;Person, Self::Err&amp;gt; {
   |        --------             ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result&amp;lt;Person, ParsePersonError&amp;gt;`, found `()`
   |        |
   |        implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `Result&amp;lt;Person, ParsePersonError&amp;gt;`
           found unit type `()`

error: aborting due to previous error

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we see that the error is related to the compiler wanting an &lt;code&gt;enum&lt;&#x2F;code&gt; type or essentially a &lt;code&gt;Result&lt;&#x2F;code&gt; type but it found a &lt;code&gt;()&lt;&#x2F;code&gt; type because our solution isn&#x27;t implemented yet.  So, let&#x27;s fix that.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;from-str-rs-solution&quot;&gt;From_str.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;Before we implement a solution let&#x27;s make sure we&#x27;re all on the same page here with the &lt;code&gt;FromStr&lt;&#x2F;code&gt; trait.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;understanding-the-fromstr-trait&quot;&gt;Understanding the FromStr Trait&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Purpose of FromStr:&lt;&#x2F;strong&gt; The FromStr trait in Rust is used for converting a string into another type. In this case, we are converting a string into a Person struct.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Why Use FromStr:&lt;&#x2F;strong&gt; Implementing FromStr allows you to use the parse method on strings, which simplifies the conversion process. This is particularly useful when you want to turn user input (which is often in string format) into more complex data types.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;breaking-down-the-implementation&quot;&gt;Breaking Down the Implementation&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Error Handling:&lt;&#x2F;strong&gt;
The FromStr trait requires you to define an error type. In this example, ParsePersonError is used to represent different kinds of errors that might occur during parsing (like empty input, incorrect format, etc.).
Using custom error types makes your code more robust and easier to debug.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Parsing Logic:&lt;&#x2F;strong&gt;
The input string is split on commas, assuming the format &lt;code&gt;name,age&lt;&#x2F;code&gt;.
The code then checks if the input is correctly formatted and handles each part (name and age) separately.
The parse method is used to convert the age from a string to a &lt;code&gt;usize&lt;&#x2F;code&gt;. If this fails, the error is captured and returned.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Creating the Person Object:&lt;&#x2F;strong&gt;
If all validations pass, a new Person object is created with the parsed name and age.
This object is then returned as a Result&amp;lt;Person, ParsePersonError&amp;gt;, indicating a successful parsing or an error.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl FromStr for Person {
    type Err = ParsePersonError;

    fn from_str(s: &amp;amp;str) -&amp;gt; Result&amp;lt;Person, Self::Err&amp;gt; {
        &amp;#x2F;&amp;#x2F; Check if the input string is empty
        if s.is_empty() {
            return Err(ParsePersonError::Empty);
        }

        &amp;#x2F;&amp;#x2F; Split the input string on the comma
        let parts: Vec&amp;lt;&amp;amp;str&amp;gt; = s.split(&amp;#x27;,&amp;#x27;).collect();
        &amp;#x2F;&amp;#x2F; Ensure that there are exactly two parts (name and age)
        if parts.len() != 2 {
            return Err(ParsePersonError::BadLen);
        }

        &amp;#x2F;&amp;#x2F; Extract the first part as the name
        let name = parts[0].to_string();
        &amp;#x2F;&amp;#x2F; Ensure that the name is not empty
        if name.is_empty() {
            return Err(ParsePersonError::NoName);
        }

        &amp;#x2F;&amp;#x2F; Parse the second part as age and handle any parsing errors
        let age = parts[1].parse::&amp;lt;usize&amp;gt;().map_err(ParsePersonError::ParseInt)?;

        &amp;#x2F;&amp;#x2F; Return a Person object if all is well
        Ok(Person { name, age })
    }
}

fn main() {
    let p = &amp;quot;Mark,20&amp;quot;.parse::&amp;lt;Person&amp;gt;().unwrap();
    println!(&amp;quot;{:?}&amp;quot;, p);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This code does the following:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Error Checking&lt;&#x2F;strong&gt;: It checks for empty input, an incorrect number of fields, and parsing errors for the age field.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;String Splitting and Parsing&lt;&#x2F;strong&gt;: It splits the input string by a comma, extracting the name and age, and attempts to parse the age as an &lt;code&gt;usize&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Error Handling&lt;&#x2F;strong&gt;: It uses custom error types to handle different error scenarios such as empty input, no name, or parsing errors.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Person Creation&lt;&#x2F;strong&gt;: If all checks pass, it creates and returns a &lt;code&gt;Person&lt;&#x2F;code&gt; object.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Testing with Main&lt;&#x2F;strong&gt;: The &lt;code&gt;main&lt;&#x2F;code&gt; function demonstrates how to parse a string to create a &lt;code&gt;Person&lt;&#x2F;code&gt; object, using the implemented &lt;code&gt;from_str&lt;&#x2F;code&gt; method.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;additional-notes-on-this-exercise&quot;&gt;Additional Notes on this Exercise&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Real-world Application&lt;&#x2F;strong&gt;: Parsing user input is a common requirement in many applications. Understanding how to do it properly in Rust is crucial for writing robust software.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Learning Rustâ€™s Conventions&lt;&#x2F;strong&gt;: Rust emphasizes safety and clear error handling. Implementing &lt;code&gt;FromStr&lt;&#x2F;code&gt; with comprehensive error checking is a great exercise in learning these aspects of Rust.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Hands-on Practice&lt;&#x2F;strong&gt;: By working through this example, beginners get practical experience with common Rust concepts like traits, error handling, and generics.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;With the changes above our code is compiling and we can move on to our next exercise!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;try-from-into-rs&quot;&gt;Try_from_into.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; try_from_into.rs
&amp;#x2F;&amp;#x2F; TryFrom is a simple and safe type conversion that may fail in a controlled way under some circumstances.
&amp;#x2F;&amp;#x2F; Basically, this is the same as From. The main difference is that this should return a Result type
&amp;#x2F;&amp;#x2F; instead of the target type itself.
&amp;#x2F;&amp;#x2F; You can read more about it at https:&amp;#x2F;&amp;#x2F;doc.rust-lang.org&amp;#x2F;std&amp;#x2F;convert&amp;#x2F;trait.TryFrom.html
&amp;#x2F;&amp;#x2F; Execute `rustlings hint try_from_into` or use the `hint` watch subcommand for a hint.

use std::convert::{TryFrom, TryInto};

#[derive(Debug, PartialEq)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

&amp;#x2F;&amp;#x2F; We will use this error type for these `TryFrom` conversions.
#[derive(Debug, PartialEq)]
enum IntoColorError {
    &amp;#x2F;&amp;#x2F; Incorrect length of slice
    BadLen,
    &amp;#x2F;&amp;#x2F; Integer conversion error
    IntConversion,
}

&amp;#x2F;&amp;#x2F; I AM NOT DONE

&amp;#x2F;&amp;#x2F; Your task is to complete this implementation
&amp;#x2F;&amp;#x2F; and return an Ok result of inner type Color.
&amp;#x2F;&amp;#x2F; You need to create an implementation for a tuple of three integers,
&amp;#x2F;&amp;#x2F; an array of three integers, and a slice of integers.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Note that the implementation for tuple and array will be checked at compile time,
&amp;#x2F;&amp;#x2F; but the slice implementation needs to check the slice length!
&amp;#x2F;&amp;#x2F; Also note that correct RGB color values must be integers in the 0..=255 range.

&amp;#x2F;&amp;#x2F; Tuple implementation
impl TryFrom&amp;lt;(i16, i16, i16)&amp;gt; for Color {
    type Error = IntoColorError;
    fn try_from(tuple: (i16, i16, i16)) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; {
    }
}

&amp;#x2F;&amp;#x2F; Array implementation
impl TryFrom&amp;lt;[i16; 3]&amp;gt; for Color {
    type Error = IntoColorError;
    fn try_from(arr: [i16; 3]) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; {
    }
}

&amp;#x2F;&amp;#x2F; Slice implementation
impl TryFrom&amp;lt;&amp;amp;[i16]&amp;gt; for Color {
    type Error = IntoColorError;
    fn try_from(slice: &amp;amp;[i16]) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; {
    }
}

fn main() {
    &amp;#x2F;&amp;#x2F; Use the `try_from` function
    let c1 = Color::try_from((183, 65, 14));
    println!(&amp;quot;{:?}&amp;quot;, c1);

    &amp;#x2F;&amp;#x2F; Since TryFrom is implemented for Color, we should be able to use TryInto
    let c2: Result&amp;lt;Color, _&amp;gt; = [183, 65, 14].try_into();
    println!(&amp;quot;{:?}&amp;quot;, c2);

    let v = vec![183, 65, 14];
    &amp;#x2F;&amp;#x2F; With slice we should use `try_from` function
    let c3 = Color::try_from(&amp;amp;v[..]);
    println!(&amp;quot;{:?}&amp;quot;, c3);
    &amp;#x2F;&amp;#x2F; or take slice within round brackets and use TryInto
    let c4: Result&amp;lt;Color, _&amp;gt; = (&amp;amp;v[..]).try_into();
    println!(&amp;quot;{:?}&amp;quot;, c4);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tuple_out_of_range_positive() {
        assert_eq!(
            Color::try_from((256, 1000, 10000)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_out_of_range_negative() {
        assert_eq!(
            Color::try_from((-1, -10, -256)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_sum() {
        assert_eq!(
            Color::try_from((-1, 255, 255)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_correct() {
        let c: Result&amp;lt;Color, _&amp;gt; = (183, 65, 14).try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_array_out_of_range_positive() {
        let c: Result&amp;lt;Color, _&amp;gt; = [1000, 10000, 256].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_out_of_range_negative() {
        let c: Result&amp;lt;Color, _&amp;gt; = [-10, -256, -1].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_sum() {
        let c: Result&amp;lt;Color, _&amp;gt; = [-1, 255, 255].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_correct() {
        let c: Result&amp;lt;Color, _&amp;gt; = [183, 65, 14].try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_slice_out_of_range_positive() {
        let arr = [10000, 256, 1000];
        assert_eq!(
            Color::try_from(&amp;amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_out_of_range_negative() {
        let arr = [-256, -1, -10];
        assert_eq!(
            Color::try_from(&amp;amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_sum() {
        let arr = [-1, 255, 255];
        assert_eq!(
            Color::try_from(&amp;amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_correct() {
        let v = vec![183, 65, 14];
        let c: Result&amp;lt;Color, _&amp;gt; = Color::try_from(&amp;amp;v[..]);
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_slice_excess_length() {
        let v = vec![0, 0, 0, 0];
        assert_eq!(Color::try_from(&amp;amp;v[..]), Err(IntoColorError::BadLen));
    }
    #[test]
    fn test_slice_insufficient_length() {
        let v = vec![0, 0];
        assert_eq!(Color::try_from(&amp;amp;v[..]), Err(IntoColorError::BadLen));
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this exercise, our specific task is to implement the TryFrom trait for a Color struct, catering to different types of inputs: tuples, arrays, and slices of i16. Each of these inputs represents potential RGB color values. The challenge involves not only facilitating these conversions but also meticulously handling potential errors. This includes managing out-of-range color values and ensuring that inputs, especially slices, are of appropriate lengths. By doing so, we aim to leverage Rust&#x27;s robust type conversion capabilities while adhering to its strict safety and error-handling principles.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;try-from-into-errors-rs&quot;&gt;Try_from_into Errors.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;conversions&amp;#x2F;try_from_into.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;conversions&amp;#x2F;try_from_into.rs:40:44
   |
40 |     fn try_from(tuple: (i16, i16, i16)) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; {
   |        --------                            ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result&amp;lt;Color, IntoColorError&amp;gt;`, found `()`
   |        |
   |        implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `Result&amp;lt;Color, IntoColorError&amp;gt;`
           found unit type `()`

error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;conversions&amp;#x2F;try_from_into.rs:47:35
   |
47 |     fn try_from(arr: [i16; 3]) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; {
   |        --------                   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result&amp;lt;Color, IntoColorError&amp;gt;`, found `()`
   |        |
   |        implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `Result&amp;lt;Color, IntoColorError&amp;gt;`
           found unit type `()`

error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;conversions&amp;#x2F;try_from_into.rs:54:35
   |
54 |     fn try_from(slice: &amp;amp;[i16]) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; {
   |        --------                   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result&amp;lt;Color, IntoColorError&amp;gt;`, found `()`
   |        |
   |        implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `Result&amp;lt;Color, IntoColorError&amp;gt;`
           found unit type `()`

error: aborting due to 3 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler errors we&#x27;re encountering are due to mismatched types in our &lt;code&gt;try_from&lt;&#x2F;code&gt; function implementations. These functions currently return the unit type &lt;code&gt;()&lt;&#x2F;code&gt;, but they are expected to return a &lt;code&gt;Result&amp;lt;Color, IntoColorError&amp;gt;&lt;&#x2F;code&gt;. The errors indicate that the body of each implementation is empty and lacks the necessary logic to perform the conversion and return the correct type.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;try-from-into-solution&quot;&gt;Try_from_into Solution&lt;&#x2F;h2&gt;
&lt;p&gt;To resolve these errors and fulfill the exercise&#x27;s requirements, we&#x27;ll need to implement the &lt;code&gt;TryFrom&lt;&#x2F;code&gt; trait for tuples &lt;code&gt;(i16, i16, i16)&lt;&#x2F;code&gt;, arrays &lt;code&gt;[i16; 3]&lt;&#x2F;code&gt;, and slices &lt;code&gt;&amp;amp;[i16]&lt;&#x2F;code&gt; with the following considerations:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Range Validation&lt;&#x2F;strong&gt;: Ensure that each color value (red, green, blue) is within the 0 to 255 range. If any value is outside this range, return an &lt;code&gt;Err&lt;&#x2F;code&gt; with &lt;code&gt;IntoColorError::IntConversion&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Handling Slice Length&lt;&#x2F;strong&gt;: For the slice implementation, check that the length of the slice is exactly 3. If not, return an &lt;code&gt;Err&lt;&#x2F;code&gt; with &lt;code&gt;IntoColorError::BadLen&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Type Conversion&lt;&#x2F;strong&gt;: Convert the valid &lt;code&gt;i16&lt;&#x2F;code&gt; values to &lt;code&gt;u8&lt;&#x2F;code&gt; for constructing the &lt;code&gt;Color&lt;&#x2F;code&gt; struct, and return &lt;code&gt;Ok(Color)&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Here&#x27;s an overview of how the implementations should look:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Tuple, array, and slice implementations for TryFrom
impl TryFrom&amp;lt;(i16, i16, i16)&amp;gt; for Color { &amp;#x2F;* ... *&amp;#x2F; }
impl TryFrom&amp;lt;[i16; 3]&amp;gt; for Color { &amp;#x2F;* ... *&amp;#x2F; }
impl TryFrom&amp;lt;&amp;amp;[i16]&amp;gt; for Color { &amp;#x2F;* ... *&amp;#x2F; }

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In each case, we ensure proper error handling and validation, adhering to the &lt;code&gt;TryFrom&lt;&#x2F;code&gt; trait&#x27;s requirements.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;complete-code&quot;&gt;Complete Code&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl TryFrom&amp;lt;(i16, i16, i16)&amp;gt; for Color {
    type Error = IntoColorError;

    fn try_from(tuple: (i16, i16, i16)) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; {
        let (red, green, blue) = tuple;
        if red &amp;lt; 0 || red &amp;gt; 255 || green &amp;lt; 0 || green &amp;gt; 255 || blue &amp;lt; 0 || blue &amp;gt; 255 {
            return Err(IntoColorError::IntConversion);
        }
        Ok(Color {
            red: red as u8,
            green: green as u8,
            blue: blue as u8,
        })
    }
}

impl TryFrom&amp;lt;[i16; 3]&amp;gt; for Color {
    type Error = IntoColorError;

    fn try_from(arr: [i16; 3]) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; {
        let [red, green, blue] = arr;
        if red &amp;lt; 0 || red &amp;gt; 255 || green &amp;lt; 0 || green &amp;gt; 255 || blue &amp;lt; 0 || blue &amp;gt; 255 {
            return Err(IntoColorError::IntConversion);
        }
        Ok(Color {
            red: red as u8,
            green: green as u8,
            blue: blue as u8,
        })
    }
}

impl TryFrom&amp;lt;&amp;amp;[i16]&amp;gt; for Color {
    type Error = IntoColorError;

    fn try_from(slice: &amp;amp;[i16]) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; {
        if slice.len() != 3 {
            return Err(IntoColorError::BadLen);
        }
        let [red, green, blue] = match slice.try_into() {
            Ok(arr) =&amp;gt; arr,
            Err(_) =&amp;gt; return Err(IntoColorError::IntConversion),
        };
        if red &amp;lt; 0 || red &amp;gt; 255 || green &amp;lt; 0 || green &amp;gt; 255 || blue &amp;lt; 0 || blue &amp;gt; 255 {
            return Err(IntoColorError::IntConversion);
        }
        Ok(Color {
            red: red as u8,
            green: green as u8,
            blue: blue as u8,
        })
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This implementation includes:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Tuple, Array, and Slice Implementations&lt;&#x2F;strong&gt;: It implements &lt;code&gt;TryFrom&lt;&#x2F;code&gt; for a tuple of three &lt;code&gt;i16&lt;&#x2F;code&gt;s, an array of three &lt;code&gt;i16&lt;&#x2F;code&gt;s, and a slice of &lt;code&gt;i16&lt;&#x2F;code&gt;s.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Error Handling&lt;&#x2F;strong&gt;: It checks for valid RGB values (0 to 255) and handles errors accordingly using the &lt;code&gt;IntoColorError&lt;&#x2F;code&gt; enum.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Length Check for Slice&lt;&#x2F;strong&gt;: For the slice implementation, it checks if the length of the slice is exactly 3, which is crucial for correct color value extraction.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Type Conversions&lt;&#x2F;strong&gt;: The valid &lt;code&gt;i16&lt;&#x2F;code&gt; values are safely converted to &lt;code&gt;u8&lt;&#x2F;code&gt; for the &lt;code&gt;Color&lt;&#x2F;code&gt; struct fields.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This exercise demonstrates the importance and utility of the &lt;code&gt;TryFrom&lt;&#x2F;code&gt; trait in Rust for handling fallible conversions. By carefully implementing &lt;code&gt;TryFrom&lt;&#x2F;code&gt;, we can create robust and error-resilient code, especially when working with data that requires validation or has specific constraints, like our &lt;code&gt;Color&lt;&#x2F;code&gt; struct in this case.&lt;&#x2F;p&gt;
&lt;p&gt;With these updates our code is now compiling.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;as-ref-mut-rs&quot;&gt;As_ref_mut.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; AsRef and AsMut allow for cheap reference-to-reference conversions.
&amp;#x2F;&amp;#x2F; Read more about them at https:&amp;#x2F;&amp;#x2F;doc.rust-lang.org&amp;#x2F;std&amp;#x2F;convert&amp;#x2F;trait.AsRef.html
&amp;#x2F;&amp;#x2F; and https:&amp;#x2F;&amp;#x2F;doc.rust-lang.org&amp;#x2F;std&amp;#x2F;convert&amp;#x2F;trait.AsMut.html, respectively.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint as_ref_mut` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

&amp;#x2F;&amp;#x2F; Obtain the number of bytes (not characters) in the given argument.
&amp;#x2F;&amp;#x2F; TODO: Add the AsRef trait appropriately as a trait bound.
fn byte_counter&amp;lt;T&amp;gt;(arg: T) -&amp;gt; usize {
    arg.as_ref().as_bytes().len()
}

&amp;#x2F;&amp;#x2F; Obtain the number of characters (not bytes) in the given argument.
&amp;#x2F;&amp;#x2F; TODO: Add the AsRef trait appropriately as a trait bound.
fn char_counter&amp;lt;T&amp;gt;(arg: T) -&amp;gt; usize {
    arg.as_ref().chars().count()
}

&amp;#x2F;&amp;#x2F; Squares a number using as_mut().
&amp;#x2F;&amp;#x2F; TODO: Add the appropriate trait bound.
fn num_sq&amp;lt;T&amp;gt;(arg: &amp;amp;mut T) {
    &amp;#x2F;&amp;#x2F; TODO: Implement the function body.
    ???
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn different_counts() {
        let s = &amp;quot;CafÃ© au lait&amp;quot;;
        assert_ne!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn same_counts() {
        let s = &amp;quot;Cafe au lait&amp;quot;;
        assert_eq!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn different_counts_using_string() {
        let s = String::from(&amp;quot;CafÃ© au lait&amp;quot;);
        assert_ne!(char_counter(s.clone()), byte_counter(s));
    }

    #[test]
    fn same_counts_using_string() {
        let s = String::from(&amp;quot;Cafe au lait&amp;quot;);
        assert_eq!(char_counter(s.clone()), byte_counter(s));
    }

    #[test]
    fn mult_box() {
        let mut num: Box&amp;lt;u32&amp;gt; = Box::new(3);
        num_sq(&amp;amp;mut num);
        assert_eq!(*num, 9);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this exercise, the objective is to correctly implement the &lt;code&gt;AsRef&lt;&#x2F;code&gt; and &lt;code&gt;AsMut&lt;&#x2F;code&gt; traits. These traits are crucial for type conversion in Rust, allowing for flexible yet safe conversions between different types.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;exercise-tasks&quot;&gt;Exercise Tasks&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Implement &lt;code&gt;byte_counter&lt;&#x2F;code&gt; and &lt;code&gt;char_counter&lt;&#x2F;code&gt; Functions&lt;&#x2F;strong&gt;: These functions should work with any type that can be converted to a string slice (&lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;), thus requiring the implementation of the &lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; trait.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Implement &lt;code&gt;num_sq&lt;&#x2F;code&gt; Function&lt;&#x2F;strong&gt;: This function is intended to mutate a numeric value. It should work with any type that can provide a mutable reference to a &lt;code&gt;u32&lt;&#x2F;code&gt;, necessitating the use of the &lt;code&gt;AsMut&amp;lt;u32&amp;gt;&lt;&#x2F;code&gt; trait. Let&#x27;s review the errors.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;as-ref-mut-rs-errors&quot;&gt;As_ref_mut.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;conversions&amp;#x2F;as_ref_mut.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;conversions&amp;#x2F;as_ref_mut.rs:24:5
   |
24 |     ???
   |     ^ expected expression

error[E0599]: no method named `as_ref` found for type parameter `T` in the current scope
  --&amp;gt; exercises&amp;#x2F;conversions&amp;#x2F;as_ref_mut.rs:11:9
   |
10 | fn byte_counter&amp;lt;T&amp;gt;(arg: T) -&amp;gt; usize {
   |                 - method `as_ref` not found for this type parameter
11 |     arg.as_ref().as_bytes().len()
   |         ^^^^^^ method not found in `T`
   |
   = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `as_ref`, perhaps you need to restrict type parameter `T` with it:
   |
10 | fn byte_counter&amp;lt;T: AsRef&amp;gt;(arg: T) -&amp;gt; usize {
   |                  +++++++

error[E0599]: no method named `as_ref` found for type parameter `T` in the current scope
  --&amp;gt; exercises&amp;#x2F;conversions&amp;#x2F;as_ref_mut.rs:17:9
   |
16 | fn char_counter&amp;lt;T&amp;gt;(arg: T) -&amp;gt; usize {
   |                 - method `as_ref` not found for this type parameter
17 |     arg.as_ref().chars().count()
   |         ^^^^^^ method not found in `T`
   |
   = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `as_ref`, perhaps you need to restrict type parameter `T` with it:
   |
16 | fn char_counter&amp;lt;T: AsRef&amp;gt;(arg: T) -&amp;gt; usize {
   |                  +++++++

error: aborting due to 3 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The errors encountered during compilation are primarily due to:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Missing Trait Bounds&lt;&#x2F;strong&gt;: Functions &lt;code&gt;byte_counter&lt;&#x2F;code&gt; and &lt;code&gt;char_counter&lt;&#x2F;code&gt; are trying to use &lt;code&gt;as_ref()&lt;&#x2F;code&gt; without the type &lt;code&gt;T&lt;&#x2F;code&gt; being bounded by &lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;&#x2F;code&gt;. This results in the error that the method &lt;code&gt;as_ref&lt;&#x2F;code&gt; is not found for the generic type &lt;code&gt;T&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Incomplete Implementation&lt;&#x2F;strong&gt;: The &lt;code&gt;num_sq&lt;&#x2F;code&gt; function has an incomplete implementation, indicated by the placeholder &lt;code&gt;???&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;as-ref-mut-rs-solution&quot;&gt;As_ref_mut.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;Here&#x27;s how to implement the &lt;code&gt;AsRef&lt;&#x2F;code&gt; and &lt;code&gt;AsMut&lt;&#x2F;code&gt; traits in this Rust exercise:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;byte_counter&lt;&#x2F;code&gt; and &lt;code&gt;char_counter&lt;&#x2F;code&gt; Functions&lt;&#x2F;strong&gt;:
&lt;ul&gt;
&lt;li&gt;These functions are designed to work with any type &lt;code&gt;T&lt;&#x2F;code&gt; that can be referenced as a string slice (&lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;By specifying &lt;code&gt;T: AsRef&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; as the trait bound, you&#x27;re indicating that these functions can accept any type &lt;code&gt;T&lt;&#x2F;code&gt; that implements the &lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;&#x2F;code&gt; trait.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;arg.as_ref()&lt;&#x2F;code&gt; converts &lt;code&gt;arg&lt;&#x2F;code&gt; into a string slice, on which you can then call &lt;code&gt;.as_bytes()&lt;&#x2F;code&gt; or &lt;code&gt;.chars()&lt;&#x2F;code&gt; to get the length in bytes or characters, respectively.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;num_sq&lt;&#x2F;code&gt; Function&lt;&#x2F;strong&gt;:
&lt;ul&gt;
&lt;li&gt;This function is supposed to mutate a numeric value.&lt;&#x2F;li&gt;
&lt;li&gt;By using &lt;code&gt;T: AsMut&amp;lt;u32&amp;gt;&lt;&#x2F;code&gt;, you&#x27;re specifying that it accepts a mutable reference to any type &lt;code&gt;T&lt;&#x2F;code&gt; that can be mutated into a &lt;code&gt;u32&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Inside the function, &lt;code&gt;*arg.as_mut()&lt;&#x2F;code&gt; gives you a mutable reference to the inner &lt;code&gt;u32&lt;&#x2F;code&gt;, which you then square.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::convert::AsRef;
use std::convert::AsMut;

fn byte_counter&amp;lt;T: AsRef&amp;lt;str&amp;gt;&amp;gt;(arg: T) -&amp;gt; usize {
    arg.as_ref().as_bytes().len()
}

fn char_counter&amp;lt;T: AsRef&amp;lt;str&amp;gt;&amp;gt;(arg: T) -&amp;gt; usize {
    arg.as_ref().chars().count()
}

fn num_sq&amp;lt;T: AsMut&amp;lt;u32&amp;gt;&amp;gt;(arg: &amp;amp;mut T) {
    let value = arg.as_mut();
    *value *= *value;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And with that we are done we are compiling!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In conclusion, Rust&#x27;s comprehensive type conversion system, including &lt;code&gt;as&lt;&#x2F;code&gt;, &lt;code&gt;From&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;Into&lt;&#x2F;code&gt;, &lt;code&gt;TryFrom&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;TryInto&lt;&#x2F;code&gt;, &lt;code&gt;FromStr&lt;&#x2F;code&gt;, &lt;code&gt;AsRef&lt;&#x2F;code&gt;, and &lt;code&gt;AsMut&lt;&#x2F;code&gt;, provides programmers with a versatile toolkit to handle various scenarios of type conversions safely and efficiently.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;as&lt;&#x2F;code&gt; Operator&lt;&#x2F;strong&gt;: Essential for basic type casting, especially when dealing with primitive data types. It&#x27;s a straightforward way to convert between compatible types, ensuring that the programmer explicitly acknowledges and handles the conversion.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;From&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;Into&lt;&#x2F;code&gt; Traits&lt;&#x2F;strong&gt;: These traits offer a more Rust-idiomatic way of handling infallible conversions between types. They simplify code and reduce boilerplate, making conversions more readable and intuitive.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;TryFrom&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;TryInto&lt;&#x2F;code&gt; Traits&lt;&#x2F;strong&gt;: They extend the capabilities of &lt;code&gt;From&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;Into&lt;&#x2F;code&gt; to include fallible conversions, where there&#x27;s a possibility of failure. This is particularly important in Rust, which emphasizes safety and error handling.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;FromStr&lt;&#x2F;code&gt; Trait&lt;&#x2F;strong&gt;: Tailored for parsing strings into other types, &lt;code&gt;FromStr&lt;&#x2F;code&gt; is crucial in scenarios where data comes as strings (like user input or file reading) and needs to be converted to more specific types.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;AsRef&lt;&#x2F;code&gt; and &lt;code&gt;AsMut&lt;&#x2F;code&gt; Traits&lt;&#x2F;strong&gt;: They facilitate cheap, non-owning conversions to references, allowing functions to accept a wide variety of arguments without sacrificing performance or flexibility. This is particularly useful in generic programming.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Together, these mechanisms contribute to Rust&#x27;s robust type system, ensuring that type conversions are handled explicitly and safely, reducing the risk of errors and increasing the overall reliability of the code. By understanding and utilizing these tools effectively, you can write Rust code that is both efficient and elegant.&lt;&#x2F;p&gt;
&lt;p&gt;And with that we are DONE! I hope you&#x27;ve enjoyed going through these exercises with me.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;ðŸŽ‰ All exercises completed! ðŸŽ‰

+----------------------------------------------------+
|          You made it to the Fe-nish line!          |
+--------------------------  ------------------------+
                          \\&amp;#x2F;
     â–’â–’          â–’â–’â–’â–’â–’â–’â–’â–’      â–’â–’â–’â–’â–’â–’â–’â–’          â–’â–’
   â–’â–’â–’â–’  â–’â–’    â–’â–’        â–’â–’  â–’â–’        â–’â–’    â–’â–’  â–’â–’â–’â–’
   â–’â–’â–’â–’  â–’â–’  â–’â–’            â–’â–’            â–’â–’  â–’â–’  â–’â–’â–’â–’
 â–‘â–‘â–’â–’â–’â–’â–‘â–‘â–’â–’  â–’â–’            â–’â–’            â–’â–’  â–’â–’â–‘â–‘â–’â–’â–’â–’
   â–“â–“â–“â–“â–“â–“â–“â–“  â–“â–“      â–“â–“â–ˆâ–ˆ  â–“â–“  â–“â–“â–ˆâ–ˆ      â–“â–“  â–“â–“â–“â–“â–“â–“â–“â–“
     â–’â–’â–’â–’    â–’â–’      â–ˆâ–ˆâ–ˆâ–ˆ  â–’â–’  â–ˆâ–ˆâ–ˆâ–ˆ      â–’â–’â–‘â–‘  â–’â–’â–’â–’
       â–’â–’  â–’â–’â–’â–’â–’â–’        â–’â–’â–’â–’â–’â–’        â–’â–’â–’â–’â–’â–’  â–’â–’
         â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–“â–“â–’â–’â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’
           â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’
             â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’â–’
           â–’â–’  â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–’â–’â–’â–’  â–’â–’
         â–’â–’    â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’    â–’â–’
       â–’â–’    â–’â–’    â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’    â–’â–’    â–’â–’
       â–’â–’  â–’â–’    â–’â–’                  â–’â–’    â–’â–’  â–’â–’
           â–’â–’  â–’â–’                      â–’â–’  â–’â–’

We hope you enjoyed learning about the various aspects of Rust!
If you noticed any issues, please don&amp;#x27;t hesitate to report them to our repo.
You can also contribute your own exercises to help the greater community!
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
      </item>
      <item>
          <title>25 Rustlings Clippy</title>
          <pubDate>Thu, 30 Nov 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/25-rustlings-clippy/</link>
          <guid>https://desmodrone.github.io/posts/25-rustlings-clippy/</guid>
          <description xml:base="https://desmodrone.github.io/posts/25-rustlings-clippy/">&lt;p&gt;The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.&lt;&#x2F;p&gt;
&lt;p&gt;If you used the installation script for Rustlings, Clippy should be already installed.
If not you can install it manually via &lt;code&gt;rustup component add clippy&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust-clippy&quot;&gt;GitHub Repository&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;clippy1-rs&quot;&gt;Clippy1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; clippy1.rs
&amp;#x2F;&amp;#x2F; The Clippy tool is a collection of lints to analyze your code
&amp;#x2F;&amp;#x2F; so you can catch common mistakes and improve your Rust code.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; For these exercises the code will fail to compile when there are clippy warnings
&amp;#x2F;&amp;#x2F; check clippy&amp;#x27;s suggestions from the output to solve the exercise.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint clippy1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::f32;

fn main() {
    let pi = 3.14f32;
    let radius = 5.00f32;

    let area = pi * f32::powi(radius, 2);

    println!(
        &amp;quot;The area of a circle with radius {:.2} is {:.5}!&amp;quot;,
        radius, area
    )
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are straight forward make the code compile and use Clippy&#x27;s suggestions to make it happen. So let&#x27;s look at the error&#x27;s and suggestions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;clippy1-rs-errors&quot;&gt;Clippy1.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;Progress: [######################################################&amp;gt;-----] 86&amp;#x2F;94 (90.4 %)
âš ï¸  Compiling of exercises&amp;#x2F;clippy&amp;#x2F;clippy1.rs failed! Please try again. Here&amp;#x27;s the output:
    Checking clippy1 v0.0.1 (&amp;#x2F;Users&amp;#x2F;desmo&amp;#x2F;Projects&amp;#x2F;rustlings&amp;#x2F;exercises&amp;#x2F;clippy)
error: approximate value of `f32::consts::PI` found
  --&amp;gt; clippy1.rs:14:14
   |
14 |     let pi = 3.14f32;
   |              ^^^^^^^
   |
   = help: consider using the constant directly
   = help: for further information visit https:&amp;#x2F;&amp;#x2F;rust-lang.github.io&amp;#x2F;rust-clippy&amp;#x2F;master&amp;#x2F;index.html#approx_constant
   = note: `#[deny(clippy::approx_constant)]` on by default

error: could not compile `clippy1` (bin &amp;quot;clippy1&amp;quot;) due to previous error
Welcome to watch mode! You can type &amp;#x27;help&amp;#x27; to get an overview of the commands you can use here.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So Clippy doesn&#x27;t like us using an approximate value of &lt;code&gt;PI&lt;&#x2F;code&gt; with &lt;code&gt;3.14f32&lt;&#x2F;code&gt; instead it suggests for us to use use the constant directly, there&#x27;s even a link let&#x27;s take a look at it in the solution.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;clippy2-rs-solution&quot;&gt;Clippy2.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;re given the &lt;a href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;master&#x2F;index.html#&#x2F;approx_constant&quot;&gt;approx_constant&lt;&#x2F;a&gt; link above which if you click, I&#x27;ll save you the trouble and summarize what is shows:&lt;&#x2F;p&gt;
&lt;h2 id=&quot;approx-constant&quot;&gt;approx_constant&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;what-it-does&quot;&gt;What it does&lt;&#x2F;h3&gt;
&lt;p&gt;Checks for floating point literals that approximate constants which are defined inÂ &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;f32&#x2F;consts&#x2F;#constants&quot;&gt;&lt;code&gt;std::f32::consts&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;Â orÂ &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;f64&#x2F;consts&#x2F;#constants&quot;&gt;&lt;code&gt;std::f64::consts&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, respectively, suggesting to use the predefined constant.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;why-is-this-bad&quot;&gt;Why is this bad?&lt;&#x2F;h3&gt;
&lt;p&gt;Usually, the definition in the standard library is more precise than what people come up with. If you find that your definition is actually more precise, pleaseÂ &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&quot;&gt;file a Rust issue&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;example&quot;&gt;Example&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;let x = 3.14;
let y = 1_f64 &amp;#x2F; x;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Use instead:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;let x = std::f32::consts::PI;
let y = std::f64::consts::FRAC_1_PI;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;applying-pi&quot;&gt;Applying &lt;code&gt;PI&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We clearly see above that Clippy doesn&#x27;t like us to use our own approximate value and wants us to import the &lt;code&gt;std::f32::consts::PI&lt;&#x2F;code&gt; from the standard library. So let&#x27;s do that, but instead of using it in the variable, which is fine as they have done in the example, it might be easier to read and also use later in code if we import it with &lt;code&gt;use&lt;&#x2F;code&gt;  and later just use &lt;code&gt;PI&lt;&#x2F;code&gt; in our variable...let&#x27;s try that.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::f32::consts::PI;

fn main() {
    let pi = PI;
    let radius = 5.00f32;

    let area = pi * f32::powi(radius, 2);

    println!(
        &amp;quot;The area of a circle with radius {:.2} is {:.5}!&amp;quot;,
        radius, area
    )
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And with this we are compiling, of course you are free to use the other method of access &lt;code&gt;PI&lt;&#x2F;code&gt; directly by not importing it at the top of your code and then only modifying the &lt;code&gt;pi&lt;&#x2F;code&gt; variable like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let pi = std::f32::consts::PI;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Either way will compile and Clippy will be happy.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âœ… Successfully compiled exercises&amp;#x2F;clippy&amp;#x2F;clippy1.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling, and ðŸ“Ž Clippy ðŸ“Ž is happy! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;clippy2-rs&quot;&gt;Clippy2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; clippy2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint clippy2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let mut res = 42;
    let option = Some(12);
    for x in option {
        res += x;
    }
    println!(&amp;quot;{}&amp;quot;, res);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here&#x27; we don&#x27;t get any additional instructions but with a quick glance at the code, it seems that something doesn&#x27;t seem quite right, but let&#x27;s inspect the errors and see if we get additional details.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;clippy2-rs-errors&quot;&gt;Clippy2.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;Checking clippy2 v0.0.1 (&amp;#x2F;Users&amp;#x2F;desmo&amp;#x2F;Projects&amp;#x2F;rustlings&amp;#x2F;exercises&amp;#x2F;clippy)
error: for loop over an `Option`. This is more readably written as an `if let` statement
 --&amp;gt; clippy2.rs:9:14
  |
9 |     for x in option {
  |              ^^^^^^
  |
  = note: `-D for-loops-over-fallibles` implied by `-D warnings`
  = help: to override `-D warnings` add `#[allow(for_loops_over_fallibles)]`
help: to check pattern in a loop use `while let`
  |
9 |     while let Some(x) = option {
  |     ~~~~~~~~~~~~~~~ ~~~
help: consider using `if let` to clear intent
  |
9 |     if let Some(x) = option {
  |     ~~~~~~~~~~~~ ~~~

error: could not compile `clippy2` (bin &amp;quot;clippy2&amp;quot;) due to previous error

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So, we&#x27;re getting a clear error with:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;`for loop over an `Option`. This is more readably written as an `if let` statement`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;clippy2-rs-solution-1&quot;&gt;Clippy2.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;Because we have an &lt;code&gt;Option&lt;&#x2F;code&gt; here, we should use either &lt;code&gt;if let&lt;&#x2F;code&gt; or &lt;code&gt;while let&lt;&#x2F;code&gt; which essentially tells our code that &lt;em&gt;if (or while) there is something&lt;&#x2F;em&gt; inside of our &lt;code&gt;option&lt;&#x2F;code&gt; variable, we should then put that something inside of &lt;code&gt;option&lt;&#x2F;code&gt; and increment &lt;code&gt;option&lt;&#x2F;code&gt; by &lt;code&gt;res&lt;&#x2F;code&gt; in this case 42, &lt;em&gt;if&lt;&#x2F;em&gt; there is &lt;code&gt;None&lt;&#x2F;code&gt; then do nothing.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let mut res = 42;
    let option = Some(12);

	  &amp;#x2F;&amp;#x2F; updated with `if let` here
        if let Some(x) = option {
            res += x;
        }

    println!(&amp;quot;{}&amp;quot;, res);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;if we were to print this we would see &lt;code&gt;54&lt;&#x2F;code&gt; as the output.&lt;&#x2F;p&gt;
&lt;p&gt;So with that updated &lt;code&gt;if let&lt;&#x2F;code&gt; our code compiles and we make Clippy happy again:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âœ… Successfully compiled exercises&amp;#x2F;clippy&amp;#x2F;clippy2.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling, and ðŸ“Ž Clippy ðŸ“Ž is happy! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;clippy3-rs&quot;&gt;Clippy3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; clippy3.rs
&amp;#x2F;&amp;#x2F; Here&amp;#x27;s a couple more easy Clippy fixes, so you can see its utility.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[allow(unused_variables, unused_assignments)]
fn main() {
    let my_option: Option&amp;lt;()&amp;gt; = None;
    if my_option.is_none() {
        my_option.unwrap();
    }

    let my_arr = &amp;amp;[
        -1, -2, -3
        -4, -5, -6
    ];
    println!(&amp;quot;My array! Here it is: {:?}&amp;quot;, my_arr);

    let my_empty_vec = vec![1, 2, 3, 4, 5].resize(0, 5);
    println!(&amp;quot;This Vec is empty, see? {:?}&amp;quot;, my_empty_vec);

    let mut value_a = 45;
    let mut value_b = 66;
    &amp;#x2F;&amp;#x2F; Let&amp;#x27;s swap these two!
    value_a = value_b;
    value_b = value_a;
    println!(&amp;quot;value a: {}; value b: {}&amp;quot;, value_a, value_b);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;re told that we have a couple of more easy Clippy fixes so we see how useful it is. Alright let&#x27;s look at the errors.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;clippy&amp;#x2F;clippy3.rs failed! Please try again. Here&amp;#x27;s the output:
    Checking clippy3 v0.0.1 (&amp;#x2F;Users&amp;#x2F;desmo&amp;#x2F;Projects&amp;#x2F;rustlings&amp;#x2F;exercises&amp;#x2F;clippy)
error: possibly missing a comma here
  --&amp;gt; clippy3.rs:14:19
   |
14 |         -1, -2, -3
   |                   ^
   |
   = note: to remove this lint, add a comma or write the expr in a single line
   = help: for further information visit https:&amp;#x2F;&amp;#x2F;rust-lang.github.io&amp;#x2F;rust-clippy&amp;#x2F;master&amp;#x2F;index.html#possible_missing_comma
   = note: `#[deny(clippy::possible_missing_comma)]` on by default

error: this call to `unwrap()` will always panic
  --&amp;gt; clippy3.rs:10:9
   |
9  |     if my_option.is_none() {
   |        ------------------- because of this check
10 |         my_option.unwrap();
   |         ^^^^^^^^^^^^^^^^^^
   |
   = help: for further information visit https:&amp;#x2F;&amp;#x2F;rust-lang.github.io&amp;#x2F;rust-clippy&amp;#x2F;master&amp;#x2F;index.html#panicking_unwrap
   = note: `#[deny(clippy::panicking_unwrap)]` on by default

error: this looks like you are trying to swap `value_a` and `value_b`
  --&amp;gt; clippy3.rs:25:5
   |
25 | &amp;#x2F;     value_a = value_b;
26 | |     value_b = value_a;
   | |_____________________^ help: try: `std::mem::swap(&amp;amp;mut value_a, &amp;amp;mut value_b)`
   |
   = note: or maybe you should use `std::mem::replace`?
   = help: for further information visit https:&amp;#x2F;&amp;#x2F;rust-lang.github.io&amp;#x2F;rust-clippy&amp;#x2F;master&amp;#x2F;index.html#almost_swapped
   = note: `#[deny(clippy::almost_swapped)]` on by default

error: used `unwrap()` on `None` value
  --&amp;gt; clippy3.rs:10:9
   |
10 |         my_option.unwrap();
   |         ^^^^^^^^^^^^^^^^^^
   |
help: remove the `None` and `unwrap()`
  --&amp;gt; clippy3.rs:8:33
   |
8  |     let my_option: Option&amp;lt;()&amp;gt; = None;
   |                                 ^^^^
   = help: for further information visit https:&amp;#x2F;&amp;#x2F;rust-lang.github.io&amp;#x2F;rust-clippy&amp;#x2F;master&amp;#x2F;index.html#unnecessary_literal_unwrap
   = note: `-D clippy::unnecessary-literal-unwrap` implied by `-D warnings`
   = help: to override `-D warnings` add `#[allow(clippy::unnecessary_literal_unwrap)]`

error: this let-binding has unit value
  --&amp;gt; clippy3.rs:19:5
   |
19 |     let my_empty_vec = vec![1, 2, 3, 4, 5].resize(0, 5);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: omit the `let` binding: `vec![1, 2, 3, 4, 5].resize(0, 5);`
   |
   = help: for further information visit https:&amp;#x2F;&amp;#x2F;rust-lang.github.io&amp;#x2F;rust-clippy&amp;#x2F;master&amp;#x2F;index.html#let_unit_value
   = note: `-D clippy::let-unit-value` implied by `-D warnings`
   = help: to override `-D warnings` add `#[allow(clippy::let_unit_value)]`

error: could not compile `clippy3` (bin &amp;quot;clippy3&amp;quot;) due to 5 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright looks like we have a lot of work to do here going through each of them one by one and see how we can get this code to compile.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;clippy3-rs-solution&quot;&gt;Clippy3.rs Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[allow(unused_variables, unused_assignments)]
fn main() {
    let my_option: Option&amp;lt;()&amp;gt; = None;
    if my_option.is_none() {
        my_option.unwrap();
    }

    let my_arr = &amp;amp;[
        -1, -2, -3
        -4, -5, -6
    ];
    println!(&amp;quot;My array! Here it is: {:?}&amp;quot;, my_arr);

    let my_empty_vec = vec![1, 2, 3, 4, 5].resize(0, 5);
    println!(&amp;quot;This Vec is empty, see? {:?}&amp;quot;, my_empty_vec);

    let mut value_a = 45;
    let mut value_b = 66;
    &amp;#x2F;&amp;#x2F; Let&amp;#x27;s swap these two!
    value_a = value_b;
    value_b = value_a;
    println!(&amp;quot;value a: {}; value b: {}&amp;quot;, value_a, value_b);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;error-1&quot;&gt;Error 1&lt;&#x2F;h3&gt;
&lt;p&gt;Our first error focuses on &lt;code&gt;my_arr&lt;&#x2F;code&gt; where it seems like we&#x27;re missing a comma.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;error: possibly missing a comma here
  --&amp;gt; clippy3.rs:14:19
   |
14 |         -1, -2, -3
   |                   ^
   |
   = note: to remove this lint, add a comma or write the expr in a single line
   = help: for further information visit https:&amp;#x2F;&amp;#x2F;rust-lang.github.io&amp;#x2F;rust-clippy&amp;#x2F;master&amp;#x2F;index.html#possible_missing_comma
   = note: `#[deny(clippy::possible_missing_comma)]` on by default
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So by adding the comma after the &lt;code&gt;-3,&lt;&#x2F;code&gt; this issue is fixed.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;error-2&quot;&gt;Error 2&lt;&#x2F;h3&gt;
&lt;p&gt;This error is highlighting a misuse of the &lt;code&gt;unwrap()&lt;&#x2F;code&gt; method on an &lt;code&gt;Option&lt;&#x2F;code&gt; type. Specifically, it&#x27;s warning against calling &lt;code&gt;unwrap()&lt;&#x2F;code&gt; on an &lt;code&gt;Option&lt;&#x2F;code&gt; that is &lt;em&gt;known&lt;&#x2F;em&gt; to be &lt;code&gt;None&lt;&#x2F;code&gt;, as this will always cause a panic at runtime.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;error: this call to `unwrap()` will always panic
  --&amp;gt; clippy3.rs:10:9
   |
9  |     if my_option.is_none() {
   |        ------------------- because of this check
10 |         my_option.unwrap();
   |         ^^^^^^^^^^^^^^^^^^
   |
   = help: for further information visit https:&amp;#x2F;&amp;#x2F;rust-lang.github.io&amp;#x2F;rust-clippy&amp;#x2F;master&amp;#x2F;index.html#panicking_unwrap
   = note: `#[deny(clippy::panicking_unwrap)]` on by default
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This code checks if &lt;code&gt;my_option&lt;&#x2F;code&gt; is &lt;code&gt;None&lt;&#x2F;code&gt;, and if so, attempts to &lt;code&gt;unwrap&lt;&#x2F;code&gt; it, which is exactly the pattern Clippy is advising against. It&#x27;s logically inconsistent to check for &lt;code&gt;None&lt;&#x2F;code&gt; and then &lt;code&gt;unwrap&lt;&#x2F;code&gt; it, as &lt;code&gt;unwrap&lt;&#x2F;code&gt; is meant for situations where you are sure the &lt;code&gt;Option&lt;&#x2F;code&gt; is &lt;code&gt;Some&lt;&#x2F;code&gt;. So what do we do, just remove the &lt;code&gt;if&lt;&#x2F;code&gt; check so this error goes away.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;error-3&quot;&gt;Error 3&lt;&#x2F;h3&gt;
&lt;p&gt;Here Clippy understands that we&#x27;re trying to swap values and advises us to use &lt;code&gt;std::mem::swap&lt;&#x2F;code&gt;. Again, I prefer to use the &lt;code&gt;use&lt;&#x2F;code&gt; key word to import just to keep the code a little bit cleaner.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;error: this looks like you are trying to swap `value_a` and `value_b`
  --&amp;gt; clippy3.rs:25:5
   |
25 | &amp;#x2F;     value_a = value_b;
26 | |     value_b = value_a;
   | |_____________________^ help: try: `std::mem::swap(&amp;amp;mut value_a, &amp;amp;mut value_b)`
   |
   = note: or maybe you should use `std::mem::replace`?
   = help: for further information visit https:&amp;#x2F;&amp;#x2F;rust-lang.github.io&amp;#x2F;rust-clippy&amp;#x2F;master&amp;#x2F;index.html#almost_swapped
   = note: `#[deny(clippy::almost_swapped)]` on by default
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So our updated code would look like this.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; import at the top of the file
use std::mem::swap;

&amp;#x2F;&amp;#x2F; -- snippet -- &amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Swapping Values

let mut value_a = 45;
let mut value_b = 66;

&amp;#x2F;&amp;#x2F; Let&amp;#x27;s swap these two!
swap(&amp;amp;mut value_a, &amp;amp;mut value_b);

println!(&amp;quot;value a: {}; value b: {}&amp;quot;, value_a, value_b);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;error-4&quot;&gt;Error 4&lt;&#x2F;h3&gt;
&lt;p&gt;Our final error is related to wanting to create an empty &lt;code&gt;Vec&lt;&#x2F;code&gt; it looks like currently we are creating and then resizing, which is a waste of effort if all we want is an empty Vector.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;error: this let-binding has unit value
  --&amp;gt; clippy3.rs:19:5
   |
19 |     let my_empty_vec = vec![1, 2, 3, 4, 5].resize(0, 5);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: omit the `let` binding: `vec![1, 2, 3, 4, 5].resize(0, 5);`
   |
   = help: for further information visit https:&amp;#x2F;&amp;#x2F;rust-lang.github.io&amp;#x2F;rust-clippy&amp;#x2F;master&amp;#x2F;index.html#let_unit_value
   = note: `-D clippy::let-unit-value` implied by `-D warnings`
   = help: to override `-D warnings` add `#[allow(clippy::let_unit_value)]`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There&#x27;s a couple of ways to solve it but probably the easiest is to just remove the elements from the vector and the &lt;code&gt;.resize()&lt;&#x2F;code&gt; method at the end.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_empty_vec: Vec&amp;lt;i32&amp;gt; = vec![];
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;re also asked to define it&#x27;s type but that&#x27;s pretty straightforward with &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt; right before the empty &lt;code&gt;vec![]&lt;&#x2F;code&gt; macro. Here&#x27;s the final code for reference.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::mem::swap;
#[allow(unused_variables, unused_assignments)]
fn main() {
    let my_option: Option&amp;lt;()&amp;gt; = None;

    &amp;#x2F;&amp;#x2F; array
    let my_arr = &amp;amp;[
        -1, -2, -3,
        -4, -5, -6
    ];
    println!(&amp;quot;My array! Here it is: {:?}&amp;quot;, my_arr);

    &amp;#x2F;&amp;#x2F; Create empty Vector
    let my_empty_vec: Vec&amp;lt;i32&amp;gt; = vec![];
    println!(&amp;quot;This Vec is empty, see? {:?}&amp;quot;, my_empty_vec);

    &amp;#x2F;&amp;#x2F; Swapping Values
    let mut value_a = 45;
    let mut value_b = 66;

    &amp;#x2F;&amp;#x2F; Let&amp;#x27;s swap these two!
    swap(&amp;amp;mut value_a, &amp;amp;mut value_b);

    println!(&amp;quot;value a: {}; value b: {}&amp;quot;, value_a, value_b);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;with these changes Clippy is once again a happy camper:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âœ… Successfully compiled exercises&amp;#x2F;clippy&amp;#x2F;clippy3.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling, and ðŸ“Ž Clippy ðŸ“Ž is happy! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In conclusion, navigating through Rust&#x27;s Clippy lints is not only an exercise in resolving compile-time errors but also a journey into the depths of idiomatic Rust programming. Clippy, as a linter, serves a pivotal role in guiding developers towards best practices, ensuring code reliability, and maintaining the high standards of Rust&#x27;s safety guarantees.&lt;&#x2F;p&gt;
&lt;p&gt;Through the examples of &lt;code&gt;clippy1.rs&lt;&#x2F;code&gt;, &lt;code&gt;clippy2.rs&lt;&#x2F;code&gt;, and &lt;code&gt;clippy3.rs&lt;&#x2F;code&gt;, we saw common pitfalls and learned how to address them effectively. Whether it was using the precise value of &lt;code&gt;PI&lt;&#x2F;code&gt; in &lt;code&gt;clippy1.rs&lt;&#x2F;code&gt;, embracing the &lt;code&gt;if let&lt;&#x2F;code&gt; construct for &lt;code&gt;Option&lt;&#x2F;code&gt; types in &lt;code&gt;clippy2.rs&lt;&#x2F;code&gt;, or understanding the importance of proper array syntax and variable swapping in &lt;code&gt;clippy3.rs&lt;&#x2F;code&gt;, each scenario brought its unique learning experience.&lt;&#x2F;p&gt;
&lt;p&gt;These exercises underscore the importance of attention to detail and the nuances of the Rust language. Clippy acts not just as a linter but as an educator, reinforcing the Rust philosophy of writing clear, efficient, and safe code. As Rust continues to evolve, tools like Clippy will remain invaluable for developers, whether they are beginners just starting their Rust journey or experienced coders refining their craft. In the world of Rust, Clippy is more than a tool; it&#x27;s a companion on the path to mastering one of the most promising systems programming languages of our time.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>24 Rustlings Macros</title>
          <pubDate>Tue, 21 Nov 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/24-rustlings-macros/</link>
          <guid>https://desmodrone.github.io/posts/24-rustlings-macros/</guid>
          <description xml:base="https://desmodrone.github.io/posts/24-rustlings-macros/">&lt;p&gt;Rust&#x27;s macro system is very powerful, but also kind of difficult to wrap your
head around. We&#x27;re not going to teach you how to write your own fully-featured
macros. Instead, we&#x27;ll show you how to use and create them.&lt;&#x2F;p&gt;
&lt;p&gt;If you&#x27;d like to learn more about writing your own macros, the
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tfpk&#x2F;macrokata&quot;&gt;macrokata&lt;&#x2F;a&gt; project has a similar style
of exercises to Rustlings, but is all about learning to write Macros.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-06-macros.html&quot;&gt;Macros&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;veykril.github.io&#x2F;tlborm&#x2F;&quot;&gt;The Little Book of Rust Macros&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;macros1-rs&quot;&gt;Macros1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; macros1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint macros1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

macro_rules! my_macro {
    () =&amp;gt; {
        println!(&amp;quot;Check out my macro!&amp;quot;);
    };
}

fn main() {
    my_macro();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This looks like a fairly simple exercise using Macros, let&#x27;s take a look at the errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;macros1-rs-errors&quot;&gt;Macros1.rs Errors&lt;&#x2F;h2&gt;
&lt;p&gt;The Rust compiler tells us directly what the problem is, we&#x27;re missing the &lt;code&gt;!&lt;&#x2F;code&gt; symbol to call our macro, just like we do for &lt;code&gt;println!&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;error[E0423]: expected function, found macro `my_macro`
  --&amp;gt; exercises&amp;#x2F;macros&amp;#x2F;macros1.rs:13:5
   |
13 |     my_macro();
   |     ^^^^^^^^ not a function
   |
help: use `!` to invoke the macro
   |
13 |     my_macro!();
   |             +

error: aborting due to previous error; 1 warning emitted
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;macros1-rs-solution&quot;&gt;Macros1.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;Following the instructions from the compiler message and simply adding the &lt;code&gt;!&lt;&#x2F;code&gt; to our calling of &lt;code&gt;my_macro&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;macro_rules! my_macro {
    () =&amp;gt; {
        println!(&amp;quot;Check out my macro!&amp;quot;);
    };
}

fn main() {
    my_macro!();  &amp;#x2F;&amp;#x2F; adding `!` here
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With that we have our code compiling and first macro exercise done.
Output:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âœ… Successfully ran exercises&amp;#x2F;macros&amp;#x2F;macros1.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰

Output:
====================
Check out my macro!

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;macros2-rs&quot;&gt;Macros2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; macros2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint macros2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    my_macro!();
}

macro_rules! my_macro {
    () =&amp;gt; {
        println!(&amp;quot;Check out my macro!&amp;quot;);
    };
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This one doesn&#x27;t give us any instruction but we can see the code is not compiling. Let&#x27;s look at the errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;macros2-rs-errors&quot;&gt;Macros2.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt; --&amp;gt; exercises&amp;#x2F;macros&amp;#x2F;macros2.rs:7:5
  |
7 |     my_macro!();
  |     ^^^^^^^^
  |
  = help: have you added the `#[macro_use]` on the module&amp;#x2F;import?

warning: unused macro definition: `my_macro`
  --&amp;gt; exercises&amp;#x2F;macros&amp;#x2F;macros2.rs:10:14
   |
10 | macro_rules! my_macro {
   |              ^^^^^^^^
   |
   = note: `#[warn(unused_macros)]` on by default

error: aborting due to previous error; 1 warning emitted
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can see errors about not having the &lt;code&gt;#[macro_use]&lt;&#x2F;code&gt; module imported, but I&#x27;m not sure if that&#x27;s exactly what is wrong here. Let&#x27;s see if there&#x27;s an easy way to solve this problem below.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;macros2-rs-solution&quot;&gt;Macros2.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;The solution is rather simple, we have to change the placement of the &lt;code&gt;macro_rules!&lt;&#x2F;code&gt; function an place it before the &lt;code&gt;fn main()&lt;&#x2F;code&gt;. The reason is that macro&#x27;s don&#x27;t abide by the same set of rules that the rest of Rust does, in the sense that order does matter. So you have to define a macro before you can use it. So simply declaring it before calling it, or in our case copy and pasting &lt;code&gt;my_macro&lt;&#x2F;code&gt; before &lt;code&gt;fn main()&lt;&#x2F;code&gt; and everything should work.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;macro_rules! my_macro {
    () =&amp;gt; {
        println!(&amp;quot;Check out my macro!&amp;quot;);
    };
}

fn main() {
    my_macro!();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It compiles and prints out the same message as before. So we&#x27;re done here.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;macros3-rs&quot;&gt;Macros3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; macros3.rs
&amp;#x2F;&amp;#x2F; Make me compile, without taking the macro out of the module!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint macros3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

mod macros {
    macro_rules! my_macro {
        () =&amp;gt; {
            println!(&amp;quot;Check out my macro!&amp;quot;);
        };
    }
}

fn main() {
    my_macro!();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;it looks like we have a very similar set of lines here with this exercise except that we have the &lt;code&gt;mod macros&lt;&#x2F;code&gt; encapsulating our &lt;code&gt;my_macro&lt;&#x2F;code&gt; definition.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;macros3-rs-errors&quot;&gt;Macros3.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;error: cannot find macro `my_macro` in this scope
  --&amp;gt; exercises&amp;#x2F;macros&amp;#x2F;macros3.rs:16:5
   |
16 |     my_macro!();
   |     ^^^^^^^^
   |
   = help: have you added the `#[macro_use]` on the module&amp;#x2F;import?

warning: unused macro definition: `my_macro`
 --&amp;gt; exercises&amp;#x2F;macros&amp;#x2F;macros3.rs:8:18
  |
8 |     macro_rules! my_macro {
  |                  ^^^^^^^^
  |
  = note: `#[warn(unused_macros)]` on by default
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So here we see the similar message about &lt;code&gt;#[macro_use]&lt;&#x2F;code&gt; but this time we might have a legitimate reason to use it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;macros3-rs-solution&quot;&gt;Macros3.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;So since we have the &lt;code&gt;my_macro&lt;&#x2F;code&gt; macro wrapped in the &lt;code&gt;mod macro&lt;&#x2F;code&gt;  we nee to use the &lt;code&gt;#[macro_use]&lt;&#x2F;code&gt; to allow use of the macro outside of the module.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; adding this line here
#[macro_use]
mod macros {
    macro_rules! my_macro {
        () =&amp;gt; {
            println!(&amp;quot;Check out my macro!&amp;quot;);
        };
    }
}

fn main() {
    my_macro!();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once again with this change we are compiling and printing &lt;code&gt;Check out my macro!&lt;&#x2F;code&gt; as before.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;macros4-rs&quot;&gt;Macros4.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; macros4.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint macros4` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[rustfmt::skip]
macro_rules! my_macro {
    () =&amp;gt; {
        println!(&amp;quot;Check out my macro!&amp;quot;);
    }
    ($val:expr) =&amp;gt; {
        println!(&amp;quot;Look at this other macro: {}&amp;quot;, $val);
    }
}

fn main() {
    my_macro!();
    my_macro!(7777);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see an expanded version of our macro that has an additional arm with that prints out a value if you give it one. But of course we&#x27;re not compiling right now with how the code is constructed. So, let&#x27;s look at the errors for any additional hints.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;macros4-rs-errors&quot;&gt;Macros4.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;macros&amp;#x2F;macros4.rs failed! Please try again. Here&amp;#x27;s the output:
error: no rules expected the token `(`
  --&amp;gt; exercises&amp;#x2F;macros&amp;#x2F;macros4.rs:11:5
   |
11 |     ($val:expr) =&amp;gt; {
   |     ^ no rules expected this token in macro call

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The error we&#x27;re seeing is that it was expecting a token,  specifically the &lt;code&gt;(&lt;&#x2F;code&gt; but for some reason it&#x27;s not seeing it. Typically when we&#x27;re trying to compile our code when we see this type of error it is because we are missing something between our blocks of code. What could that be?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;macros4-rs-solution&quot;&gt;Macros4.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;This solution is again painfully simple all we need to do to get this to compile is properly separate the arms of the macro by adding &lt;code&gt;;&lt;&#x2F;code&gt; at the end of the first macro. This let&#x27;s the Rust compiler know that we&#x27;ve ended the first arm of our macro so it then knows we have 2 different arms in the &lt;code&gt;my_macro&lt;&#x2F;code&gt; macro.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[rustfmt::skip]
macro_rules! my_macro {
    () =&amp;gt; {
        println!(&amp;quot;Check out my macro!&amp;quot;);
    };
    ($val:expr) =&amp;gt; {
        println!(&amp;quot;Look at this other macro: {}&amp;quot;, $val);
    }
}

fn main() {
    my_macro!();
    my_macro!(7777);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;with this we have our code compiling and printing:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âœ… Successfully ran exercises&amp;#x2F;macros&amp;#x2F;macros4.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰

Output:
====================
Check out my macro!
Look at this other macro: 7777

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Working with macros in Rust can initially seem daunting due to their unique syntax and behavior. However, as we&#x27;ve seen in these exercises, common issues often have straightforward solutions once you understand how macros operate. Remember, macros are expanded at compile time, and their scope and definition order matter. By practicing with examples and understanding the error messages, you can become more comfortable with using and creating macros in Rust. They are a powerful tool in the Rust programmer&#x27;s toolkit, enabling more expressive and flexible code. Keep experimenting and exploring the Rust documentation and community resources to deepen your understanding of macros and their capabilities in Rust programming.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>23 Rustlings Smart Pointers</title>
          <pubDate>Fri, 17 Nov 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/23-rustlings-smart-pointers/</link>
          <guid>https://desmodrone.github.io/posts/23-rustlings-smart-pointers/</guid>
          <description xml:base="https://desmodrone.github.io/posts/23-rustlings-smart-pointers/">&lt;p&gt;In Rust, smart pointers are variables that contain an address in memory and reference some other data, but they also have additional metadata and capabilities.
Smart pointers in Rust often own the data they point to, while references only borrow data.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further Information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch15-00-smart-pointers.html&quot;&gt;Smart Pointers&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch15-01-box.html&quot;&gt;Using Box to Point to Data on the Heap&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch15-04-rc.html&quot;&gt;Rc&amp;lt;T&amp;gt;, the Reference Counted Smart Pointer&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch16-03-shared-state.html&quot;&gt;Shared-State Concurrency&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;borrow&#x2F;enum.Cow.html&quot;&gt;Cow Documentation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;box1-rs&quot;&gt;Box1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; box1.rs
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; At compile time, Rust needs to know how much space a type takes up. This becomes problematic
&amp;#x2F;&amp;#x2F; for recursive types, where a value can have as part of itself another value of the same type.
&amp;#x2F;&amp;#x2F; To get around the issue, we can use a `Box` - a smart pointer used to store data on the heap,
&amp;#x2F;&amp;#x2F; which also allows us to wrap a recursive type.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; The recursive type we&amp;#x27;re implementing in this exercise is the `cons list` - a data structure
&amp;#x2F;&amp;#x2F; frequently found in functional programming languages. Each item in a cons list contains two
&amp;#x2F;&amp;#x2F; elements: the value of the current item and the next item. The last item is a value called `Nil`.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Step 1: use a `Box` in the enum definition to make the code compile
&amp;#x2F;&amp;#x2F; Step 2: create both empty and non-empty cons lists by replacing `todo!()`
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Note: the tests should not be changed
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Execute `rustlings hint box1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[derive(PartialEq, Debug)]
pub enum List {
    Cons(i32, List),
    Nil,
}

fn main() {
    println!(&amp;quot;This is an empty cons list: {:?}&amp;quot;, create_empty_list());
    println!(
        &amp;quot;This is a non-empty cons list: {:?}&amp;quot;,
        create_non_empty_list()
    );
}

pub fn create_empty_list() -&amp;gt; List {
    todo!()
}

pub fn create_non_empty_list() -&amp;gt; List {
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_empty_list() {
        assert_eq!(List::Nil, create_empty_list())
    }

    #[test]
    fn test_create_non_empty_list() {
        assert_ne!(create_empty_list(), create_non_empty_list())
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are pretty clear, we have to first, make our code compile and then complete a couple of functions and make the program pass the tests.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Step 1: use a &lt;code&gt;Box&lt;&#x2F;code&gt; in the enum definition to make the code compile&lt;&#x2F;li&gt;
&lt;li&gt;Step 2: create both empty and non-empty cons lists by replacing &lt;code&gt;todo!()&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;box1-rs-errors&quot;&gt;Box1.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;smart_pointers&amp;#x2F;box1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0072]: recursive type `List` has infinite size
  --&amp;gt; exercises&amp;#x2F;smart_pointers&amp;#x2F;box1.rs:22:1
   |
22 | pub enum List {
   | ^^^^^^^^^^^^^
23 |     Cons(i32, List),
   |               ---- recursive without indirection
   |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;amp;`) to break the cycle
   |
23 |     Cons(i32, Box&amp;lt;List&amp;gt;),
   |               ++++    +

error: aborting due to previous error

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we see the Rust compiler is suggesting to use a &lt;code&gt;Box&amp;lt;&amp;gt;&lt;&#x2F;code&gt; in our &lt;code&gt;enum&lt;&#x2F;code&gt; this seems like a reasonable suggestion and we should use that and see&lt;&#x2F;p&gt;
&lt;h2 id=&quot;box1-rs-solution&quot;&gt;Box1.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s take what the Rust compiler suggests and see what happens.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
  #[derive(PartialEq, Debug)]
pub enum List {
    Cons(i32, Box&amp;lt;List&amp;gt;),  &amp;#x2F;&amp;#x2F; Adding `Box&amp;lt;&amp;gt;` here
    Nil,
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By adding the &lt;code&gt;Box&amp;lt;List&amp;gt;&lt;&#x2F;code&gt; to our &lt;code&gt;Cons&lt;&#x2F;code&gt; variant, our code now compiles but our tests are not passing, but that should be expected as we know we have &lt;code&gt;todo!&lt;&#x2F;code&gt; macros that we need to complete.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;empty-list-todo&quot;&gt;Empty List &lt;code&gt;todo!&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s take a look at our first &lt;code&gt;todo!&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn create_empty_list() -&amp;gt; List {
    todo!()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;by also looking at the test we see that we should trying to get to pass&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[test]
fn test_create_empty_list() {
    assert_eq!(List::Nil, create_empty_list())
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Simply put, we need our function to return &lt;code&gt;List::Nil&lt;&#x2F;code&gt; so let&#x27;s update our function to match:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn create_empty_list() -&amp;gt; List {
    List::Nil
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we are passing our first test:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;running 2 tests
test tests::test_create_empty_list ... ok
test tests::test_create_non_empty_list ... FAILED
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;non-empty-listtodo&quot;&gt;Non-Empty List&lt;code&gt;todo!&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Our instructions for our second &lt;code&gt;todo!&lt;&#x2F;code&gt; are &lt;em&gt;Step 2: create both empty and non-empty cons lists by replacing &lt;code&gt;todo!()&lt;&#x2F;code&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn create_non_empty_list() -&amp;gt; List {
    todo!()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So let&#x27;s see how we can do that.&lt;&#x2F;p&gt;
&lt;p&gt;If we look at our &lt;code&gt;List&lt;&#x2F;code&gt; enum we see that &lt;code&gt;Cons&lt;&#x2F;code&gt; variant has both an &lt;code&gt;i32&lt;&#x2F;code&gt; and the &lt;code&gt;Box&amp;lt;List&amp;gt;&lt;&#x2F;code&gt; that we just added to get the code to compile. So to make our function &lt;code&gt;create_non_empty_list()&lt;&#x2F;code&gt; compile we have to pass in both and &lt;code&gt;i32&lt;&#x2F;code&gt; and create a new &lt;code&gt;List&lt;&#x2F;code&gt; right? let&#x27;s try.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn create_non_empty_list() -&amp;gt; List {
    List::Cons(3, Box::new(List::Nil))
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And with this our code compiles, let&#x27;s have a look at the full block for reference&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
  #[derive(PartialEq, Debug)]
pub enum List {
    Cons(i32, Box&amp;lt;List&amp;gt;),
    Nil,
}

fn main() {
    println!(&amp;quot;This is an empty cons list: {:?}&amp;quot;, create_empty_list());
    println!(
        &amp;quot;This is a non-empty cons list: {:?}&amp;quot;,
        create_non_empty_list()
    );
}

pub fn create_empty_list() -&amp;gt; List {
    List::Nil
}

pub fn create_non_empty_list() -&amp;gt; List {

    List::Cons(3,Box::new(List::Nil))
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s move on to the next exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rc1-rs&quot;&gt;Rc1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; rc1.rs
&amp;#x2F;&amp;#x2F; In this exercise, we want to express the concept of multiple owners via the Rc&amp;lt;T&amp;gt; type.
&amp;#x2F;&amp;#x2F; This is a model of our solar system - there is a Sun type and multiple Planets.
&amp;#x2F;&amp;#x2F; The Planets take ownership of the sun, indicating that they revolve around the sun.

&amp;#x2F;&amp;#x2F; Make this code compile by using the proper Rc primitives to express that the sun has multiple owners.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::rc::Rc;

#[derive(Debug)]
struct Sun {}

#[derive(Debug)]
enum Planet {
    Mercury(Rc&amp;lt;Sun&amp;gt;),
    Venus(Rc&amp;lt;Sun&amp;gt;),
    Earth(Rc&amp;lt;Sun&amp;gt;),
    Mars(Rc&amp;lt;Sun&amp;gt;),
    Jupiter(Rc&amp;lt;Sun&amp;gt;),
    Saturn(Rc&amp;lt;Sun&amp;gt;),
    Uranus(Rc&amp;lt;Sun&amp;gt;),
    Neptune(Rc&amp;lt;Sun&amp;gt;),
}

impl Planet {
    fn details(&amp;amp;self) {
        println!(&amp;quot;Hi from {:?}!&amp;quot;, self)
    }
}

fn main() {
    let sun = Rc::new(Sun {});
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 1 reference

    let mercury = Planet::Mercury(Rc::clone(&amp;amp;sun));
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 2 references
    mercury.details();

    let venus = Planet::Venus(Rc::clone(&amp;amp;sun));
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 3 references
    venus.details();

    let earth = Planet::Earth(Rc::clone(&amp;amp;sun));
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 4 references
    earth.details();

    let mars = Planet::Mars(Rc::clone(&amp;amp;sun));
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 5 references
    mars.details();

    let jupiter = Planet::Jupiter(Rc::clone(&amp;amp;sun));
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 6 references
    jupiter.details();

    &amp;#x2F;&amp;#x2F; TODO
    let saturn = Planet::Saturn(Rc::new(Sun {}));
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 7 references
    saturn.details();

    &amp;#x2F;&amp;#x2F; TODO
    let uranus = Planet::Uranus(Rc::new(Sun {}));
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 8 references
    uranus.details();

    &amp;#x2F;&amp;#x2F; TODO
    let neptune = Planet::Neptune(Rc::new(Sun {}));
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 9 references
    neptune.details();

    assert_eq!(Rc::strong_count(&amp;amp;sun), 9);

    drop(neptune);
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 8 references

    drop(uranus);
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 7 references

    drop(saturn);
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 6 references

    drop(jupiter);
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 5 references

    drop(mars);
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 4 references

    &amp;#x2F;&amp;#x2F; TODO
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 3 references

    &amp;#x2F;&amp;#x2F; TODO
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 2 references

    &amp;#x2F;&amp;#x2F; TODO
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 1 reference

    assert_eq!(Rc::strong_count(&amp;amp;sun), 1);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;okay, we have a lot of &lt;code&gt;TODO&lt;&#x2F;code&gt;&#x27;s here, with the instructions of making the code compile by using the proper &lt;code&gt;Rc&lt;&#x2F;code&gt; primitives. Let&#x27;s take a look at what the Rust compiler says.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rc1-rs-errors&quot;&gt;Rc1.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Ran exercises&amp;#x2F;smart_pointers&amp;#x2F;rc1.rs with errors
reference count = 1
reference count = 2
Hi from Mercury(Sun)!
reference count = 3
Hi from Venus(Sun)!
reference count = 4
Hi from Earth(Sun)!
reference count = 5
Hi from Mars(Sun)!
reference count = 6
Hi from Jupiter(Sun)!
reference count = 6
Hi from Saturn(Sun)!
reference count = 6
Hi from Uranus(Sun)!
reference count = 6
Hi from Neptune(Sun)!

thread &amp;#x27;main&amp;#x27; panicked at exercises&amp;#x2F;smart_pointers&amp;#x2F;rc1.rs:72:5:
assertion `left == right` failed
  left: 6
 right: 9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Welcome to watch mode! You can type &amp;#x27;help&amp;#x27; to get an overview of the commands you can use here.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see that our code is panicking and that our asserting at line &lt;code&gt;72&lt;&#x2F;code&gt;:  &lt;code&gt;assert_eq!(Rc::strong_count(&amp;amp;sun), 9);&lt;&#x2F;code&gt; because we&#x27;re &amp;quot;stuck&amp;quot; on reference count 6. So let&#x27;s go ahead and try and fix that&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rc1-rs-solution&quot;&gt;Rc1.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s break this down into two different parts as there seems to be a thread (no pun intended ðŸ˜„) between the different &lt;code&gt;TODOs&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fixing-saturn-uranus-and-neptune&quot;&gt;Fixing Saturn, Uranus and Neptune&lt;&#x2F;h3&gt;
&lt;p&gt;First 3 &lt;code&gt;TODO&lt;&#x2F;code&gt;&#x27;s  are these:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    &amp;#x2F;&amp;#x2F; TODO
    let saturn = Planet::Saturn(Rc::new(Sun {}));
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 7 references
    saturn.details();

    &amp;#x2F;&amp;#x2F; TODO
    let uranus = Planet::Uranus(Rc::new(Sun {}));
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 8 references
    uranus.details();

    &amp;#x2F;&amp;#x2F; TODO
    let neptune = Planet::Neptune(Rc::new(Sun {}));
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 9 references
    neptune.details();
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and if you look at the variable assignment of each it differs from the first 3, instead of cloning our planet we use the &lt;code&gt;Rc::new()&lt;&#x2F;code&gt; syntax, here&#x27;s what the &lt;code&gt;jupiter&lt;&#x2F;code&gt; variable looks like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let jupiter = Planet::Jupiter(Rc::clone(&amp;amp;sun));
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we are taking our &lt;code&gt;Jupiter&lt;&#x2F;code&gt; planet and cloning it using &lt;code&gt;Rc::clone&lt;&#x2F;code&gt; which creates a new reference to &lt;code&gt;sun&lt;&#x2F;code&gt;. This working for our first 3 planets,   So let&#x27;s fix &lt;code&gt;saturn&lt;&#x2F;code&gt;, &lt;code&gt;uranus&lt;&#x2F;code&gt; and &lt;code&gt;neptune&lt;&#x2F;code&gt; to match and see what happens.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;reference-count-output&quot;&gt;Reference Count Output&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Ran exercises&amp;#x2F;smart_pointers&amp;#x2F;rc1.rs with errors
reference count = 1
reference count = 2
Hi from Mercury(Sun)!
reference count = 3
Hi from Venus(Sun)!
reference count = 4
Hi from Earth(Sun)!
reference count = 5
Hi from Mars(Sun)!
reference count = 6
Hi from Jupiter(Sun)!
reference count = 7
Hi from Saturn(Sun)!
reference count = 8
Hi from Uranus(Sun)!
reference count = 9
Hi from Neptune(Sun)!
reference count = 8
reference count = 7
reference count = 6
reference count = 5
reference count = 4
reference count = 4
reference count = 4
reference count = 4

thread &amp;#x27;main&amp;#x27; panicked at exercises&amp;#x2F;smart_pointers&amp;#x2F;rc1.rs:101:5:
assertion `left == right` failed
  left: 4
 right: 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Okay, we are counting all the way to 9 now, BUT, we&#x27;re still not fully working because as you can see, the second set of &lt;code&gt;TODO&lt;&#x2F;code&gt;&#x27;s are  still not updated, let&#x27;s take a closer look:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    &amp;#x2F;&amp;#x2F; TODO
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 3 references

    &amp;#x2F;&amp;#x2F; TODO
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 2 references

    &amp;#x2F;&amp;#x2F; TODO
    println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 1 reference
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again, we seem to have a natural grouping of these three, and we see that we should be going down to &lt;code&gt;3&lt;&#x2F;code&gt;, &lt;code&gt;2&lt;&#x2F;code&gt;, and finally &lt;code&gt;1&lt;&#x2F;code&gt; reference. If we look at the previous reference output. We&#x27;ll notice that there&#x27;s a &lt;code&gt;drop(mars)&lt;&#x2F;code&gt; before the &lt;code&gt;println!&lt;&#x2F;code&gt; statement:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;drop(mars);
println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 4 references
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Seems simple enough let&#x27;s add a drop for each of the corresponding planets which would be &lt;code&gt;earth&lt;&#x2F;code&gt;, &lt;code&gt;venus&lt;&#x2F;code&gt;, and &lt;code&gt;mercury&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; TODO
drop(earth);
println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 3 references

&amp;#x2F;&amp;#x2F; TODO
drop(venus);
println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 2 references

&amp;#x2F;&amp;#x2F; TODO
drop(mercury);
println!(&amp;quot;reference count = {}&amp;quot;, Rc::strong_count(&amp;amp;sun)); &amp;#x2F;&amp;#x2F; 1 reference
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;final-output&quot;&gt;Final Output&lt;&#x2F;h3&gt;
&lt;p&gt;With those updates we are now compiling!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰

Output:
====================
reference count = 1
reference count = 2
Hi from Mercury(Sun)!
reference count = 3
Hi from Venus(Sun)!
reference count = 4
Hi from Earth(Sun)!
reference count = 5
Hi from Mars(Sun)!
reference count = 6
Hi from Jupiter(Sun)!
reference count = 7
Hi from Saturn(Sun)!
reference count = 8
Hi from Uranus(Sun)!
reference count = 9
Hi from Neptune(Sun)!
reference count = 8
reference count = 7
reference count = 6
reference count = 5
reference count = 4
reference count = 3
reference count = 2
reference count = 1

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;arc1-rs&quot;&gt;Arc1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; arc1.rs
&amp;#x2F;&amp;#x2F; In this exercise, we are given a Vec of u32 called &amp;quot;numbers&amp;quot; with values ranging
&amp;#x2F;&amp;#x2F; from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]
&amp;#x2F;&amp;#x2F; We would like to use this set of numbers within 8 different threads simultaneously.
&amp;#x2F;&amp;#x2F; Each thread is going to get the sum of every eighth value, with an offset.
&amp;#x2F;&amp;#x2F; The first thread (offset 0), will sum 0, 8, 16, ...
&amp;#x2F;&amp;#x2F; The second thread (offset 1), will sum 1, 9, 17, ...
&amp;#x2F;&amp;#x2F; The third thread (offset 2), will sum 2, 10, 18, ...
&amp;#x2F;&amp;#x2F; ...
&amp;#x2F;&amp;#x2F; The eighth thread (offset 7), will sum 7, 15, 23, ...

&amp;#x2F;&amp;#x2F; Because we are using threads, our values need to be thread-safe.  Therefore,
&amp;#x2F;&amp;#x2F; we are using Arc.  We need to make a change in each of the two TODOs.


&amp;#x2F;&amp;#x2F; Make this code compile by filling in a value for `shared_numbers` where the
&amp;#x2F;&amp;#x2F; first TODO comment is, and create an initial binding for `child_numbers`
&amp;#x2F;&amp;#x2F; where the second TODO comment is. Try not to create any copies of the `numbers` Vec!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint arc1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#![forbid(unused_imports)] &amp;#x2F;&amp;#x2F; Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec&amp;lt;_&amp;gt; = (0..100u32).collect();
    let shared_numbers = &amp;#x2F;&amp;#x2F; TODO
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = &amp;#x2F;&amp;#x2F; TODO
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|&amp;amp;&amp;amp;n| n % 8 == offset).sum();
            println!(&amp;quot;Sum of offset {} is {}&amp;quot;, offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We continue our exercises with threads this time our exercise focuses on the use of &lt;code&gt;Arc&lt;&#x2F;code&gt; we have 2 &lt;code&gt;TODO&lt;&#x2F;code&gt;&#x27;s to complete&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let shared_numbers = &#x2F;&#x2F; TODO  &lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;let child_numbers = &#x2F;&#x2F; TODO  &lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Let&#x27;s take a look at the Rust compiler errors and see if we can get some hints from there.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;arc1-rs-errors&quot;&gt;Arc1.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;smart_pointers&amp;#x2F;arc1.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `let` statement
  --&amp;gt; exercises&amp;#x2F;smart_pointers&amp;#x2F;arc1.rs:30:5
   |
30 |     let mut joinhandles = Vec::new();
   |     ^^^

error: expected expression, found statement (`let`)
  --&amp;gt; exercises&amp;#x2F;smart_pointers&amp;#x2F;arc1.rs:30:5
   |
30 |     let mut joinhandles = Vec::new();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: variable declaration using `let` is a statement

error[E0425]: cannot find value `child_numbers` in this scope
  --&amp;gt; exercises&amp;#x2F;smart_pointers&amp;#x2F;arc1.rs:35:28
   |
35 |             let sum: u32 = child_numbers.iter().filter(|&amp;amp;&amp;amp;n| n % 8 == offset).sum();
   |                            ^^^^^^^^^^^^^ help: a local variable with a similar name exists: `shared_numbers`

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Unfortunately it does&#x27;t say much, just let&#x27;s us know that we have missing information where our &lt;code&gt;TODO&lt;&#x2F;code&gt;&#x27;s are located so that&#x27;s not a surprise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;arc1-rs-solution&quot;&gt;Arc1.rs Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
  #![forbid(unused_imports)] &amp;#x2F;&amp;#x2F; Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec&amp;lt;_&amp;gt; = (0..100u32).collect();
    let shared_numbers = &amp;#x2F;&amp;#x2F; TODO
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = &amp;#x2F;&amp;#x2F; TODO
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|&amp;amp;&amp;amp;n| n % 8 == offset).sum();
            println!(&amp;quot;Sum of offset {} is {}&amp;quot;, offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So we know that we need to use &lt;code&gt;Arc&lt;&#x2F;code&gt; in this exercise, so let&#x27;s create a new &lt;code&gt;Arc&lt;&#x2F;code&gt; for shared number by completing the first &lt;code&gt;TODO&lt;&#x2F;code&gt; with:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let shared_numbers = Arc::new(numbers); &amp;#x2F;&amp;#x2F; TODO
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This allows us to wrap the &lt;code&gt;numbers&lt;&#x2F;code&gt; vector in an &lt;code&gt;Arc&lt;&#x2F;code&gt; to share it safely among threads without making any copies.&lt;&#x2F;p&gt;
&lt;p&gt;Our second &lt;code&gt;TODO&lt;&#x2F;code&gt; needs a reference to the shared numbers so we need to create a reference to the shared &lt;code&gt;Arc&lt;&#x2F;code&gt; data for each thread. Let&#x27;s use &lt;code&gt;clone&lt;&#x2F;code&gt; as we have done before in previous exercises&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let child_numbers = Arc::clone(&amp;amp;shared_numbers); &amp;#x2F;&amp;#x2F; TODO
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and with this our Rust code is compiling!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰

Output:
====================
Sum of offset 0 is 624
Sum of offset 1 is 637
Sum of offset 2 is 650
Sum of offset 5 is 588
Sum of offset 3 is 663
Sum of offset 4 is 576
Sum of offset 6 is 600
Sum of offset 7 is 612

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s move on to our final exercise for this category.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cow1-rs&quot;&gt;Cow1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; cow1.rs

&amp;#x2F;&amp;#x2F; This exercise explores the Cow, or Clone-On-Write type.
&amp;#x2F;&amp;#x2F; Cow is a clone-on-write smart pointer.
&amp;#x2F;&amp;#x2F; It can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required.
&amp;#x2F;&amp;#x2F; The type is designed to work with general borrowed data via the Borrow trait.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; This exercise is meant to show you what to expect when passing data to Cow.
&amp;#x2F;&amp;#x2F; Fix the unit tests by checking for Cow::Owned(_) and Cow::Borrowed(_) at the TODO markers.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::borrow::Cow;

fn abs_all&amp;lt;&amp;#x27;a, &amp;#x27;b&amp;gt;(input: &amp;amp;&amp;#x27;a mut Cow&amp;lt;&amp;#x27;b, [i32]&amp;gt;) -&amp;gt; &amp;amp;&amp;#x27;a mut Cow&amp;lt;&amp;#x27;b, [i32]&amp;gt; {
    for i in 0..input.len() {
        let v = input[i];
        if v &amp;lt; 0 {
            &amp;#x2F;&amp;#x2F; Clones into a vector if not already owned.
            input.to_mut()[i] = -v;
        }
    }
    input
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn reference_mutation() -&amp;gt; Result&amp;lt;(), &amp;amp;&amp;#x27;static str&amp;gt; {
        &amp;#x2F;&amp;#x2F; Clone occurs because `input` needs to be mutated.
        let slice = [-1, 0, 1];
        let mut input = Cow::from(&amp;amp;slice[..]);
        match abs_all(&amp;amp;mut input) {
            Cow::Owned(_) =&amp;gt; Ok(()),
            _ =&amp;gt; Err(&amp;quot;Expected owned value&amp;quot;),
        }
    }

    #[test]
    fn reference_no_mutation() -&amp;gt; Result&amp;lt;(), &amp;amp;&amp;#x27;static str&amp;gt; {
        &amp;#x2F;&amp;#x2F; No clone occurs because `input` doesn&amp;#x27;t need to be mutated.
        let slice = [0, 1, 2];
        let mut input = Cow::from(&amp;amp;slice[..]);
        match abs_all(&amp;amp;mut input) {
            &amp;#x2F;&amp;#x2F; TODO
        }
    }

    #[test]
    fn owned_no_mutation() -&amp;gt; Result&amp;lt;(), &amp;amp;&amp;#x27;static str&amp;gt; {
        &amp;#x2F;&amp;#x2F; We can also pass `slice` without `&amp;amp;` so Cow owns it directly.
        &amp;#x2F;&amp;#x2F; In this case no mutation occurs and thus also no clone,
        &amp;#x2F;&amp;#x2F; but the result is still owned because it always was.
        let slice = vec![0, 1, 2];
        let mut input = Cow::from(slice);
        match abs_all(&amp;amp;mut input) {
            &amp;#x2F;&amp;#x2F; TODO
        }
    }

    #[test]
    fn owned_mutation() -&amp;gt; Result&amp;lt;(), &amp;amp;&amp;#x27;static str&amp;gt; {
        &amp;#x2F;&amp;#x2F; Of course this is also the case if a mutation does occur.
        &amp;#x2F;&amp;#x2F; In this case the call to `to_mut()` returns a reference to
        &amp;#x2F;&amp;#x2F; the same data as before.
        let slice = vec![-1, 0, 1];
        let mut input = Cow::from(slice);
        match abs_all(&amp;amp;mut input) {
            &amp;#x2F;&amp;#x2F; TODO
        }
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are to fix the unit tests to get them to pass by using &lt;code&gt;Cow::Owned(_) &lt;&#x2F;code&gt;and &lt;code&gt;Cow::Borrowed(_)&lt;&#x2F;code&gt;, let&#x27;s take a look at what the compiler is saying.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cow1-rs-errors&quot;&gt;Cow1.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;smart_pointers&amp;#x2F;cow1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0004]: non-exhaustive patterns: type `&amp;amp;mut std::borrow::Cow&amp;lt;&amp;#x27;_, [i32]&amp;gt;` is non-empty
   --&amp;gt; exercises&amp;#x2F;smart_pointers&amp;#x2F;cow1.rs:46:15
    |
46  |         match abs_all(&amp;amp;mut input) {
    |               ^^^^^^^^^^^^^^^^^^^
    |
note: `std::borrow::Cow&amp;lt;&amp;#x27;_, [i32]&amp;gt;` defined here
   --&amp;gt; &amp;#x2F;Users&amp;#x2F;desmo&amp;#x2F;.rustup&amp;#x2F;toolchains&amp;#x2F;stable-aarch64-apple-darwin&amp;#x2F;lib&amp;#x2F;rustlib&amp;#x2F;src&amp;#x2F;rust&amp;#x2F;library&amp;#x2F;alloc&amp;#x2F;src&amp;#x2F;borrow.rs:179:1
    |
179 | pub enum Cow&amp;lt;&amp;#x27;a, B: ?Sized + &amp;#x27;a&amp;gt;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: the matched value is of type `&amp;amp;mut std::borrow::Cow&amp;lt;&amp;#x27;_, [i32]&amp;gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown
    |
46  ~         match abs_all(&amp;amp;mut input) {
47  +             _ =&amp;gt; todo!(),
48  +         }
    |

error[E0004]: non-exhaustive patterns: type `&amp;amp;mut std::borrow::Cow&amp;lt;&amp;#x27;_, [i32]&amp;gt;` is non-empty
   --&amp;gt; exercises&amp;#x2F;smart_pointers&amp;#x2F;cow1.rs:58:15
    |
58  |         match abs_all(&amp;amp;mut input) {
    |               ^^^^^^^^^^^^^^^^^^^
    |
note: `std::borrow::Cow&amp;lt;&amp;#x27;_, [i32]&amp;gt;` defined here
   --&amp;gt; &amp;#x2F;Users&amp;#x2F;desmo&amp;#x2F;.rustup&amp;#x2F;toolchains&amp;#x2F;stable-aarch64-apple-darwin&amp;#x2F;lib&amp;#x2F;rustlib&amp;#x2F;src&amp;#x2F;rust&amp;#x2F;library&amp;#x2F;alloc&amp;#x2F;src&amp;#x2F;borrow.rs:179:1
    |
179 | pub enum Cow&amp;lt;&amp;#x27;a, B: ?Sized + &amp;#x27;a&amp;gt;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: the matched value is of type `&amp;amp;mut std::borrow::Cow&amp;lt;&amp;#x27;_, [i32]&amp;gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown
    |
58  ~         match abs_all(&amp;amp;mut input) {
59  +             _ =&amp;gt; todo!(),
60  +         }
    |

error[E0004]: non-exhaustive patterns: type `&amp;amp;mut std::borrow::Cow&amp;lt;&amp;#x27;_, [i32]&amp;gt;` is non-empty
   --&amp;gt; exercises&amp;#x2F;smart_pointers&amp;#x2F;cow1.rs:70:15
    |
70  |         match abs_all(&amp;amp;mut input) {
    |               ^^^^^^^^^^^^^^^^^^^
    |
note: `std::borrow::Cow&amp;lt;&amp;#x27;_, [i32]&amp;gt;` defined here
   --&amp;gt; &amp;#x2F;Users&amp;#x2F;desmo&amp;#x2F;.rustup&amp;#x2F;toolchains&amp;#x2F;stable-aarch64-apple-darwin&amp;#x2F;lib&amp;#x2F;rustlib&amp;#x2F;src&amp;#x2F;rust&amp;#x2F;library&amp;#x2F;alloc&amp;#x2F;src&amp;#x2F;borrow.rs:179:1
    |
179 | pub enum Cow&amp;lt;&amp;#x27;a, B: ?Sized + &amp;#x27;a&amp;gt;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: the matched value is of type `&amp;amp;mut std::borrow::Cow&amp;lt;&amp;#x27;_, [i32]&amp;gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown
    |
70  ~         match abs_all(&amp;amp;mut input) {
71  +             _ =&amp;gt; todo!(),
72  +         }
    |

error: aborting due to 3 previous errors

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Okay, our messages are essentially telling us we have some code missing in our &lt;code&gt;TODO&lt;&#x2F;code&gt;&#x27;s fair enough. Let&#x27;s try and work on a solution.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cow1-rs-solution&quot;&gt;Cow1.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;If we look at the first test &lt;code&gt;reference_mutation&lt;&#x2F;code&gt; we can get and idea of what is missing in our other tests:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    fn reference_mutation() -&amp;gt; Result&amp;lt;(), &amp;amp;&amp;#x27;static str&amp;gt; {
        &amp;#x2F;&amp;#x2F; Clone occurs because `input` needs to be mutated.
        let slice = [-1, 0, 1];
        let mut input = Cow::from(&amp;amp;slice[..]);
        match abs_all(&amp;amp;mut input) {
            Cow::Owned(_) =&amp;gt; Ok(()),
            _ =&amp;gt; Err(&amp;quot;Expected owned value&amp;quot;),
        }
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the other tests, we are missing the &lt;code&gt;match abs_all&lt;&#x2F;code&gt; match arms. So I would expect to fill those match arms with either &lt;code&gt;Cow::Owned(_) &lt;&#x2F;code&gt; or &lt;code&gt;Cow::Borrowed(_)&lt;&#x2F;code&gt; we get additional comment notes at each function. Looking at the comment in &lt;code&gt;reference_mutation&lt;&#x2F;code&gt;, it tells us that a clone occurs because &lt;code&gt;input&lt;&#x2F;code&gt; needs to be mutated, so it makes sense that they use the &lt;code&gt;Cow::Owned()&lt;&#x2F;code&gt; smart pointer.&lt;&#x2F;p&gt;
&lt;p&gt;In our next function &lt;code&gt;reference_no_mutation&lt;&#x2F;code&gt; we see the comment: &lt;em&gt;No clone occurs because &lt;code&gt;input&lt;&#x2F;code&gt; doesn&#x27;t need to be mutated&lt;&#x2F;em&gt;. So naturally, since it doesn&#x27;t need to be owned we should use the &lt;code&gt;Cow::Borrowed&lt;&#x2F;code&gt; smart pointer, right?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[test]
fn reference_no_mutation() -&amp;gt; Result&amp;lt;(), &amp;amp;&amp;#x27;static str&amp;gt; {
    &amp;#x2F;&amp;#x2F; No clone occurs because `input` doesn&amp;#x27;t need to be mutated.
    let slice = [0, 1, 2];
    let mut input = Cow::from(&amp;amp;slice[..]);
    match abs_all(&amp;amp;mut input) {
        Cow::Borrowed(_) =&amp;gt; Ok(()),
        _ =&amp;gt; Err(&amp;quot;Expected owned value&amp;quot;),
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our third function tells us we don&#x27;t need to mutate and no clone is created but the result is still &lt;em&gt;owned&lt;&#x2F;em&gt; so that makes it clear to use &lt;code&gt;Cow::Owned&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    #[test]
    fn owned_no_mutation() -&amp;gt; Result&amp;lt;(), &amp;amp;&amp;#x27;static str&amp;gt; {
        &amp;#x2F;&amp;#x2F; We can also pass `slice` without `&amp;amp;` so Cow owns it directly.
        &amp;#x2F;&amp;#x2F; In this case no mutation occurs and thus also no clone,
        &amp;#x2F;&amp;#x2F; but the result is still owned because it always was.
        let slice = vec![0, 1, 2];
        let mut input = Cow::from(slice);
        match abs_all(&amp;amp;mut input) {
            Cow::Owned(_) =&amp;gt; Ok(()),
            _ =&amp;gt; Err(&amp;quot;Expected owned value&amp;quot;),
        }
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our final test tells us that that calling &lt;code&gt;input.to_mut()&lt;&#x2F;code&gt; in our &lt;code&gt;abs_all&lt;&#x2F;code&gt; function, in case we need to mutate the data we need to make sure it&#x27;s owned.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    fn owned_mutation() -&amp;gt; Result&amp;lt;(), &amp;amp;&amp;#x27;static str&amp;gt; {
        &amp;#x2F;&amp;#x2F; Of course this is also the case if a mutation does occur.
        &amp;#x2F;&amp;#x2F; In this case the call to `to_mut()` returns a reference to
        &amp;#x2F;&amp;#x2F; the same data as before.
        let slice = vec![-1, 0, 1];
        let mut input = Cow::from(slice);
        match abs_all(&amp;amp;mut input) {
            Cow::Owned(_) =&amp;gt; Ok(()),
            _ =&amp;gt; Err(&amp;quot;Expected owned value&amp;quot;),
        }
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and with that we are compiling and our tests have all passed!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âœ… Successfully tested exercises&amp;#x2F;smart_pointers&amp;#x2F;cow1.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Exploring Rust&#x27;s smart pointers - &lt;code&gt;Box&lt;&#x2F;code&gt;, &lt;code&gt;Rc&lt;&#x2F;code&gt;, &lt;code&gt;Arc&lt;&#x2F;code&gt;, and &lt;code&gt;Cow&lt;&#x2F;code&gt; - has taken us through a variety of scenarios, each illustrating the unique strengths and use cases of these powerful tools in the Rust ecosystem. From handling recursive data structures with &lt;code&gt;Box&lt;&#x2F;code&gt; to managing shared ownership with &lt;code&gt;Rc&lt;&#x2F;code&gt; and &lt;code&gt;Arc&lt;&#x2F;code&gt;, and leveraging the efficiency of &lt;code&gt;Cow&lt;&#x2F;code&gt; for clone-on-write scenarios, we&#x27;ve seen how Rust smart pointers enable more complex data management while maintaining the language&#x27;s strict guarantees on safety and concurrency.&lt;&#x2F;p&gt;
&lt;p&gt;What stands out is how Rust&#x27;s design encourages developers to think critically about ownership, lifetime, and memory usage. These smart pointers are not just tools but also guidelines that shape the way we structure our programs for optimal performance and safety. They embody Rust&#x27;s philosophy of making systems programming both accessible and reliable, preventing common pitfalls such as data races and memory leaks.&lt;&#x2F;p&gt;
&lt;p&gt;As you continue your journey with Rust, remember that mastering these concepts opens doors to advanced patterns and techniques in Rust programming. The versatility of smart pointers in Rust makes them indispensable for a wide range of applications, from web servers and operating systems to game development and embedded systems.&lt;&#x2F;p&gt;
&lt;p&gt;Keep experimenting, keep building, and most importantly, keep enjoying the process of learning and growing with Rust. The Rust community is an invaluable resource, always ready to help and inspire. With these tools in your arsenal, you&#x27;re well-equipped to tackle the challenges of systems programming with confidence and creativity.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>22 Rustlings Threads</title>
          <pubDate>Mon, 06 Nov 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/22-rustlings-threads/</link>
          <guid>https://desmodrone.github.io/posts/22-rustlings-threads/</guid>
          <description xml:base="https://desmodrone.github.io/posts/22-rustlings-threads/">&lt;p&gt;In most current operating systems, an executed programâ€™s code is run in a process, and the operating system manages multiple processes at once.
Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called threads.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.4.0&#x2F;book&#x2F;dining-philosophers.html&quot;&gt;Dining Philosophers example&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch16-01-threads.html&quot;&gt;Using Threads to Run Code Simultaneously&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;threads1-rs&quot;&gt;Threads1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; threads1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint threads1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; This program spawns multiple threads that each run for at least 250ms,
&amp;#x2F;&amp;#x2F; and each thread returns how much time they took to complete.
&amp;#x2F;&amp;#x2F; The program should wait until all the spawned threads have finished and
&amp;#x2F;&amp;#x2F; should collect their return values into a vector.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::thread;
use std::time::{Duration, Instant};

fn main() {
    let mut handles = vec![];
    for i in 0..10 {
        handles.push(thread::spawn(move || {
            let start = Instant::now();
            thread::sleep(Duration::from_millis(250));
            println!(&amp;quot;thread {} is complete&amp;quot;, i);
            start.elapsed().as_millis()
        }));
    }

    let mut results: Vec&amp;lt;u128&amp;gt; = vec![];

    for handle in handles {
        &amp;#x2F;&amp;#x2F; TODO: a struct is returned from thread::spawn, can you use it?

    }

    if results.len() != 10 {
        panic!(&amp;quot;Oh no! All the spawned threads did not finish!&amp;quot;);
    }

    println!();
    for (i, result) in results.into_iter().enumerate() {
        println!(&amp;quot;thread {} took {}ms&amp;quot;, i, result);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have one TODO on this exercise and we have a question about &lt;code&gt;thread::spawn&lt;&#x2F;code&gt;&#x27; s returned struct.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;threads1-rs-errors&quot;&gt;Threads1.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Ran exercises&amp;#x2F;threads&amp;#x2F;threads1.rs with errors

thread &amp;#x27;main&amp;#x27; panicked at exercises&amp;#x2F;threads&amp;#x2F;threads1.rs:31:9:
Oh no! All the spawned threads did not finish!
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Looking at the errors we see that the &lt;code&gt;if&lt;&#x2F;code&gt; result is triggering a panic with the &lt;code&gt;Oh no! All the spawned threads did not finish!&lt;&#x2F;code&gt; message.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;threads1-rs-solution&quot;&gt;Threads1.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;If you look at the Rust documentation you will see that you can use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;thread&#x2F;fn.spawn.html&quot;&gt;JoinHandle&lt;&#x2F;a&gt; when using the &lt;code&gt;std::thread::spawn&lt;&#x2F;code&gt; which provides a &lt;code&gt;join&lt;&#x2F;code&gt; method that can be used to &amp;quot;join&amp;quot; the spawned thread, this is because the &lt;code&gt;join&lt;&#x2F;code&gt; method waits for the thread to finish and returns the result of the thread&#x27;s operation, which is why it&#x27;s necessary to call &lt;code&gt;join&lt;&#x2F;code&gt; on each handle. So let&#x27;s try that in our &lt;code&gt;for handle&lt;&#x2F;code&gt; loop. It would look something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;for handle in handles {
	handle.join().unwrap();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s run this is and see what happens&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Ran exercises&amp;#x2F;threads&amp;#x2F;threads1.rs with errors
thread 2 is complete
thread 0 is complete
thread 3 is complete
thread 9 is complete
thread 1 is complete
thread 8 is complete
thread 6 is complete
thread 7 is complete
thread 4 is complete
thread 5 is complete

thread &amp;#x27;main&amp;#x27; panicked at exercises&amp;#x2F;threads&amp;#x2F;threads1.rs:32:9:
Oh no! All the spawned threads did not finish!
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Looks like we&#x27;re getting closer but we are still panicking with the same message, notice how the threads are all out of order, this will vary every time we run the program and this is part the challenge with multi-threaded applications that the main thread can finish before the spawned threads are complete.  So going back to our &lt;code&gt;for&lt;&#x2F;code&gt; loop, if we look back at the code we see that we are using the &lt;code&gt;results&lt;&#x2F;code&gt; variable in the &lt;code&gt;if&lt;&#x2F;code&gt; portion of the code but we never actually pushed the threads into the &lt;code&gt;results&lt;&#x2F;code&gt; variable so the code is panicking regardless of the fact that we&#x27;re printing out the threads, so let&#x27;s fix that.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;for handle in handles {
	&amp;#x2F;&amp;#x2F; creating a new variable `result` with the joined threads
	let result = handle.join().unwrap();
	&amp;#x2F;&amp;#x2F; pushing these results to the `results` Vec&amp;lt;u128&amp;gt; defined before the for loop.
	results.push(result);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This will properly populate the &lt;code&gt;results&lt;&#x2F;code&gt; vector and allow the &lt;code&gt;if&lt;&#x2F;code&gt; part of the code not panic because &lt;code&gt;results&lt;&#x2F;code&gt; will indeed be equal to &lt;code&gt;10&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;with this we are complete, here&#x27;s our output:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âœ… Successfully ran exercises&amp;#x2F;threads&amp;#x2F;threads1.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰

Output:
====================
thread 1 is complete
thread 4 is complete
thread 9 is complete
thread 0 is complete
thread 2 is complete
thread 3 is complete
thread 5 is complete
thread 7 is complete
thread 8 is complete
thread 6 is complete

thread 0 took 255ms
thread 1 took 255ms
thread 2 took 255ms
thread 3 took 255ms
thread 4 took 254ms
thread 5 took 255ms
thread 6 took 255ms
thread 7 took 255ms
thread 8 took 255ms
thread 9 took 255ms

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;threads2-rs&quot;&gt;Threads2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; threads2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.
&amp;#x2F;&amp;#x2F; Building on the last exercise, we want all of the threads to complete their work but this time
&amp;#x2F;&amp;#x2F; the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::sync::Arc;
use std::thread;
use std::time::Duration;

struct JobStatus {
    jobs_completed: u32,
}

fn main() {
    let status = Arc::new(JobStatus { jobs_completed: 0 });
    let mut handles = vec![];
    for _ in 0..10 {
        let status_shared = Arc::clone(&amp;amp;status);
        let handle = thread::spawn(move || {
            thread::sleep(Duration::from_millis(250));
            &amp;#x2F;&amp;#x2F; TODO: You must take an action before you update a shared value
            status_shared.jobs_completed += 1;
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
        &amp;#x2F;&amp;#x2F; TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything
        &amp;#x2F;&amp;#x2F; interesting in the output? Do you have to &amp;#x27;join&amp;#x27; on all the handles?
        println!(&amp;quot;jobs completed {}&amp;quot;, ???);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have a couple of &lt;code&gt;TODO&lt;&#x2F;code&gt;&#x27;s on  this exercise that is building on the previous&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;In our first &lt;code&gt;for&lt;&#x2F;code&gt; loop we must take an action before we can update a shared value&lt;&#x2F;li&gt;
&lt;li&gt;In our &lt;code&gt;handle&lt;&#x2F;code&gt; for loop we must print out the value of the &lt;code&gt;JobStatus.jobs_completed&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;threads2-rs-errors&quot;&gt;Threads2.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;threads&amp;#x2F;threads2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;threads&amp;#x2F;threads2.rs:32:39
   |
32 |         println!(&amp;quot;jobs completed {}&amp;quot;, ???);
   |                                       ^ expected expression

error: aborting due to previous error

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The errors show that we&#x27;re missing the last part of our print statement so that&#x27;s not much help, but let&#x27;s proceed. We actually get more of a hint in the comments of the &lt;code&gt;TODO&lt;&#x2F;code&gt; with :  &lt;code&gt;Did you notice anything interesting in the output? Do you have to &#x27;join&#x27; on all the handles?&lt;&#x2F;code&gt; So let&#x27;s keep that in mind.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;threads2-rs-solution&quot;&gt;Threads2.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;let&#x27;s first take a look at our &lt;code&gt;fn main&lt;&#x2F;code&gt; where we have the &lt;code&gt;TODO&lt;&#x2F;code&gt; right before our incrementation.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let status = Arc::new(JobStatus { jobs_completed: 0 });
    let mut handles = vec![];
    for _ in 0..10 {
        let status_shared = Arc::clone(&amp;amp;status);
        let handle = thread::spawn(move || {
            thread::sleep(Duration::from_millis(250));
            &amp;#x2F;&amp;#x2F; TODO: You must take an action before you update a shared value
            status_shared.jobs_completed += 1;
        });
        handles.push(handle);
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;implementing-mutex&quot;&gt;Implementing Mutex&lt;&#x2F;h3&gt;
&lt;p&gt;So, what is the action that we must do before we updated a shared value? This hint must be referring to the use of a &lt;em&gt;Mutex&lt;&#x2F;em&gt; which if you&#x27;re not familiar with them, is to short for &lt;em&gt;mutual exclusion&lt;&#x2F;em&gt; -- meaning a mutex allows only one thread to access on piece of data at any given time. To use the data with a &lt;em&gt;mutex&lt;&#x2F;em&gt; a thread must request access by asking to acquire a mutex &lt;em&gt;lock&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;So let&#x27;s first implement the &lt;code&gt;Mutex&lt;&#x2F;code&gt; syntax into our code starting at the very top with:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let status = Arc::new(Mutex::new(JobStatus { jobs_completed }));
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Also since we&#x27;re using a new type, &lt;code&gt;Mutex&lt;&#x2F;code&gt; we must import it with &lt;code&gt;use std::sync::Mutex;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Alright now we have to work on the locking portion of the code our &lt;em&gt;TODO:&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    &amp;#x2F;&amp;#x2F; TODO: You must take an action before you update a shared value
    status_shared.jobs_completed += 1;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So, let&#x27;s create update the &lt;code&gt;status_shared&lt;&#x2F;code&gt; variable so we can store the &lt;code&gt;status_shared.lock().unwrap()&lt;&#x2F;code&gt;, let&#x27;s make it &lt;code&gt;mut&lt;&#x2F;code&gt; as well as we have to update the value. The lines would look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let mut status_shared = status_shared.lock().unwrap();
status_shared.jobs_completed += 1;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;fixing-printing&quot;&gt;Fixing Printing&lt;&#x2F;h3&gt;
&lt;p&gt;Now, let&#x27;s look at our 2nd &lt;em&gt;TODO&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything
&amp;#x2F;&amp;#x2F; interesting in the output? Do you have to &amp;#x27;join&amp;#x27; on all the handles?
println!(&amp;quot;jobs completed {}&amp;quot;, ???);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First let&#x27;s figure out what we should be printing here, clearly it&#x27;s the &lt;code&gt;jobs_completed&lt;&#x2F;code&gt; and this is being stored inside of our &lt;code&gt;status&lt;&#x2F;code&gt; variable, so how do we get to this data? By dereferencing with &lt;code&gt;*&lt;&#x2F;code&gt; and because it&#x27;s a &lt;code&gt;Mutex&lt;&#x2F;code&gt; we should also use the &lt;code&gt;lock&lt;&#x2F;code&gt; syntax. Let&#x27;s try:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;println!(&amp;quot;jobs completed {:?}&amp;quot;, *status.lock().unwrap());
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that we also have to add the &lt;code&gt;:?&lt;&#x2F;code&gt; syntax inside of the curly braces as well as add &lt;code&gt;#[derive(Debug)]&lt;&#x2F;code&gt; to our &lt;code&gt;JobStatus&lt;&#x2F;code&gt; struct to be able to print to our terminal. Here&#x27;s our updated full code block&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::sync::Arc;
use std::thread;
use std::time::Duration;
use std::sync::Mutex;

#[derive(Debug)]
struct JobStatus {
    jobs_completed: u32,
}

fn main() {
    let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));
    let mut handles = vec![];
    for _ in 0..10 {
        let status_shared = Arc::clone(&amp;amp;status);
        let handle = thread::spawn(move || {
            thread::sleep(Duration::from_millis(250));
            let mut status_shared = status_shared.lock().unwrap();
            status_shared.jobs_completed += 1;
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
        println!(&amp;quot;jobs completed {:?}&amp;quot;, *status.lock().unwrap());
    }

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And with this we are compiling, BUT maybe we&#x27;re not getting the expected output:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰

Output:
====================
jobs completed JobStatus { jobs_completed: 10 }
jobs completed JobStatus { jobs_completed: 10 }
jobs completed JobStatus { jobs_completed: 10 }
jobs completed JobStatus { jobs_completed: 10 }
jobs completed JobStatus { jobs_completed: 10 }
====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is strange so how do we fix it? I propose we add 2 different print statements to get a better understanding of what is happening with our threads.&lt;&#x2F;p&gt;
&lt;p&gt;The first one inside of our &lt;code&gt;for&lt;&#x2F;code&gt; loop&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;for _ in 0..10 {
    let status_shared = Arc::clone(&amp;amp;status);
    let handle = thread::spawn(move || {
        thread::sleep(Duration::from_millis(250));
        let mut status_shared = status_shared.lock().unwrap();
        status_shared.jobs_completed += 1;
        &amp;#x2F;&amp;#x2F; Print inside the thread to observe the incrementation
        println!(&amp;quot;Thread incremented jobs_completed to {}&amp;quot;, status_shared.jobs_completed);
    });
    handles.push(handle);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and final printout that is not inside of the second &lt;code&gt;for&lt;&#x2F;code&gt; loop but outside to confirm our total jobs completed:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;for handle in handles {
    handle.join().unwrap();
}

&amp;#x2F;&amp;#x2F; Print the final value of the JobStatus.jobs_completed after all threads have been joined
println!(&amp;quot;Final jobs completed {}&amp;quot;, status.lock().unwrap().jobs_completed);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With these tweaks we have our code compiling and behaving in a more predictable or rather informative manner:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;Output:
====================
Thread incremented jobs_completed to 1
Thread incremented jobs_completed to 2
Thread incremented jobs_completed to 3
Thread incremented jobs_completed to 4
Thread incremented jobs_completed to 5
Thread incremented jobs_completed to 6
Thread incremented jobs_completed to 7
Thread incremented jobs_completed to 8
Thread incremented jobs_completed to 9
Thread incremented jobs_completed to 10
jobs completed JobStatus { jobs_completed: 10 }

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;threads3-rs&quot;&gt;Threads3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; threads3.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint threads3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::sync::mpsc;
use std::sync::Arc;
use std::thread;
use std::time::Duration;

struct Queue {
    length: u32,
    first_half: Vec&amp;lt;u32&amp;gt;,
    second_half: Vec&amp;lt;u32&amp;gt;,
}

impl Queue {
    fn new() -&amp;gt; Self {
        Queue {
            length: 10,
            first_half: vec![1, 2, 3, 4, 5],
            second_half: vec![6, 7, 8, 9, 10],
        }
    }
}

fn send_tx(q: Queue, tx: mpsc::Sender&amp;lt;u32&amp;gt;) -&amp;gt; () {
    let qc = Arc::new(q);
    let qc1 = Arc::clone(&amp;amp;qc);
    let qc2 = Arc::clone(&amp;amp;qc);

    thread::spawn(move || {
        for val in &amp;amp;qc1.first_half {
            println!(&amp;quot;sending {:?}&amp;quot;, val);
            tx.send(*val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        for val in &amp;amp;qc2.second_half {
            println!(&amp;quot;sending {:?}&amp;quot;, val);
            tx.send(*val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });
}

fn main() {
    let (tx, rx) = mpsc::channel();
    let queue = Queue::new();
    let queue_length = queue.length;

    send_tx(queue, tx);

    let mut total_received: u32 = 0;
    for received in rx {
        println!(&amp;quot;Got: {}&amp;quot;, received);
        total_received += 1;
    }

    println!(&amp;quot;total numbers received: {}&amp;quot;, total_received);
    assert_eq!(total_received, queue_length)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;On this final threads exercise we don&#x27;t get any information other than what the Rust errors tell us.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;threads3-rs-errors&quot;&gt;Threads3.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;error[E0382]: use of moved value: `tx`
  --&amp;gt; exercises&amp;#x2F;threads&amp;#x2F;threads3.rs:40:19
   |
27 | fn send_tx(q: Queue, tx: mpsc::Sender&amp;lt;u32&amp;gt;) -&amp;gt; () {
   |                      -- move occurs because `tx` has type `Sender&amp;lt;u32&amp;gt;`, which does not implement the `Copy` trait
...
32 |     thread::spawn(move || {
   |                   ------- value moved into closure here
...
35 |             tx.send(*val).unwrap();
   |             -- variable moved due to use in closure
...
40 |     thread::spawn(move || {
   |                   ^^^^^^^ value used here after move
...
43 |             tx.send(*val).unwrap();
   |             -- use occurs due to use in closure

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright we have some hints from the error&#x27;s -- let&#x27;s implement a solution that fixes this &lt;code&gt;Copy&lt;&#x2F;code&gt; trait issue.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;threads3-rs-solution&quot;&gt;Threads3.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s recap, the error we&#x27;re encountering is because the &lt;code&gt;tx&lt;&#x2F;code&gt; (transmitter) is moved into the first thread we spawn. Once a value has been moved into a closure, it cannot be used again because the ownership has been transferred to the closure. In Rust, most values have &#x27;move semantics&#x27;, which means that when you pass a value to a function or a thread, the ownership is transferred, and the original variable can no longer be used.&lt;&#x2F;p&gt;
&lt;p&gt;To fix this, you need to create a transmitter for each thread because the &lt;code&gt;mpsc::Sender&lt;&#x2F;code&gt; type does not implement the &lt;code&gt;Copy&lt;&#x2F;code&gt; trait, (as the error tells us) which means it cannot be copied, only moved. However, &lt;code&gt;mpsc::Sender&lt;&#x2F;code&gt; does implement the &lt;code&gt;Clone&lt;&#x2F;code&gt; trait, so you can clone it before moving it into the thread.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s how we can modify the &lt;code&gt;send_tx&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn send_tx(q: Queue, tx: mpsc::Sender&amp;lt;u32&amp;gt;) -&amp;gt; () {
    let qc = Arc::new(q);
    let qc1 = Arc::clone(&amp;amp;qc);
    let qc2 = Arc::clone(&amp;amp;qc);

    let tx1 = tx.clone(); &amp;#x2F;&amp;#x2F; Clone the transmitter for the first thread
    thread::spawn(move || {
        for val in &amp;amp;qc1.first_half {
            println!(&amp;quot;sending {:?}&amp;quot;, val);
            tx1.send(*val).unwrap(); &amp;#x2F;&amp;#x2F; Use the cloned transmitter
            thread::sleep(Duration::from_secs(1));
        }
    });

    &amp;#x2F;&amp;#x2F; No need to clone here, as we can use the original transmitter
    thread::spawn(move || {
        for val in &amp;amp;qc2.second_half {
            println!(&amp;quot;sending {:?}&amp;quot;, val);
            tx.send(*val).unwrap(); &amp;#x2F;&amp;#x2F; Use the original transmitter
            thread::sleep(Duration::from_secs(1));
        }
    });
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this modified function, &lt;code&gt;tx1&lt;&#x2F;code&gt; is a clone of the original transmitter &lt;code&gt;tx&lt;&#x2F;code&gt; and is moved into the first thread. The second thread can use the original &lt;code&gt;tx&lt;&#x2F;code&gt; because it&#x27;s no longer needed in the main thread after &lt;code&gt;send_tx&lt;&#x2F;code&gt; is called.&lt;&#x2F;p&gt;
&lt;p&gt;And with that we&#x27;re compiling!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âœ… Successfully ran exercises&amp;#x2F;threads&amp;#x2F;threads3.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰

Output:
====================
sending 1
sending 6
Got: 1
Got: 6
sending 2
sending 7
Got: 2
Got: 7
sending 3
sending 8
Got: 3
Got: 8
sending 9
Got: 9
sending 4
Got: 4
sending 10
Got: 10
sending 5
Got: 5
total numbers received: 10

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By cloning the &lt;code&gt;tx&lt;&#x2F;code&gt; before moving it into the threads, we&#x27;ve ensured that each thread has its own &lt;code&gt;Sender&lt;&#x2F;code&gt; to communicate with the &lt;code&gt;Receiver&lt;&#x2F;code&gt;. This allows both threads to send messages concurrently without taking ownership of the original &lt;code&gt;Sender&lt;&#x2F;code&gt;, which is why we&#x27;re seeing the interleaved &amp;quot;sending&amp;quot; and &amp;quot;Got:&amp;quot; outputs.&lt;&#x2F;p&gt;
&lt;p&gt;The reason the &lt;code&gt;Receiver&lt;&#x2F;code&gt; stops blocking and allows the program to finish, even without explicitly joining the threads, is because the &lt;code&gt;Sender&lt;&#x2F;code&gt; endpoints are dropped when each thread finishes execution. When all &lt;code&gt;Sender&lt;&#x2F;code&gt; instances are dropped, the &lt;code&gt;Receiver&lt;&#x2F;code&gt; knows no more messages will come through, and it stops blocking, allowing the &lt;code&gt;for received in rx&lt;&#x2F;code&gt; loop to complete.&lt;&#x2F;p&gt;
&lt;p&gt;This is a key aspect of Rust&#x27;s channel implementation: the &lt;code&gt;Receiver&lt;&#x2F;code&gt; will only return &lt;code&gt;None&lt;&#x2F;code&gt; (and thus stop iterating in a &lt;code&gt;for&lt;&#x2F;code&gt; loop) when all &lt;code&gt;Sender&lt;&#x2F;code&gt; instances have been dropped, signaling that no more messages will be sent on the channel.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s a summary of how it happens:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Each thread sends its messages, sleeping for a second between each one.&lt;&#x2F;li&gt;
&lt;li&gt;The main thread concurrently receives messages. As soon as a message is sent, it&#x27;s printed out by the main thread.&lt;&#x2F;li&gt;
&lt;li&gt;When the threads finish their execution, the &lt;code&gt;Sender&lt;&#x2F;code&gt; objects they own are dropped.&lt;&#x2F;li&gt;
&lt;li&gt;Once all &lt;code&gt;Sender&lt;&#x2F;code&gt; objects are dropped, the &lt;code&gt;Receiver&lt;&#x2F;code&gt; stops blocking and the &lt;code&gt;for&lt;&#x2F;code&gt; loop in the main thread exits.&lt;&#x2F;li&gt;
&lt;li&gt;The program prints the total number of messages received and exits.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The interleaved output of &amp;quot;sending&amp;quot; and &amp;quot;Got:&amp;quot; lines is due to the threads and the main thread running concurrently, with the threads sleeping for a second between sends, giving the main thread time to print out the received messages.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Throughout this exploration of Rust&#x27;s threading model, we&#x27;ve seen how the language&#x27;s design choices around ownership and concurrency enable us to write safe and efficient multithreaded code. From the basics of spawning threads and joining them, to sharing state via &lt;code&gt;Arc&lt;&#x2F;code&gt; and &lt;code&gt;Mutex&lt;&#x2F;code&gt;, and coordinating between threads with message passing, Rust provides a rich set of tools for concurrent programming.&lt;&#x2F;p&gt;
&lt;p&gt;The exercises we&#x27;ve worked through demonstrate the importance of understanding ownership and the type system when working with threads in Rust. By leveraging these concepts, Rust ensures that our concurrent programs are free from data races and other common concurrency pitfalls.&lt;&#x2F;p&gt;
&lt;p&gt;As we&#x27;ve seen, Rust&#x27;s channels and synchronization primitives are powerful, but they also require us to think carefully about how we structure our code and manage shared state. The compiler&#x27;s strict checks might seem restrictive at first, but they guide us towards writing code that is not only correct but also clear in its intent.&lt;&#x2F;p&gt;
&lt;p&gt;In conclusion, Rust&#x27;s approach to concurrency is not about taking away the power from the programmer but about providing the tools to harness that power responsibly. It encourages us to think in terms of safe abstractions, clear ownership, and explicit synchronization. As you continue to explore Rust&#x27;s concurrency features, keep in mind the patterns and principles we&#x27;ve discussed here. They will serve as a solid foundation for building reliable, high-performance concurrent applications.&lt;&#x2F;p&gt;
&lt;p&gt;Happy coding, and may your Rustacean journey be concurrency-error-free!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>21 Rustlings Iterators</title>
          <pubDate>Fri, 27 Oct 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/21-rustlings-iterators/</link>
          <guid>https://desmodrone.github.io/posts/21-rustlings-iterators/</guid>
          <description xml:base="https://desmodrone.github.io/posts/21-rustlings-iterators/">&lt;h1 id=&quot;iterators&quot;&gt;Iterators&lt;&#x2F;h1&gt;
&lt;p&gt;Rust&#x27;s journey towards becoming one of the most loved programming languages isn&#x27;t just by accident. At the heart of its rapidly growing ecosystem are several features that make it both powerful and unique. Among these, iterators stand out as a foundational concept, bridging the gap between functionality and performance. In this section, we&#x27;ll look into the world of iterators in Rust, unraveling their elegance and efficiency. By understanding and mastering iterators, you&#x27;ll unlock a significant aspect of Rust&#x27;s capabilities, enabling you to write code that&#x27;s both expressive and performant.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch13-02-iterators.html&quot;&gt;Iterator&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;iter&#x2F;&quot;&gt;Iterator documentation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;iterators1-rs&quot;&gt;Iterators1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; iterators1.rs
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F;  Make me compile by filling in the `???`s
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; When performing operations on elements within a collection, iterators are essential.
&amp;#x2F;&amp;#x2F; This module helps you get familiar with the structure of using an iterator and
&amp;#x2F;&amp;#x2F; how to go through elements within an iterable collection.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Execute `rustlings hint iterators1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let my_fav_fruits = vec![&amp;quot;banana&amp;quot;, &amp;quot;custard apple&amp;quot;, &amp;quot;avocado&amp;quot;, &amp;quot;peach&amp;quot;, &amp;quot;raspberry&amp;quot;];

    let mut my_iterable_fav_fruits = ???;   &amp;#x2F;&amp;#x2F; TODO: Step 1

    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;amp;&amp;quot;banana&amp;quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     &amp;#x2F;&amp;#x2F; TODO: Step 2
    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;amp;&amp;quot;avocado&amp;quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     &amp;#x2F;&amp;#x2F; TODO: Step 3
    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;amp;&amp;quot;raspberry&amp;quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     &amp;#x2F;&amp;#x2F; TODO: Step 4
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this exercise we&#x27;re looking at how to make this code compile in this line: &lt;code&gt;let mut my_iterable_fav_fruits = ???; &lt;&#x2F;code&gt; as our first step.
Before we proceed, let&#x27;s look at the errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;iterators1-rs-errors&quot;&gt;Iterators1.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;iterators&amp;#x2F;iterators1.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;iterators&amp;#x2F;iterators1.rs:16:38
   |
16 |     let mut my_iterable_fav_fruits = ???;   &amp;#x2F;&amp;#x2F; TODO: Step 1
   |                                      ^ expected expression

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We get an obvious error due to the missing expression in the variable assignment with the &lt;code&gt;???&lt;&#x2F;code&gt; so we have to implement an iterator. Let&#x27;s solve this.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;iterators1-rs-solution&quot;&gt;Iterators1.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;With iterators we can easily go through an array (or vector in this case) of elements. If you&#x27;re not familiar with iterators, they&#x27;re rather easy to use. In our situation here we have a vector which is &lt;code&gt;my_fav_fruits&lt;&#x2F;code&gt; that has a list of fruits. We see in the next line of code a new mutable variable &lt;code&gt;my_iterable_fav_fruits&lt;&#x2F;code&gt; where we know we have to complete this. So how do we do it? Easy, we add the &lt;code&gt;.iter()&lt;&#x2F;code&gt; method to the end of our variable that represents our vector, like this &lt;code&gt;my_fav_fruits.iter()&lt;&#x2F;code&gt; the full line will now look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let mut my_iterable_fav_fruits = my_fav_fruits.iter(); &amp;#x2F;&amp;#x2F; TODO: Step 1
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The next part of TODO&#x27;s  are in the &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; section of the code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;amp;&amp;quot;banana&amp;quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     &amp;#x2F;&amp;#x2F; TODO: Step 2
    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;amp;&amp;quot;avocado&amp;quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     &amp;#x2F;&amp;#x2F; TODO: Step 3
    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;amp;&amp;quot;raspberry&amp;quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     &amp;#x2F;&amp;#x2F; TODO: Step 4
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And it looks pretty straightforward to follow the pattern of adding &lt;code&gt;Some(&amp;amp;&amp;quot;fruit&amp;quot;)&lt;&#x2F;code&gt; as we already have some examples with &lt;code&gt;banana&lt;&#x2F;code&gt;, &lt;code&gt;avocado&lt;&#x2F;code&gt;, and &lt;code&gt;raspberry&lt;&#x2F;code&gt;. The only one that should be different is the final one since after &lt;code&gt;raspberry&lt;&#x2F;code&gt; there is nothing in the vector. So the logical answer would be &lt;code&gt;None&lt;&#x2F;code&gt; right? Let&#x27;s try this out.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let my_fav_fruits = vec![&amp;quot;banana&amp;quot;, &amp;quot;custard apple&amp;quot;, &amp;quot;avocado&amp;quot;, &amp;quot;peach&amp;quot;, &amp;quot;raspberry&amp;quot;];

    let mut my_iterable_fav_fruits = my_fav_fruits.iter();   &amp;#x2F;&amp;#x2F; TODO: Step 1

    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;amp;&amp;quot;banana&amp;quot;));
    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;amp;&amp;quot;custard apple&amp;quot;));     &amp;#x2F;&amp;#x2F; TODO: Step 2
    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;amp;&amp;quot;avocado&amp;quot;));
    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;amp;&amp;quot;peach&amp;quot;));     &amp;#x2F;&amp;#x2F; TODO: Step 3
    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;amp;&amp;quot;raspberry&amp;quot;));
    assert_eq!(my_iterable_fav_fruits.next(), None);     &amp;#x2F;&amp;#x2F; TODO: Step 4
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With those changes as defined above we are compiling, great let&#x27;s move on to the next exercise.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âœ… Successfully ran exercises&amp;#x2F;iterators&amp;#x2F;iterators1.rs!
ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;iterators2-rs&quot;&gt;Iterators2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; iterators2.rs
&amp;#x2F;&amp;#x2F; In this exercise, you&amp;#x27;ll learn some of the unique advantages that iterators
&amp;#x2F;&amp;#x2F; can offer. Follow the steps to complete the exercise.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint iterators2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

&amp;#x2F;&amp;#x2F; Step 1.
&amp;#x2F;&amp;#x2F; Complete the `capitalize_first` function.
&amp;#x2F;&amp;#x2F; &amp;quot;hello&amp;quot; -&amp;gt; &amp;quot;Hello&amp;quot;
pub fn capitalize_first(input: &amp;amp;str) -&amp;gt; String {
    let mut c = input.chars();
    match c.next() {
        None =&amp;gt; String::new(),
        Some(first) =&amp;gt; ???,
    }
}

&amp;#x2F;&amp;#x2F; Step 2.
&amp;#x2F;&amp;#x2F; Apply the `capitalize_first` function to a slice of string slices.
&amp;#x2F;&amp;#x2F; Return a vector of strings.
&amp;#x2F;&amp;#x2F; [&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;] -&amp;gt; [&amp;quot;Hello&amp;quot;, &amp;quot;World&amp;quot;]
pub fn capitalize_words_vector(words: &amp;amp;[&amp;amp;str]) -&amp;gt; Vec&amp;lt;String&amp;gt; {
    vec![]
}

&amp;#x2F;&amp;#x2F; Step 3.
&amp;#x2F;&amp;#x2F; Apply the `capitalize_first` function again to a slice of string slices.
&amp;#x2F;&amp;#x2F; Return a single string.
&amp;#x2F;&amp;#x2F; [&amp;quot;hello&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;world&amp;quot;] -&amp;gt; &amp;quot;Hello World&amp;quot;
pub fn capitalize_words_string(words: &amp;amp;[&amp;amp;str]) -&amp;gt; String {
    String::new()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(capitalize_first(&amp;quot;hello&amp;quot;), &amp;quot;Hello&amp;quot;);
    }

    #[test]
    fn test_empty() {
        assert_eq!(capitalize_first(&amp;quot;&amp;quot;), &amp;quot;&amp;quot;);
    }

    #[test]
    fn test_iterate_string_vec() {
        let words = vec![&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;];
        assert_eq!(capitalize_words_vector(&amp;amp;words), [&amp;quot;Hello&amp;quot;, &amp;quot;World&amp;quot;]);
    }

    #[test]
    fn test_iterate_into_string() {
        let words = vec![&amp;quot;hello&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;world&amp;quot;];
        assert_eq!(capitalize_words_string(&amp;amp;words), &amp;quot;Hello World&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;iterators2-rs-errors&quot;&gt;Iterators2.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;iterators&amp;#x2F;iterators2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;iterators&amp;#x2F;iterators2.rs:15:24
   |
15 |         Some(first) =&amp;gt; ???,
   |                     -- ^ expected expression
   |                     |
   |                     while parsing the `match` arm starting here

error: aborting due to previous error

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;our errors are to be expected with our incomplete functions, so let&#x27;s move on to&lt;&#x2F;p&gt;
&lt;h2 id=&quot;iterators2-rs-solution&quot;&gt;Iterators2.rs Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Step 1.
&amp;#x2F;&amp;#x2F; Complete the `capitalize_first` function.
&amp;#x2F;&amp;#x2F; &amp;quot;hello&amp;quot; -&amp;gt; &amp;quot;Hello&amp;quot;
pub fn capitalize_first(input: &amp;amp;str) -&amp;gt; String {
    let mut c = input.chars();
    match c.next() {
        None =&amp;gt; String::new(),
        Some(first) =&amp;gt; first.to_uppercase().collect::&amp;lt;String&amp;gt;() + c.as_str(),
    }
}

&amp;#x2F;&amp;#x2F; Step 2.
&amp;#x2F;&amp;#x2F; Apply the `capitalize_first` function to a slice of string slices.
&amp;#x2F;&amp;#x2F; Return a vector of strings.
&amp;#x2F;&amp;#x2F; [&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;] -&amp;gt; [&amp;quot;Hello&amp;quot;, &amp;quot;World&amp;quot;]
pub fn capitalize_words_vector(words: &amp;amp;[&amp;amp;str]) -&amp;gt; Vec&amp;lt;String&amp;gt; {
    words.iter().map(|x| capitalize_first(x)).collect()
}

&amp;#x2F;&amp;#x2F; Step 3.
&amp;#x2F;&amp;#x2F; Apply the `capitalize_first` function again to a slice of string slices.
&amp;#x2F;&amp;#x2F; Return a single string.
&amp;#x2F;&amp;#x2F; [&amp;quot;hello&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;world&amp;quot;] -&amp;gt; &amp;quot;Hello World&amp;quot;
pub fn capitalize_words_string(words: &amp;amp;[&amp;amp;str]) -&amp;gt; String {
    capitalize_words_vector(words).join(&amp;quot;&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is one of the more involved solutions we&#x27;ve seen in a while, so let&#x27;s go over each step and what we did to finish each function and make our code compile and pass the tests.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Step 1 - &lt;code&gt;capitalize_first&lt;&#x2F;code&gt; function:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We have a function called &lt;code&gt;capitalize_first&lt;&#x2F;code&gt; that takes a reference to a string (&lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;) as input.&lt;&#x2F;li&gt;
&lt;li&gt;Inside the function, we used the &lt;code&gt;.chars()&lt;&#x2F;code&gt; method to get an iterator over the characters in the input string.&lt;&#x2F;li&gt;
&lt;li&gt;We then used a &lt;code&gt;match&lt;&#x2F;code&gt; expression to handle two cases:
&lt;ul&gt;
&lt;li&gt;If the iterator is empty (i.e., the input string is empty), we returned an empty &lt;code&gt;String&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;If there is at least one character, we used &lt;code&gt;.next()&lt;&#x2F;code&gt; to get the first character and then applied the &lt;code&gt;.to_uppercase()&lt;&#x2F;code&gt; method to convert it to uppercase.&lt;&#x2F;li&gt;
&lt;li&gt;Finally, we used &lt;code&gt;.collect::&amp;lt;String&amp;gt;()&lt;&#x2F;code&gt; to collect the uppercase character and the rest of the characters (using &lt;code&gt;c.as_str()&lt;&#x2F;code&gt;) into a new &lt;code&gt;String&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Step 2 - &lt;code&gt;capitalize_words_vector&lt;&#x2F;code&gt; function:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We complete a function called &lt;code&gt;capitalize_words_vector&lt;&#x2F;code&gt; that takes a slice of string slices (&lt;code&gt;&amp;amp;[&amp;amp;str]&lt;&#x2F;code&gt;) as input.&lt;&#x2F;li&gt;
&lt;li&gt;Inside the function, we used &lt;code&gt;.iter()&lt;&#x2F;code&gt; to iterate over the elements in the input slice (which are string slices).&lt;&#x2F;li&gt;
&lt;li&gt;For each string slice, we applied the &lt;code&gt;capitalize_first&lt;&#x2F;code&gt; function to capitalize its first character and collected the results into a &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;&#x2F;code&gt; using &lt;code&gt;.map()&lt;&#x2F;code&gt; and &lt;code&gt;.collect()&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Step 3 - &lt;code&gt;capitalize_words_string&lt;&#x2F;code&gt; function:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We created a function called &lt;code&gt;capitalize_words_string&lt;&#x2F;code&gt; that takes a slice of string slices (&lt;code&gt;&amp;amp;[&amp;amp;str]&lt;&#x2F;code&gt;) as input.&lt;&#x2F;li&gt;
&lt;li&gt;Inside the function, we reused the &lt;code&gt;capitalize_words_vector&lt;&#x2F;code&gt; function to get a vector of capitalized words.&lt;&#x2F;li&gt;
&lt;li&gt;To create a single string, we used the &lt;code&gt;.join(&amp;quot;&amp;quot;)&lt;&#x2F;code&gt; method, which concatenates all the elements in the vector without any spaces between them.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Overall, the solution focuses on creating reusable functions (&lt;code&gt;capitalize_first&lt;&#x2F;code&gt; and &lt;code&gt;capitalize_words_vector&lt;&#x2F;code&gt;) to handle the capitalization of individual words and then uses these functions to achieve the desired output for the exercise (&lt;code&gt;capitalize_words_string&lt;&#x2F;code&gt;). This approach makes the code more modular and easier to understand.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âœ… Successfully tested exercises&amp;#x2F;iterators&amp;#x2F;iterators2.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With that we have passed the test, let&#x27;s continue to our next exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;iterators3-rs&quot;&gt;Iterators3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; iterators3.rs
&amp;#x2F;&amp;#x2F; This is a bigger exercise than most of the others! You can do it!
&amp;#x2F;&amp;#x2F; Here is your mission, should you choose to accept it:
&amp;#x2F;&amp;#x2F; 1. Complete the divide function to get the first four tests to pass.
&amp;#x2F;&amp;#x2F; 2. Get the remaining tests to pass by completing the result_with_list and
&amp;#x2F;&amp;#x2F;    list_of_results functions.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint iterators3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[derive(Debug, PartialEq, Eq)]
pub enum DivisionError {
    NotDivisible(NotDivisibleError),
    DivideByZero,
}

#[derive(Debug, PartialEq, Eq)]
pub struct NotDivisibleError {
    dividend: i32,
    divisor: i32,
}

&amp;#x2F;&amp;#x2F; Calculate `a` divided by `b` if `a` is evenly divisible by `b`.
&amp;#x2F;&amp;#x2F; Otherwise, return a suitable error.
pub fn divide(a: i32, b: i32) -&amp;gt; Result&amp;lt;i32, DivisionError&amp;gt; {
    todo!();
}

&amp;#x2F;&amp;#x2F; Complete the function and return a value of the correct type so the test passes.
&amp;#x2F;&amp;#x2F; Desired output: Ok([1, 11, 1426, 3])
fn result_with_list() -&amp;gt; () {
    let numbers = vec![27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
}

&amp;#x2F;&amp;#x2F; Complete the function and return a value of the correct type so the test passes.
&amp;#x2F;&amp;#x2F; Desired output: [Ok(1), Ok(11), Ok(1426), Ok(3)]
fn list_of_results() -&amp;gt; () {
    let numbers = vec![27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(divide(81, 9), Ok(9));
    }

    #[test]
    fn test_not_divisible() {
        assert_eq!(
            divide(81, 6),
            Err(DivisionError::NotDivisible(NotDivisibleError {
                dividend: 81,
                divisor: 6
            }))
        );
    }

    #[test]
    fn test_divide_by_0() {
        assert_eq!(divide(81, 0), Err(DivisionError::DivideByZero));
    }

    #[test]
    fn test_divide_0_by_something() {
        assert_eq!(divide(0, 81), Ok(0));
    }

    #[test]
    fn test_result_with_list() {
        assert_eq!(format!(&amp;quot;{:?}&amp;quot;, result_with_list()), &amp;quot;Ok([1, 11, 1426, 3])&amp;quot;);
    }

    #[test]
    fn test_list_of_results() {
        assert_eq!(
            format!(&amp;quot;{:?}&amp;quot;, list_of_results()),
            &amp;quot;[Ok(1), Ok(11), Ok(1426), Ok(3)]&amp;quot;
        );
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Okay, this is a longer one, so let&#x27;s breakdown the instructions.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Complete the &lt;code&gt;divide&lt;&#x2F;code&gt; function&lt;&#x2F;li&gt;
&lt;li&gt;Complete the  &lt;code&gt;results_with_list&lt;&#x2F;code&gt; function&lt;&#x2F;li&gt;
&lt;li&gt;Complete the &lt;code&gt;list_of_results&lt;&#x2F;code&gt; function&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;iterators3-rs-errors&quot;&gt;Iterators3.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Testing of exercises&amp;#x2F;iterators&amp;#x2F;iterators3.rs failed! Please try again. Here&amp;#x27;s the output:

running 6 tests
test tests::test_divide_0_by_something ... FAILED
test tests::test_not_divisible ... FAILED
test tests::test_divide_by_0 ... FAILED
test tests::test_result_with_list ... FAILED
test tests::test_list_of_results ... FAILED
test tests::test_success ... FAILED

successes:

successes:

failures:

---- tests::test_divide_0_by_something stdout ----
thread &amp;#x27;tests::test_divide_0_by_something&amp;#x27; panicked at exercises&amp;#x2F;iterators&amp;#x2F;iterators3.rs:26:5:
not yet implemented

---- tests::test_not_divisible stdout ----
thread &amp;#x27;tests::test_not_divisible&amp;#x27; panicked at exercises&amp;#x2F;iterators&amp;#x2F;iterators3.rs:26:5:
not yet implemented

---- tests::test_divide_by_0 stdout ----
thread &amp;#x27;tests::test_divide_by_0&amp;#x27; panicked at exercises&amp;#x2F;iterators&amp;#x2F;iterators3.rs:26:5:
not yet implemented
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

---- tests::test_result_with_list stdout ----
thread &amp;#x27;tests::test_result_with_list&amp;#x27; panicked at exercises&amp;#x2F;iterators&amp;#x2F;iterators3.rs:75:9:
assertion `left == right` failed
  left: &amp;quot;()&amp;quot;
 right: &amp;quot;Ok([1, 11, 1426, 3])&amp;quot;

---- tests::test_list_of_results stdout ----
thread &amp;#x27;tests::test_list_of_results&amp;#x27; panicked at exercises&amp;#x2F;iterators&amp;#x2F;iterators3.rs:80:9:
assertion `left == right` failed
  left: &amp;quot;()&amp;quot;
 right: &amp;quot;[Ok(1), Ok(11), Ok(1426), Ok(3)]&amp;quot;

---- tests::test_success stdout ----
thread &amp;#x27;tests::test_success&amp;#x27; panicked at exercises&amp;#x2F;iterators&amp;#x2F;iterators3.rs:26:5:
not yet implemented


failures:
    tests::test_divide_0_by_something
    tests::test_divide_by_0
    tests::test_list_of_results
    tests::test_not_divisible
    tests::test_result_with_list
    tests::test_success

test result: FAILED. 0 passed; 6 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see that we have a total 6 tests and they&#x27;re all failing. The first 3 are because the functions are not yet implemented as our compiler confirms, the next 2 show us that the &lt;code&gt;left&lt;&#x2F;code&gt; is not matching the &lt;code&gt;right&lt;&#x2F;code&gt; and our final test is also because it&#x27;s not yet implemented.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;iterators3-rs-solution&quot;&gt;Iterators3.rs Solution&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;1-complete-the-divide-function&quot;&gt;1. Complete the &lt;code&gt;divide&lt;&#x2F;code&gt; function&lt;&#x2F;h3&gt;
&lt;p&gt;Our instructions to complete the &lt;code&gt;divide&lt;&#x2F;code&gt; function are the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Calculate `a` divided by `b` if `a` is evenly divisible by `b`.
&amp;#x2F;&amp;#x2F; Otherwise, return a suitable error.
pub fn divide(a: i32, b: i32) -&amp;gt; Result&amp;lt;i32, DivisionError&amp;gt; {
    todo!();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this function we actually have a couple of different ways of solving it, we can use the classic &lt;code&gt;if&lt;&#x2F;code&gt; statement or use a more &amp;quot;Rusty&amp;quot; approach by using &lt;code&gt;match&lt;&#x2F;code&gt;. Let&#x27;s first look at the more traditional method of completing this function. Our instructions tell is that we have to calculate if &lt;code&gt;a&lt;&#x2F;code&gt; can be evenly divided by &lt;code&gt;b&lt;&#x2F;code&gt; if, it can we do it, if not we return an error. If we look our &lt;code&gt;enum&lt;&#x2F;code&gt; &lt;code&gt;DivisionError&lt;&#x2F;code&gt; we can see that we have 2 possible errors, so that gives us a total of 3 possible scenarios:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Ok()&lt;&#x2F;code&gt;: if &lt;code&gt;a&lt;&#x2F;code&gt; is divisible by &lt;code&gt;b&lt;&#x2F;code&gt; and we divided&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Err()&lt;&#x2F;code&gt;: if we are trying to divide by so if &lt;code&gt;b == 0&lt;&#x2F;code&gt; so we return the &lt;code&gt;DividebyZero&lt;&#x2F;code&gt;error.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Err()&lt;&#x2F;code&gt;: if &lt;code&gt;a&lt;&#x2F;code&gt; is not evenly divisible by &lt;code&gt;b&lt;&#x2F;code&gt; we return &lt;code&gt;NotDivisible(NotDivisibleError)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Alright let&#x27;s implement this. Note, that we should implement the &lt;code&gt;if b == 0&lt;&#x2F;code&gt; first to make sure that &lt;code&gt;b&lt;&#x2F;code&gt; is not zero before proceeding to &lt;code&gt;a % b&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn divide(a: i32, b: i32) -&amp;gt; Result&amp;lt;i32, DivisionError&amp;gt; {
    if b == 0 {
        &amp;#x2F;&amp;#x2F; If the divisor is zero, return the DivideByZero error.
        Err(DivisionError::DivideByZero)
    } else if a % b == 0 {
        &amp;#x2F;&amp;#x2F; If &amp;#x27;a&amp;#x27; is evenly divisible by &amp;#x27;b&amp;#x27;, return the result.
        Ok(a &amp;#x2F; b)
    } else {
        &amp;#x2F;&amp;#x2F; If &amp;#x27;a&amp;#x27; is not evenly divisible by &amp;#x27;b&amp;#x27;, return the NotDivisible error.
        Err(DivisionError::NotDivisible(NotDivisibleError {
            dividend: a,
            divisor: b,
        }))
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now let&#x27;s look at this alternative version using using match:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn divide(a: i32, b: i32) -&amp;gt; Result&amp;lt;i32, DivisionError&amp;gt; {
    match (a, b) {
	    &amp;#x2F;&amp;#x2F; first check if the divisor is zero
        (_, 0) =&amp;gt; Err(DivisionError::DivideByZero),
        &amp;#x2F;&amp;#x2F; then check if (x, y) are evenly divisible
        (x, y) if x % y == 0 =&amp;gt; Ok(x &amp;#x2F; y),
        &amp;#x2F;&amp;#x2F; lastly return an error if it&amp;#x27;s not even divisible
        (x, y) =&amp;gt; Err(DivisionError::NotDivisible(NotDivisibleError {
            dividend: x,
            divisor: y,
        })),
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this version:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We use a &lt;code&gt;match&lt;&#x2F;code&gt; expression to pattern match with a the tuple &lt;code&gt;(a, b)&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;The first arm &lt;code&gt;(_, 0) =&amp;gt; Err(DivisionError::DivideByZero)&lt;&#x2F;code&gt; matches when the divisor &lt;code&gt;b&lt;&#x2F;code&gt; is zero, and it returns the &lt;code&gt;DivideByZero&lt;&#x2F;code&gt; error.&lt;&#x2F;li&gt;
&lt;li&gt;The second arm &lt;code&gt;(x, y) if x % y == 0 =&amp;gt; Ok(x &#x2F; y)&lt;&#x2F;code&gt; matches when &lt;code&gt;a&lt;&#x2F;code&gt; is evenly divisible by &lt;code&gt;b&lt;&#x2F;code&gt;, and it returns the result of the division as &lt;code&gt;Ok&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;The third arm &lt;code&gt;(x, y)&lt;&#x2F;code&gt; is a catch-all that matches any other case where &lt;code&gt;a&lt;&#x2F;code&gt; is not evenly divisible by &lt;code&gt;b&lt;&#x2F;code&gt;. It returns the &lt;code&gt;NotDivisible&lt;&#x2F;code&gt; error with the appropriate &lt;code&gt;NotDivisibleError&lt;&#x2F;code&gt; struct.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Let&#x27;s save at this point and see what happens:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;test result: FAILED. 4 passed; 2 failed;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Great, it looks like we have passed 4 tests, by completing that first function.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;2-complete-the-results-with-list-function&quot;&gt;2. Complete the  &lt;code&gt;results_with_list&lt;&#x2F;code&gt; function&lt;&#x2F;h3&gt;
&lt;p&gt;These are the instructions to help us complete this function.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Complete the function and return a value of the correct type so the test passes.
&amp;#x2F;&amp;#x2F; Desired output: Ok([1, 11, 1426, 3])
fn result_with_list() -&amp;gt; () {
    let numbers = vec![27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So, let&#x27;s add a return type, if we look at the rest of the function you can see that we are using a &lt;code&gt;Vec&lt;&#x2F;code&gt; so, that makes it pretty straight forward to understand what we have to return right?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn result_with_list() -&amp;gt; Result&amp;lt;Vec&amp;lt;i32&amp;gt;, DivisionError&amp;gt; {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our function signature should be updated to handle returning a &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt; if all is &lt;code&gt;Ok&lt;&#x2F;code&gt; or a &lt;code&gt;DivisionError&lt;&#x2F;code&gt; if it&#x27;s not so we put that in the function signature to  complete it. Next let&#x27;s format the &lt;code&gt;division_results&lt;&#x2F;code&gt; function a little differently from the one liner to the having each method start on a new line.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let division_results = numbers
    .into_iter()
    .map(|n| divide(n, 27))
    .collect();
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This also give us the opportunity to add the &lt;code&gt;.collect()&lt;&#x2F;code&gt; method which was missing and essentially when &amp;quot;collecting&amp;quot; elements back into a vector. This also makes it easier to read in my opinion.&lt;&#x2F;p&gt;
&lt;p&gt;Finally to complete this function we have to return a value. Right now if we compile we&#x27;d see this message:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;40 | fn result_with_list() -&amp;gt; Result&amp;lt;Vec&amp;lt;i32&amp;gt;, DivisionError&amp;gt; {
   |    ----------------      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result&amp;lt;Vec&amp;lt;i32&amp;gt;, DivisionError&amp;gt;`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `Result&amp;lt;Vec&amp;lt;i32&amp;gt;, DivisionError&amp;gt;`
           found unit type `()`
help: consider returning the local binding `division_results`
   |
45 ~         .collect();
46 +     division_results
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Luckily the Rust&#x27;s error message is explicit in telling you what you should return. If we add &lt;code&gt;division_results&lt;&#x2F;code&gt; on line &lt;code&gt;46&lt;&#x2F;code&gt; we get this printout:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;running 6 tests
test tests::test_divide_0_by_something ... ok
test tests::test_divide_by_0 ... ok
test tests::test_not_divisible ... ok
test tests::test_result_with_list ... ok
test tests::test_success ... ok
test tests::test_list_of_results ... FAILED
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright we&#x27;re almost there.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;3-complete-the-list-of-results-function&quot;&gt;3. Complete the &lt;code&gt;list_of_results&lt;&#x2F;code&gt; function&lt;&#x2F;h3&gt;
&lt;p&gt;This is our final function to complete as you can see we are passing all our tests except our final one, so let&#x27;s dig into the instructions for this one.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Complete the function and return a value of the correct type so the test passes.
&amp;#x2F;&amp;#x2F; Desired output: [Ok(1), Ok(11), Ok(1426), Ok(3)]
fn list_of_results() -&amp;gt; () {
    let numbers = vec![27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our starting point looks very similar to our previous function but the desired output is different. As it seems to be wanting one &lt;code&gt;Ok&lt;&#x2F;code&gt; result for every number vs a &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt;. So how do we solve this?&lt;&#x2F;p&gt;
&lt;p&gt;Instead of wrapping our &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt; in &lt;code&gt;Result&lt;&#x2F;code&gt; we wrap our &lt;code&gt;Result&lt;&#x2F;code&gt; in a &lt;code&gt;Vec&amp;lt;Result&amp;lt;i32&amp;gt;&amp;gt;&lt;&#x2F;code&gt; like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn list_of_results() -&amp;gt; Vec&amp;lt;Result&amp;lt;i32, DivisionError&amp;gt;&amp;gt; {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and then like in our previous example, we use the &lt;code&gt;.collect()&lt;&#x2F;code&gt; method and return&lt;code&gt;division_results&lt;&#x2F;code&gt;. Here&#x27;s the full block for reference.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn list_of_results() -&amp;gt; Vec&amp;lt;Result&amp;lt;i32, DivisionError&amp;gt;&amp;gt; {
    let numbers = vec![27, 297, 38502, 81];
    let division_results: Vec&amp;lt;Result&amp;lt;i32, DivisionError&amp;gt;&amp;gt; = numbers
        .into_iter()
        .map(|n| divide(n, 27))
        .collect();

    division_results
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol&gt;
&lt;li&gt;We specify the return type as &lt;code&gt;Vec&amp;lt;Result&amp;lt;i32, DivisionError&amp;gt;&amp;gt;&lt;&#x2F;code&gt; to match the desired output.&lt;&#x2F;li&gt;
&lt;li&gt;We use the &lt;code&gt;collect&lt;&#x2F;code&gt; method on the iterator of division results. This method collects the individual results into a &lt;code&gt;Vec&amp;lt;Result&amp;lt;i32, DivisionError&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;We store the collected results in the &lt;code&gt;division_results&lt;&#x2F;code&gt; variable.&lt;&#x2F;li&gt;
&lt;li&gt;Finally, we return &lt;code&gt;division_results&lt;&#x2F;code&gt;, which is a &lt;code&gt;Vec&lt;&#x2F;code&gt; containing individual &lt;code&gt;Ok&lt;&#x2F;code&gt; results.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This should make the test pass with the desired output &lt;code&gt;[Ok(1), Ok(11), Ok(1426), Ok(3)]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âœ… Successfully tested exercises&amp;#x2F;iterators&amp;#x2F;iterators3.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;iterators4-rs&quot;&gt;Iterators4.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; iterators4.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint iterators4` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub fn factorial(num: u64) -&amp;gt; u64 {
    &amp;#x2F;&amp;#x2F; Complete this function to return the factorial of num
    &amp;#x2F;&amp;#x2F; Do not use:
    &amp;#x2F;&amp;#x2F; - return
    &amp;#x2F;&amp;#x2F; Try not to use:
    &amp;#x2F;&amp;#x2F; - imperative style loops (for, while)
    &amp;#x2F;&amp;#x2F; - additional variables
    &amp;#x2F;&amp;#x2F; For an extra challenge, don&amp;#x27;t use:
    &amp;#x2F;&amp;#x2F; - recursion
    &amp;#x2F;&amp;#x2F; Execute `rustlings hint iterators4` for hints.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn factorial_of_0() {
        assert_eq!(1, factorial(0));
    }

    #[test]
    fn factorial_of_1() {
        assert_eq!(1, factorial(1));
    }
    #[test]
    fn factorial_of_2() {
        assert_eq!(2, factorial(2));
    }

    #[test]
    fn factorial_of_4() {
        assert_eq!(24, factorial(4));
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Okay it seems we have a little challenge here to create a function that returns the factorial of &lt;code&gt;num&lt;&#x2F;code&gt;
we also have some added limitations.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Do not use &lt;code&gt;return&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Try not use &lt;code&gt;for&lt;&#x2F;code&gt; or &lt;code&gt;while&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Additional variables&lt;&#x2F;li&gt;
&lt;li&gt;Extra credit: Don&#x27;t use recursion&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;iterators4-rs-errors&quot;&gt;Iterators4.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;iterators&amp;#x2F;iterators4.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
 --&amp;gt; exercises&amp;#x2F;iterators&amp;#x2F;iterators4.rs:6:31
  |
6 | pub fn factorial(num: u64) -&amp;gt; u64 {
  |        ---------              ^^^ expected `u64`, found `()`
  |        |
  |        implicitly returns `()` as its body has no tail or `return` expression
  |
help: consider returning the local binding `num`
  |
6 ~ pub fn factorial(num: u64) -&amp;gt; u64 {
7 +     num
  |
error: aborting due to previous error

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our errors don&#x27;t tell us much in this case we know we have an incomplete function&lt;&#x2F;p&gt;
&lt;h2 id=&quot;iterators4-rs-solution&quot;&gt;Iterators4.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;So our challenge is pretty wide open, meaning we do have a possible few different ways to solve this, but let&#x27;s try to stick as closely as possible to the requirements. It&#x27;s clear this exercise is made for us to iterators and their associated methods.&lt;&#x2F;p&gt;
&lt;p&gt;But before we do that let&#x27;s make sure we understand the goal, just incase some of us need to brush up on our math terminology, let&#x27;s make sure we understand the definition of a &lt;em&gt;factorial&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;what-is-a-factorial&quot;&gt;What is a Factorial?&lt;&#x2F;h3&gt;
&lt;p&gt;Factorials are a fascinating concept in mathematics that involves multiplying a sequence of numbers together.&lt;&#x2F;p&gt;
&lt;p&gt;Simply put, a factorial of a number is the product of all positive integers from 1 to that number. For example, the factorial of 5 is calculated as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;5! = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In Rust, you can do this easily and efficiently using a few simple methods.&lt;&#x2F;p&gt;
&lt;p&gt;So we said that to calculate a factorial we need a sequence of numbers from 1 to that numbers so how do we represent this in Rust?&lt;code&gt;1..num&lt;&#x2F;code&gt; seems like a logical choice. Right, so now we have to take this range and iterate over it but instead of using &lt;code&gt;iter&lt;&#x2F;code&gt; let&#x27;s use &lt;code&gt;into_iter&lt;&#x2F;code&gt; which allows us to take ownership of each element and then we use &lt;code&gt;.product()&lt;&#x2F;code&gt; which we haven&#x27;t used before but comes in handy in situations like these, more on product below.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn factorial(num: u64) -&amp;gt; u64 {
    (1..=num).into_iter().product()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;product-notes&quot;&gt;&lt;code&gt;.product()&lt;&#x2F;code&gt; Notes&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;product()&lt;&#x2F;code&gt; method is a convenient way to calculate the product of all the numbers in an iterator or a range. In the context of calculating a factorial, think of it like this:&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s say you want to find the factorial of a number, like &lt;code&gt;5!&lt;&#x2F;code&gt; (read as &amp;quot;5 factorial&amp;quot;). This means you want to multiply all the positive whole numbers from &lt;code&gt;1&lt;&#x2F;code&gt; to &lt;code&gt;5&lt;&#x2F;code&gt; together: &lt;code&gt;1 * 2 * 3 * 4 * 5&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Using an iterator or a range, you can create a sequence of these numbers: &lt;code&gt;1, 2, 3, 4, 5&lt;&#x2F;code&gt;. Then, when you apply the &lt;code&gt;product()&lt;&#x2F;code&gt; method to this sequence, it will perform the multiplication for you and give you the result, which in this case is &lt;code&gt;120&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;So, in essence, &lt;code&gt;product()&lt;&#x2F;code&gt; takes a sequence of numbers and multiplies them all together, making it handy for tasks like calculating factorials. It&#x27;s like a built-in calculator for products in Rust!&lt;&#x2F;p&gt;
&lt;p&gt;So if we save this we will successfully compile.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s move on to our final exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;iterators5-rs&quot;&gt;Iterators5.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; iterators5.rs
&amp;#x2F;&amp;#x2F; Let&amp;#x27;s define a simple model to track Rustlings exercise progress. Progress
&amp;#x2F;&amp;#x2F; will be modelled using a hash map. The name of the exercise is the key and
&amp;#x2F;&amp;#x2F; the progress is the value. Two counting functions were created to count the
&amp;#x2F;&amp;#x2F; number of exercises with a given progress. These counting functions use
&amp;#x2F;&amp;#x2F; imperative style for loops. Recreate this counting functionality using
&amp;#x2F;&amp;#x2F; iterators. Only the two iterator methods (count_iterator and
&amp;#x2F;&amp;#x2F; count_collection_iterator) need to be modified.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint iterators5` or use the `hint` watch subcommand for a hint.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Make the code compile and the tests pass.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::collections::HashMap;

#[derive(Clone, Copy, PartialEq, Eq)]
enum Progress {
    None,
    Some,
    Complete,
}

fn count_for(map: &amp;amp;HashMap&amp;lt;String, Progress&amp;gt;, value: Progress) -&amp;gt; usize {
    let mut count = 0;
    for val in map.values() {
        if val == &amp;amp;value {
            count += 1;
        }
    }
    count
}

fn count_iterator(map: &amp;amp;HashMap&amp;lt;String, Progress&amp;gt;, value: Progress) -&amp;gt; usize {
    &amp;#x2F;&amp;#x2F; map is a hashmap with String keys and Progress values.
    &amp;#x2F;&amp;#x2F; map = { &amp;quot;variables1&amp;quot;: Complete, &amp;quot;from_str&amp;quot;: None, ... }
    todo!();
}

fn count_collection_for(collection: &amp;amp;[HashMap&amp;lt;String, Progress&amp;gt;], value: Progress) -&amp;gt; usize {
    let mut count = 0;
    for map in collection {
        for val in map.values() {
            if val == &amp;amp;value {
                count += 1;
            }
        }
    }
    count
}

fn count_collection_iterator(collection: &amp;amp;[HashMap&amp;lt;String, Progress&amp;gt;], value: Progress) -&amp;gt; usize {
    &amp;#x2F;&amp;#x2F; collection is a slice of hashmaps.
    &amp;#x2F;&amp;#x2F; collection = [{ &amp;quot;variables1&amp;quot;: Complete, &amp;quot;from_str&amp;quot;: None, ... },
    &amp;#x2F;&amp;#x2F;     { &amp;quot;variables2&amp;quot;: Complete, ... }, ... ]
    todo!();
}

#[cfg(test)]
mod tests {
    use super::*;

&amp;#x2F;&amp;#x2F; tests removed for space...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are to finish 2 functions using iterators instead of imperative style loops.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;iterators5-rs-errors&quot;&gt;Iterators5.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Testing of exercises&amp;#x2F;iterators&amp;#x2F;iterators5.rs failed! Please try again. Here&amp;#x27;s the output:

running 4 tests
test tests::count_complete ... FAILED
test tests::count_equals_for ... FAILED
test tests::count_collection_complete ... FAILED
test tests::count_collection_equals_for ... FAILED
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For reference,  here are failing tests, but this is expected as they are not implemented yet.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;iterators5-rs-solution&quot;&gt;Iterators5.rs Solution&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;count-iterator-solution&quot;&gt;&lt;code&gt;count_iterator&lt;&#x2F;code&gt; solution&lt;&#x2F;h3&gt;
&lt;p&gt;For the first function &lt;code&gt;count_iterator&lt;&#x2F;code&gt; we have additional note to help us complete our function&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn count_iterator(map: &amp;amp;HashMap&amp;lt;String, Progress&amp;gt;, value: Progress) -&amp;gt; usize {
    &amp;#x2F;&amp;#x2F; map is a hashmap with String keys and Progress values.
    &amp;#x2F;&amp;#x2F; map = { &amp;quot;variables1&amp;quot;: Complete, &amp;quot;from_str&amp;quot;: None, ... }
    todo!();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here&#x27;s a way we can solve this function&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We use &lt;code&gt;map.values()&lt;&#x2F;code&gt; to obtain an iterator over the values in the hashmap.&lt;&#x2F;li&gt;
&lt;li&gt;We use &lt;code&gt;filter&lt;&#x2F;code&gt; to keep only the values that are equal to the given &lt;code&gt;value&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Finally, we call &lt;code&gt;count()&lt;&#x2F;code&gt; to count the number of elements that match the condition.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn count_iterator(map: &amp;amp;HashMap&amp;lt;String, Progress&amp;gt;, value: Progress) -&amp;gt; usize {
    map.values()
    .filter(|&amp;amp;&amp;amp;val| val == value)
    .count()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This should complete our function and move us closer to compiling.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;count-collection-iterator-solution&quot;&gt;&lt;code&gt;count_collection_iterator&lt;&#x2F;code&gt; solution&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn count_collection_iterator(collection: &amp;amp;[HashMap&amp;lt;String, Progress&amp;gt;], value: Progress) -&amp;gt; usize {
    &amp;#x2F;&amp;#x2F; collection is a slice of hashmaps.
    &amp;#x2F;&amp;#x2F; collection = [{ &amp;quot;variables1&amp;quot;: Complete, &amp;quot;from_str&amp;quot;: None, ... },
    &amp;#x2F;&amp;#x2F;     { &amp;quot;variables2&amp;quot;: Complete, ... }, ... ]
    todo!();
}```
again a similar situation where we have to complete our function with additional notes and instructions in the comments.

We can approach this function like so:
- We use `collection.iter()` to get an iterator over the slices of hashmaps.
- We use `flat_map` to flatten each slice of hashmap values into a single iterator of values.
- Then, we apply the same `filter` and `count` operations as in `count_iterator` to count the matching values across all hashmaps in the collection.

Our final code block looks like this:
```rust
fn count_collection_iterator(collection: &amp;amp;[HashMap&amp;lt;String, Progress&amp;gt;], value: Progress) -&amp;gt; usize {
    collection.iter()
    .flat_map(|map| map.values())
    .filter(|&amp;amp;&amp;amp;val| val == value)
    .count()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And with this we are compiling and passing our tests!&lt;&#x2F;p&gt;
&lt;p&gt;I apologize for the oversight. Let&#x27;s wrap up your blog with a suitable conclusion.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In these &lt;code&gt;rustlings&lt;&#x2F;code&gt; exercises, we&#x27;ve traversed the intriguing waters of Rust&#x27;s iterators, pattern matching, and handling results. Rust, being a language that prioritizes safety and efficiency, provides tools like &lt;code&gt;match&lt;&#x2F;code&gt; and &lt;code&gt;Result&lt;&#x2F;code&gt; to handle various scenarios gracefully. The real power of Rust lies in its expressive type system and the way it allows us to catch errors at compile time. By practicing with iterators and learning to handle errors the &amp;quot;Rusty&amp;quot; way, we&#x27;re not just writing more concise code; we&#x27;re embracing a paradigm that avoids common pitfalls seen in other languages.&lt;&#x2F;p&gt;
&lt;p&gt;Through our journey of solving the provided exercises, we have reinforced the idea that Rust provides an elegant balance between performance and safety. Its functional capabilities, combined with its low-level control, make it a top choice for systems programming and beyond. If you&#x27;re still new to Rust, I hope this exploration has provided clarity and fueled your interest to dig deeper. If you&#x27;re already a seasoned Rustacean, I hope this was a refreshing recap and perhaps even offered a new perspective or two.&lt;&#x2F;p&gt;
&lt;p&gt;In the world of programming, continuous learning is the key. As we&#x27;ve seen today, even seemingly simple exercises can offer valuable insights. Keep coding, keep exploring, and always strive to better your understanding. The Rust community is vast, welcoming, and ever-growing. With tools like &lt;code&gt;rustlings&lt;&#x2F;code&gt; and a plethora of online resources, your Rust journey is bound to be exciting and enlightening. Happy coding!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>20 Rustlings Lifetimes</title>
          <pubDate>Tue, 17 Oct 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/20-rustlings-lifetimes/</link>
          <guid>https://desmodrone.github.io/posts/20-rustlings-lifetimes/</guid>
          <description xml:base="https://desmodrone.github.io/posts/20-rustlings-lifetimes/">&lt;h1 id=&quot;lifetimes&quot;&gt;Lifetimes&lt;&#x2F;h1&gt;
&lt;h4 id=&quot;readme&quot;&gt;ReadMe&lt;&#x2F;h4&gt;
&lt;p&gt;Lifetimes tell the compiler how to check whether references live long
enough to be valid in any given situation. For example lifetimes say
&amp;quot;make sure parameter &#x27;a&#x27; lives as long as parameter &#x27;b&#x27; so that the return
value is valid&amp;quot;.&lt;&#x2F;p&gt;
&lt;p&gt;They are only necessary on borrows, i.e. references,
since copied parameters or moves are owned in their scope and cannot
be referenced outside. Lifetimes mean that calling code of e.g. functions
can be checked to make sure their arguments are valid. Lifetimes are
restrictive of their callers.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-03-lifetime-syntax.html&quot;&gt;Validating References with Lifetimes&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;rust-by-example&#x2F;scope&#x2F;lifetime.html&quot;&gt;Lifetimes (in Rust By Example)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;lifetimes1-rs&quot;&gt;Lifetimes1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; lifetimes1.rs
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; The Rust compiler needs to know how to check whether supplied references are
&amp;#x2F;&amp;#x2F; valid, so that it can let the programmer know if a reference is at risk
&amp;#x2F;&amp;#x2F; of going out of scope before it is used. Remember, references are borrows
&amp;#x2F;&amp;#x2F; and do not own their own data. What if their owner goes out of scope?
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Execute `rustlings hint lifetimes1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn longest(x: &amp;amp;str, y: &amp;amp;str) -&amp;gt; &amp;amp;str {
    if x.len() &amp;gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from(&amp;quot;abcd&amp;quot;);
    let string2 = &amp;quot;xyz&amp;quot;;

    let result = longest(string1.as_str(), string2);
    println!(&amp;quot;The longest string is &amp;#x27;{}&amp;#x27;&amp;quot;, result);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are to help the Rust compiler with the supplied references by using lifetime annotation I presume. As always let&#x27;s look at the compiler errors to see if there&#x27;s any additional details.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lifetimes1-rs-errors&quot;&gt;Lifetimes1.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;lifetimes&amp;#x2F;lifetimes1.rs failed! Please try again. Here is the output:
error[E0106]: missing lifetime specifier
  --&amp;gt; exercises&amp;#x2F;lifetimes&amp;#x2F;lifetimes1.rs:12:33
   |
12 | fn longest(x: &amp;amp;str, y: &amp;amp;str) -&amp;gt; &amp;amp;str {
   |               ----     ----     ^ expected named lifetime parameter
   |
   = help: this function&amp;#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
   |
12 | fn longest&amp;lt;&amp;#x27;a&amp;gt;(x: &amp;amp;&amp;#x27;a str, y: &amp;amp;&amp;#x27;a str) -&amp;gt; &amp;amp;&amp;#x27;a str {
   |           ++++     ++          ++          ++

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We get a solid hint for how to help the compiler understand the lifetime of the variables, let&#x27;s try to do what it suggest to do on line 12&lt;&#x2F;p&gt;
&lt;h2 id=&quot;liftemes1-rs-solution&quot;&gt;Liftemes1.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;So as the compiler error&#x27;s suggested we add a lifetime of &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; to our function signature. First right after the function name and then we assign it to the variables as seen below.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn longest&amp;lt;&amp;#x27;a&amp;gt;(x: &amp;amp;&amp;#x27;a str, y: &amp;amp;&amp;#x27;a str) -&amp;gt; &amp;amp;&amp;#x27;a str {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;our full code block looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn longest&amp;lt;&amp;#x27;a&amp;gt;(x: &amp;amp;&amp;#x27;a str, y: &amp;amp;&amp;#x27;a str) -&amp;gt; &amp;amp;&amp;#x27;a str {
    if x.len() &amp;gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from(&amp;quot;abcd&amp;quot;);
    let string2 = &amp;quot;xyz&amp;quot;;

    let result = longest(string1.as_str(), string2);
    println!(&amp;quot;The longest string is &amp;#x27;{}&amp;#x27;&amp;quot;, result);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;so-what-is-actually-happening-here&quot;&gt;So what is Actually Happening Here?&lt;&#x2F;h3&gt;
&lt;p&gt;To use lifetime annotations in function signatures, we declare generic lifetime parameters inside angle brackets, just like we do with generic type parameters. The key concept is that the reference returned must stay valid as long as both parameters are valid.&lt;&#x2F;p&gt;
&lt;p&gt;In our example, we define a lifetime &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;, and the function signature states that it takes two string slices (&lt;code&gt;&amp;amp;&#x27;a str&lt;&#x2F;code&gt;) as parameters, both of which should live at least as long as &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;. Additionally, the function signature ensures that the returned string slice also lives at least as long as &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;. This means the reference&#x27;s lifetime returned by the &lt;code&gt;longest&lt;&#x2F;code&gt; function is constrained by the shorter of the lifetimes of the values referred to by the function arguments.&lt;&#x2F;p&gt;
&lt;p&gt;Importantly, specifying these lifetime parameters doesn&#x27;t change the lifetimes of the values being passed or returned. Instead, it instructs the Rust borrow checker to reject any values that don&#x27;t adhere to these constraints.&lt;&#x2F;p&gt;
&lt;p&gt;and like that...we&#x27;re compiling&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰

Output:
====================
The longest string is &amp;#x27;abcd&amp;#x27;

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;lifetimes2-rs&quot;&gt;Lifetimes2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; lifetimes2.rs
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; So if the compiler is just validating the references passed
&amp;#x2F;&amp;#x2F; to the annotated parameters and the return type, what do
&amp;#x2F;&amp;#x2F; we need to change?
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Execute `rustlings hint lifetimes2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn longest&amp;lt;&amp;#x27;a&amp;gt;(x: &amp;amp;&amp;#x27;a str, y: &amp;amp;&amp;#x27;a str) -&amp;gt; &amp;amp;&amp;#x27;a str {
    if x.len() &amp;gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from(&amp;quot;long string is long&amp;quot;);
    let result;
    {
        let string2 = String::from(&amp;quot;xyz&amp;quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&amp;quot;The longest string is &amp;#x27;{}&amp;#x27;&amp;quot;, result);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have a similar exercise as before in terms of using the &lt;code&gt;longest&lt;&#x2F;code&gt; function but in this case we have an inner code block that declares &lt;code&gt;string2&lt;&#x2F;code&gt; and also &lt;code&gt;result&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lifetimes2-rs-errors&quot;&gt;Lifetimes2.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;lifetimes&amp;#x2F;lifetimes2.rs failed! Please try again. Here is the output:
error[E0597]: `string2` does not live long enough
  --&amp;gt; exercises&amp;#x2F;lifetimes&amp;#x2F;lifetimes2.rs:24:44
   |
23 |         let string2 = String::from(&amp;quot;xyz&amp;quot;);
   |             ------- binding `string2` declared here
24 |         result = longest(string1.as_str(), string2.as_str());
   |                                            ^^^^^^^ borrowed value does not live long enough
25 |     }
   |     - `string2` dropped here while still borrowed
26 |     println!(&amp;quot;The longest string is &amp;#x27;{}&amp;#x27;&amp;quot;, result);
   |                                            ------ borrow later used here

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, we encounter an issue where the &lt;code&gt;result&lt;&#x2F;code&gt; variable can&#x27;t be used outside the inner scope because it borrows a value (&lt;code&gt;string2&lt;&#x2F;code&gt;) that gets dropped as soon as the scope ends. To fix this, we either move the print statement inside the scope or remove the inner scope braces, ensuring that &lt;code&gt;result&lt;&#x2F;code&gt; remains valid.&lt;&#x2F;p&gt;
&lt;p&gt;So how do we fix it?&lt;&#x2F;p&gt;
&lt;p&gt;There&#x27;s a couple of ways we could fix this but let&#x27;s try the easiest (at least for me ðŸ˜‰).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lifetimes2-rs-solution&quot;&gt;Lifetimes2.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;So...is there any reason that we need to use the print statement outside of inner bracket? I don&#x27;t think so, there&#x27;s nothing preventing us from moving the last line and making this code compile, it gives us the same result and we have no issues with our variables being dropped after the scope.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn longest&amp;lt;&amp;#x27;a&amp;gt;(x: &amp;amp;&amp;#x27;a str, y: &amp;amp;&amp;#x27;a str) -&amp;gt; &amp;amp;&amp;#x27;a str {
    if x.len() &amp;gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from(&amp;quot;long string is long&amp;quot;);
    let result;
    {
        let string2 = String::from(&amp;quot;xyz&amp;quot;);
        result = longest(string1.as_str(), string2.as_str());
        println!(&amp;quot;The longest string is &amp;#x27;{}&amp;#x27;&amp;quot;, result);  &amp;#x2F;&amp;#x2F; add the print statment here
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;another easy solution is to just remove the inner scope braces and in this case we can also perform a little bit of clean-up so we don&#x27;t have &lt;code&gt;result&lt;&#x2F;code&gt; declared twice for no reason&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn longest&amp;lt;&amp;#x27;a&amp;gt;(x: &amp;amp;&amp;#x27;a str, y: &amp;amp;&amp;#x27;a str) -&amp;gt; &amp;amp;&amp;#x27;a str {
    if x.len() &amp;gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from(&amp;quot;hi&amp;quot;);
    let string2 = String::from(&amp;quot;xyz&amp;quot;);
    let result = longest(string1.as_str(), string2.as_str());
    println!(&amp;quot;The longest string is &amp;#x27;{}&amp;#x27;&amp;quot;, result);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I&#x27;m sure there&#x27;s more ways we could solve this but you get the idea right?  Let&#x27;s move on to the next exercise.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s the printout of our modified code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰

Output:
====================
The longest string is &amp;#x27;xyz&amp;#x27;

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;lifetimes3-rs&quot;&gt;Lifetimes3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; lifetimes3.rs
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Lifetimes are also needed when structs hold references.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Execute `rustlings hint lifetimes3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

struct Book {
    author: &amp;amp;str,
    title: &amp;amp;str,
}

fn main() {
    let name = String::from(&amp;quot;Jill Smith&amp;quot;);
    let title = String::from(&amp;quot;Fish Flying&amp;quot;);
    let book = Book { author: &amp;amp;name, title: &amp;amp;title };

    println!(&amp;quot;{} by {}&amp;quot;, book.title, book.author);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So we are being told that structs can also references in the instructions and we see in our errors that is telling us how to fix them.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lifetimes3-rs-errors&quot;&gt;Lifetimes3.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;lifetimes&amp;#x2F;lifetimes3.rs failed! Please try again. Here is the output:
error[E0106]: missing lifetime specifier
  --&amp;gt; exercises&amp;#x2F;lifetimes&amp;#x2F;lifetimes3.rs:10:13
   |
10 |     author: &amp;amp;str,
   |             ^ expected named lifetime parameter
   |
help: consider introducing a named lifetime parameter
   |
9  ~ struct Book&amp;lt;&amp;#x27;a&amp;gt; {
10 ~     author: &amp;amp;&amp;#x27;a str,
   |

error[E0106]: missing lifetime specifier
  --&amp;gt; exercises&amp;#x2F;lifetimes&amp;#x2F;lifetimes3.rs:11:12
   |
11 |     title: &amp;amp;str,
   |            ^ expected named lifetime parameter
   |
help: consider introducing a named lifetime parameter
   |
9  ~ struct Book&amp;lt;&amp;#x27;a&amp;gt; {
10 |     author: &amp;amp;str,
11 ~     title: &amp;amp;&amp;#x27;a str,
   |
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Looks easy enough let&#x27;s try and implement it...&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lifetimes3-rs-solution&quot;&gt;Lifetimes3.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;Lifetimes are also essential when structs hold references. In this example, we define a &lt;code&gt;Book&lt;&#x2F;code&gt; struct with lifetime annotations for the &lt;code&gt;author&lt;&#x2F;code&gt; and &lt;code&gt;title&lt;&#x2F;code&gt; fields to ensure that they reference valid data. By introducing the lifetime parameter &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;, we make sure that the references inside the struct remain valid for as long as the struct itself.&lt;&#x2F;p&gt;
&lt;p&gt;So, let&#x27;s implement the lifetime notation just as the compiler suggests and let&#x27;s see what happens....&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct Book&amp;lt;&amp;#x27;a&amp;gt; {
    author: &amp;amp;&amp;#x27;a str,
    title: &amp;amp;&amp;#x27;a str,
}

fn main() {
    let name = String::from(&amp;quot;Jill Smith&amp;quot;);
    let title = String::from(&amp;quot;Fish Flying&amp;quot;);
    let book = Book { author: &amp;amp;name, title: &amp;amp;title };

    println!(&amp;quot;{} by {}&amp;quot;, book.title, book.author);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Easy enough we are compiling!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰

Output:
====================
Fish Flying by Jill Smith

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In conclusion, lifetimes are a critical part of Rust&#x27;s ownership system that helps ensure the safety and validity of references. By understanding how to use lifetime annotations in function signatures and structs, you can write code that is both safe and efficient. Remember that lifetimes don&#x27;t change the actual lifetimes of values but serve as constraints for the borrow checker to enforce.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>19 Rustlings Tests</title>
          <pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/19-rustlings-tests/</link>
          <guid>https://desmodrone.github.io/posts/19-rustlings-tests/</guid>
          <description xml:base="https://desmodrone.github.io/posts/19-rustlings-tests/">&lt;p&gt;We&#x27;re going out of order from the book to cover tests -- many of the following exercises will ask you to make tests pass!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch11-01-writing-tests.html&quot;&gt;Writing Tests&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;tests1-rs&quot;&gt;Tests1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; tests1.rs  
&amp;#x2F;&amp;#x2F; Tests are important to ensure that your code does what you think it should do.  
&amp;#x2F;&amp;#x2F; Tests can be run on this file with the following command:  
&amp;#x2F;&amp;#x2F; rustlings run tests1  
  
&amp;#x2F;&amp;#x2F; This test has a problem with it -- make the test compile! Make the test  
&amp;#x2F;&amp;#x2F; pass! Make the test fail!  
&amp;#x2F;&amp;#x2F; Execute `rustlings hint tests1` or use the `hint` watch subcommand for a hint.  
  
&amp;#x2F;&amp;#x2F; I AM NOT DONE  
  
#[cfg(test)]  
mod tests {  
    #[test]  
    fn you_can_assert() {  
        assert!();  
    }  
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So now we&#x27;re looking at tests, an important part of the development process in any language is being able to test your code. In our first exercise we see instructions that tells us to make the test compile, make the test fail, essentially to play around with the code.
Let&#x27;s look at our errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;test1-rs-errors&quot;&gt;Test1.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;tests&amp;#x2F;tests1.rs failed! Please try again. Here&amp;#x27;s the output:
error: macro requires a boolean expression as an argument
  --&amp;gt; exercises&amp;#x2F;tests&amp;#x2F;tests1.rs:16:9
   |
16 |         assert!();
   |         ^^^^^^^^^ boolean expression required

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler gives us a big hint, we need to add a boolean expression. So let&#x27;s try that.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;test1-rs-solution&quot;&gt;Test1.rs Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;  
#[cfg(test)]  
mod tests {  
    #[test]  
    fn you_can_assert() {  
        assert!(false == false); &amp;#x2F;&amp;#x2F; let&amp;#x27;s add false == false
    }  
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;if we add this we actually compile and pass the tests:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âœ… Successfully tested exercises&amp;#x2F;tests&amp;#x2F;tests1.rs

ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But let&#x27;s see what happens when we change what&#x27;s inside of the &lt;code&gt;assert!&lt;&#x2F;code&gt; as we are told to do in our exercises.
if we change our &lt;code&gt;assert!&lt;&#x2F;code&gt; to this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;assert!(false == true);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;we fail and panic!&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;running 1 test
test tests::you_can_assert ... FAILED

successes:

successes:

failures:

---- tests::you_can_assert stdout ----
thread &amp;#x27;tests::you_can_assert&amp;#x27; panicked at &amp;#x27;assertion failed: false == true&amp;#x27;, exercises&amp;#x2F;tests&amp;#x2F;tests1.rs:16:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What about trying out different types&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;assert!(1 == 1); &amp;#x2F;&amp;#x2F; this passes âœ…

assert!(1); &amp;#x2F;&amp;#x2F; this fails âŒ

assert!(&amp;quot;hi&amp;quot; == &amp;quot;hi&amp;quot;); &amp;#x2F;&amp;#x2F; this passes âœ…
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright, we get the idea we need to have something to compare it, and have it be equal for it to pass, alright got it! Let&#x27;s move on.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;test2-rs&quot;&gt;Test2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; tests2.rs  
&amp;#x2F;&amp;#x2F; This test has a problem with it -- make the test compile! Make the test  
&amp;#x2F;&amp;#x2F; pass! Make the test fail!  
&amp;#x2F;&amp;#x2F; Execute `rustlings hint tests2` or use the `hint` watch subcommand for a hint.  
  
&amp;#x2F;&amp;#x2F; I AM NOT DONE  
  
#[cfg(test)]  
mod tests {  
    #[test]  
    fn you_can_assert_eq() {  
        assert_eq!();  
    }  
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are again similar, we need to make the code compile and pass tests.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;test2-rs-errors&quot;&gt;Test2.rs Errors&lt;&#x2F;h2&gt;
&lt;p&gt;Looking at the errors we can see&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;tests&amp;#x2F;tests2.rs failed! Please try again. Here&amp;#x27;s the output:
error: unexpected end of macro invocation
  --&amp;gt; exercises&amp;#x2F;tests&amp;#x2F;tests2.rs:12:9
   |
12 |         assert_eq!();
   |         ^^^^^^^^^^^^ missing tokens in macro arguments
   |
note: while trying to match meta-variable `$left:expr`
  --&amp;gt; &amp;#x2F;Users&amp;#x2F;desmo&amp;#x2F;.rustup&amp;#x2F;toolchains&amp;#x2F;stable-aarch64-apple-darwin&amp;#x2F;lib&amp;#x2F;rustlib&amp;#x2F;src&amp;#x2F;rust&amp;#x2F;library&amp;#x2F;core&amp;#x2F;src&amp;#x2F;macros&amp;#x2F;mod.rs:37:6
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again we get a clear statement saying we have missing tokens in the macro arguments. So let&#x27;s play around and see what we get.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;test2-rs-solution&quot;&gt;Test2.rs Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[cfg(test)]  
mod tests {  
    #[test]  
    fn you_can_assert_eq() {  
        assert_eq!(0, true);  
    }  
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This fails!  Let&#x27;s see what the compiler says&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;tests&amp;#x2F;tests2.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;tests&amp;#x2F;tests2.rs:12:9
   |
12 |         assert_eq!(0, true);
   |         ^^^^^^^^^^^^^^^^^^^ expected integer, found `bool`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Okay, so now let&#x27;s try&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;assert_eq!(0, 0);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This compiles&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âœ… Successfully tested exercises&amp;#x2F;tests&amp;#x2F;tests2.rs

ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s try different values&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;assert_eq!(&amp;quot;hi&amp;quot;, &amp;quot;hi&amp;quot;);  âœ…

assert_eq!(&amp;quot;0&amp;quot;, 0);  âŒ

assert_eq!(true, true); âœ…

assert_eq!(true, false); âŒ

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Similar to our last exercise, we can enter comma separated values and see what happens. We clearly. have to enter matching values or the tests fail. Great, moving on!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;test3-rs&quot;&gt;Test3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; tests3.rs  
&amp;#x2F;&amp;#x2F; This test isn&amp;#x27;t testing our function -- make it do that in such a way that  
&amp;#x2F;&amp;#x2F; the test passes. Then write a second test that tests whether we get the result  
&amp;#x2F;&amp;#x2F; we expect to get when we call `is_even(5)`.  
&amp;#x2F;&amp;#x2F; Execute `rustlings hint tests3` or use the `hint` watch subcommand for a hint.  
  
&amp;#x2F;&amp;#x2F; I AM NOT DONE  
  
pub fn is_even(num: i32) -&amp;gt; bool {  
    num % 2 == 0  
}  
  
#[cfg(test)]  
mod tests {  
    use super::*;  
  
    #[test]  
    fn is_true_when_even() {  
        assert!();  
    }  
  
    #[test]  
    fn is_false_when_odd() {  
        assert!();  
    }  
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now, we finally get a function to test, it looks like we have to make the code compile and pass tests. If we look at the function we can see that it takes in an &lt;code&gt;i32&lt;&#x2F;code&gt; and returns a &lt;code&gt;bool&lt;&#x2F;code&gt; meaning, either &lt;code&gt;true&lt;&#x2F;code&gt; or &lt;code&gt;false&lt;&#x2F;code&gt; so does that give us a hint as to what to do?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;test3-rs-errors&quot;&gt;Test3.rs Errors&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s take a look at the errors, again we see that we have an expression missing in our &lt;code&gt;assert!&lt;&#x2F;code&gt; macro, so let&#x27;s fix that.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;tests&amp;#x2F;tests3.rs failed! Please try again. Here&amp;#x27;s the output:
error: macro requires a boolean expression as an argument
  --&amp;gt; exercises&amp;#x2F;tests&amp;#x2F;tests3.rs:19:9
   |
19 |         assert!();
   |         ^^^^^^^^^ boolean expression required

error: macro requires a boolean expression as an argument
  --&amp;gt; exercises&amp;#x2F;tests&amp;#x2F;tests3.rs:24:9
   |
24 |         assert!();
   |         ^^^^^^^^^ boolean expression required

warning: unused import: `super::*`
  --&amp;gt; exercises&amp;#x2F;tests&amp;#x2F;tests3.rs:15:9
   |
15 |     use super::*;
   |         ^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;test3-rs-solution&quot;&gt;Test3.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;ve been playing with these tests for a couple of exercises and we can say that we&#x27;ve seen that we need to have matching values. So we know that we need to match a &lt;code&gt;bool&lt;&#x2F;code&gt; so let&#x27;s try that..&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;  
pub fn is_even(num: i32) -&amp;gt; bool {  
    num % 2 == 0  
}  
  
#[cfg(test)]  
mod tests {  
    use super::*;  
  
    #[test]  
    fn is_true_when_even() {  
        assert!(true == true);  
    }  
  
    #[test]  
    fn is_false_when_odd() {  
        assert!(false == false);  
    }  
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And there we have it! Our tests are passing and our code is compiling.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;running 2 tests
test tests::is_true_when_even ... ok

âœ… Successfully tested exercises&amp;#x2F;tests&amp;#x2F;tests3.rs

ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Congratulations, you&#x27;ve just taken a quick look into the world of testing in Rust! From understanding how to make a test compile to making it pass or fail intentionally. You&#x27;ve also explored how to handle different types and expressions within the &lt;code&gt;assert!&lt;&#x2F;code&gt; and &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; macros.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;key-takeaways&quot;&gt;Key Takeaways:&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Boolean Expressions&lt;&#x2F;strong&gt;: The &lt;code&gt;assert!&lt;&#x2F;code&gt; macro requires a boolean expression. If the expression evaluates to &lt;code&gt;true&lt;&#x2F;code&gt;, the test passes; otherwise, it fails and panics.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Matching Types&lt;&#x2F;strong&gt;: The &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; macro expects two values of the same type. If they are equal, the test passes; otherwise, it fails.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Function Testing&lt;&#x2F;strong&gt;: We also looked at how to test a custom function (&lt;code&gt;is_even&lt;&#x2F;code&gt;) using the &lt;code&gt;assert!&lt;&#x2F;code&gt; macro. This gave us a practical example of how testing integrates into real-world code.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Error Messages&lt;&#x2F;strong&gt;: Paying attention to compiler error messages can provide valuable hints for resolving issues in your tests.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Exploration&lt;&#x2F;strong&gt;: Don&#x27;t be afraid to experiment. Changing the values and types in your tests can offer additional insights into how Rust&#x27;s testing framework operates.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Testing is a critical part of software development that ensures your code behaves as expected. It&#x27;s a safety net that allows you to make changes to your code with confidence. As you continue your journey with Rust, you&#x27;ll find that the language&#x27;s robust testing framework is a powerful ally in writing reliable, robust software.&lt;&#x2F;p&gt;
&lt;p&gt;So, the next time you&#x27;re writing code in Rust, remember: a test today can prevent a bug tomorrow. Happy coding!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>18 Rustlings Quiz 3</title>
          <pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/18-rustlings-quiz3/</link>
          <guid>https://desmodrone.github.io/posts/18-rustlings-quiz3/</guid>
          <description xml:base="https://desmodrone.github.io/posts/18-rustlings-quiz3/">&lt;h2 id=&quot;quiz3-rs&quot;&gt;Quiz3.rs&lt;&#x2F;h2&gt;
&lt;p&gt;It&#x27;s time to revisit what we&#x27;ve learned so far. In this case, we&#x27;re focusing on generics and traits in Rust. Let&#x27;s dive into the exercise.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; quiz3.rs
&amp;#x2F;&amp;#x2F; This quiz tests:
&amp;#x2F;&amp;#x2F; - Generics
&amp;#x2F;&amp;#x2F; - Traits
&amp;#x2F;&amp;#x2F; An imaginary magical school has a new report card generation system written in Rust!
&amp;#x2F;&amp;#x2F; Currently the system only supports creating report cards where the student&amp;#x27;s grade
&amp;#x2F;&amp;#x2F; is represented numerically (e.g. 1.0 -&amp;gt; 5.5).
&amp;#x2F;&amp;#x2F; However, the school also issues alphabetical grades (A+ -&amp;gt; F-) and needs
&amp;#x2F;&amp;#x2F; to be able to print both types of report card!

&amp;#x2F;&amp;#x2F; Make the necessary code changes in the struct ReportCard and the impl block
&amp;#x2F;&amp;#x2F; to support alphabetical report cards. Change the Grade in the second test to &amp;quot;A+&amp;quot;
&amp;#x2F;&amp;#x2F; to show that your changes allow alphabetical grades.

&amp;#x2F;&amp;#x2F; Execute `rustlings hint quiz3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub struct ReportCard {
    pub grade: f32,
    pub student_name: String,
    pub student_age: u8,
}

impl ReportCard {
    pub fn print(&amp;amp;self) -&amp;gt; String {
        format!(&amp;quot;{} ({}) - achieved a grade of {}&amp;quot;,
            &amp;amp;self.student_name, &amp;amp;self.student_age, &amp;amp;self.grade)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generate_numeric_report_card() {
        let report_card = ReportCard {
            grade: 2.1,
            student_name: &amp;quot;Tom Wriggle&amp;quot;.to_string(),
            student_age: 12,
        };
        assert_eq!(
            report_card.print(),
            &amp;quot;Tom Wriggle (12) - achieved a grade of 2.1&amp;quot;
        );
    }

    #[test]
    fn generate_alphabetic_report_card() {
        &amp;#x2F;&amp;#x2F; TODO: Make sure to change the grade here after you finish the exercise.
        let report_card = ReportCard {
            grade: 2.1,
            student_name: &amp;quot;Gary Plotter&amp;quot;.to_string(),
            student_age: 11,
        };
        assert_eq!(
            report_card.print(),
            &amp;quot;Gary Plotter (11) - achieved a grade of A+&amp;quot;
        );
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our task here is to allow both numeric and alphabetical grades, currently we can only print numeric grades correctly. So we how can we fix this. Generics of course!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;quiz3-rs-errors&quot;&gt;Quiz3.rs errors&lt;&#x2F;h2&gt;
&lt;p&gt;When we run the tests, we find that one test passes while the other fails. Here&#x27;s the output:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Testing of exercises&amp;#x2F;quiz3.rs failed! Please try again. Here&amp;#x27;s the output:

running 2 tests
test tests::generate_numeric_report_card ... ok
test tests::generate_alphabetic_report_card ... FAILED

successes:

successes:
    tests::generate_numeric_report_card

failures:

---- tests::generate_alphabetic_report_card stdout ----
thread &amp;#x27;tests::generate_alphabetic_report_card&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `&amp;quot;Gary Plotter (11) - achieved a grade of 2.1&amp;quot;`,
 right: `&amp;quot;Gary Plotter (11) - achieved a grade of A+&amp;quot;`&amp;#x27;, exercises&amp;#x2F;quiz3.rs:57:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::generate_alphabetic_report_card

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;quiz3-rs-solution&quot;&gt;Quiz3.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;The issue here is that our &lt;code&gt;ReportCard&lt;&#x2F;code&gt; struct is not designed to handle both numerical and alphabetical grades. So let&#x27;s solve this problem by implementing generics.&lt;&#x2F;p&gt;
&lt;p&gt;Our original &lt;code&gt;ReportCard&lt;&#x2F;code&gt; struct looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub struct ReportCard {
    pub grade: f32,
    pub student_name: String,
    pub student_age: u8,
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;updating-the-struct-to-use-generics&quot;&gt;Updating the Struct to use Generics&lt;&#x2F;h3&gt;
&lt;p&gt;Since the &lt;code&gt;student_name&lt;&#x2F;code&gt; will always be a &lt;code&gt;String&lt;&#x2F;code&gt; and the &lt;code&gt;student_age&lt;&#x2F;code&gt; will always be a &lt;code&gt;u8&lt;&#x2F;code&gt;, we only need to make the &lt;code&gt;grade&lt;&#x2F;code&gt; field generic:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub struct ReportCard&amp;lt;T&amp;gt; {
	pub grade: T,
	pub student_name: String,
	pub student_age: u8,
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This should do the trick for the struct but now we have to take a look at our &lt;code&gt;impl&lt;&#x2F;code&gt; block&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl ReportCard {
    pub fn print(&amp;amp;self) -&amp;gt; String {
        format!(&amp;quot;{} ({}) - achieved a grade of {}&amp;quot;,
            &amp;amp;self.student_name, &amp;amp;self.student_age, &amp;amp;self.grade)
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;updating-the-implementation-block&quot;&gt;Updating the Implementation Block&lt;&#x2F;h3&gt;
&lt;p&gt;Next, we update the &lt;code&gt;impl&lt;&#x2F;code&gt; block to accommodate the generic type &lt;code&gt;T&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl&amp;lt;T&amp;gt; ReportCard&amp;lt;T&amp;gt; {
 &amp;#x2F;&amp;#x2F; rest of code
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This let&#x27;s the compiler know that we are using generics in this block of code. Alright let&#x27;s save the changes and see what happens!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;uh-oh-problems&quot;&gt;Uh oh. Problems&lt;&#x2F;h2&gt;
&lt;p&gt;So it seems like we are not quite done yet. Since we are now using generics in our &lt;code&gt;impl&lt;&#x2F;code&gt; block the compiler is telling us that we cannot format the &lt;code&gt;grade&lt;&#x2F;code&gt; portion of this code on line 29 at : &lt;code&gt;&amp;amp;self.grade&lt;&#x2F;code&gt;, but luckily it has a suggestion. The compiler suggests restricting &lt;code&gt;T&lt;&#x2F;code&gt; to types that implement &lt;code&gt;Display&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;quiz3.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0277]: `T` doesn&amp;#x27;t implement `std::fmt::Display`
  --&amp;gt; exercises&amp;#x2F;quiz3.rs:29:52
   |
29 |             &amp;amp;self.student_name, &amp;amp;self.student_age, &amp;amp;self.grade
   |                                                    ^^^^^^^^^^^ `T` cannot be formatted with the default formatter
   |
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
   = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider restricting type parameter `T`
   |
25 | impl&amp;lt;T: std::fmt::Display&amp;gt; ReportCard&amp;lt;T&amp;gt; {
   |       +++++++++++++++++++

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Okay so let&#x27;s fix that our &lt;code&gt;impl&lt;&#x2F;code&gt; block now looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl&amp;lt;T&amp;gt; ReportCard&amp;lt;T&amp;gt; {
    pub fn print(&amp;amp;self) -&amp;gt; String {
        format!(
            &amp;quot;{} ({}) - achieved a grade of {}&amp;quot;,
            &amp;amp;self.student_name, &amp;amp;self.student_age, &amp;amp;self.grade
        )
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we save now we should be..doh. Our test fails.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;running 2 tests
test tests::generate_numeric_report_card ... ok
test tests::generate_alphabetic_report_card ... FAILED

successes:

successes:
    tests::generate_numeric_report_card

failures:

---- tests::generate_alphabetic_report_card stdout ----
thread &amp;#x27;tests::generate_alphabetic_report_card&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `&amp;quot;Gary Plotter (11) - achieved a grade of 2.1&amp;quot;`,
 right: `&amp;quot;Gary Plotter (11) - achieved a grade of A+&amp;quot;`&amp;#x27;, exercises&amp;#x2F;quiz3.rs:59:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::generate_alphabetic_report_card
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;resolving-test-failures&quot;&gt;Resolving Test Failures&lt;&#x2F;h3&gt;
&lt;p&gt;After making these changes, the test for alphabetical grades still fails. The issue is that we forgot to update the grade in the &lt;code&gt;generate_alphabetic_report_card()&lt;&#x2F;code&gt; test function from &lt;code&gt;2.1&lt;&#x2F;code&gt; to &lt;code&gt;A+&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;final-working-code&quot;&gt;Final Working Code&lt;&#x2F;h2&gt;
&lt;p&gt;Here&#x27;s the complete, working code for reference:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub struct ReportCard&amp;lt;T&amp;gt; {
    pub grade: T,
    pub student_name: String,
    pub student_age: u8,
}

impl&amp;lt;T: std::fmt::Display&amp;gt; ReportCard&amp;lt;T&amp;gt; {
    pub fn print(&amp;amp;self) -&amp;gt; String {
        format!(
            &amp;quot;{} ({}) - achieved a grade of {}&amp;quot;,
            &amp;amp;self.student_name, &amp;amp;self.student_age, &amp;amp;self.grade
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generate_numeric_report_card() {
        let report_card = ReportCard {
            grade: 2.1,
            student_name: &amp;quot;Tom Wriggle&amp;quot;.to_string(),
            student_age: 12,
        };
        assert_eq!(
            report_card.print(),
            &amp;quot;Tom Wriggle (12) - achieved a grade of 2.1&amp;quot;
        );
    }

    #[test]
    fn generate_alphabetic_report_card() {

        let report_card = ReportCard {
            grade: &amp;quot;A+&amp;quot;,
            student_name: &amp;quot;Gary Plotter&amp;quot;.to_string(),
            student_age: 11,
        };
        assert_eq!(
            report_card.print(),
            &amp;quot;Gary Plotter (11) - achieved a grade of A+&amp;quot;
        );
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;notes&quot;&gt;Notes&lt;&#x2F;h2&gt;
&lt;p&gt;I used the code below, in Rust playgrounds essentially letting me print the report card which then allowed me to have errors when trying to compile and better figure out what I needed to be doing by seeing the printout instead of just having the tests as the compiler gave me the error that &lt;code&gt;T&amp;lt;: std::fmt::Debug&amp;gt;&lt;&#x2F;code&gt; was missing from the &lt;code&gt;impl&lt;&#x2F;code&gt; signature.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note this is different that the &lt;code&gt;T&amp;lt;: std::fmt::Display&amp;gt;&lt;&#x2F;code&gt; used in solving the exercise.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[derive(Debug)]
pub struct ReportCard&amp;lt;T&amp;gt; {
    pub grade: T,
    pub student_name: String,
    pub student_age: u8,
}

impl&amp;lt;T: std::fmt::Display&amp;gt; ReportCard&amp;lt;T&amp;gt; {
    pub fn print(&amp;amp;self) -&amp;gt; String {
        format!(&amp;quot;{} ({}) - achieved a grade of {:?}&amp;quot;,
            &amp;amp;self.student_name, &amp;amp;self.student_age, &amp;amp;self.grade)
    }
}

fn main() {
    fn generate_numeric_report_card() {
        let report_card = ReportCard {
            grade: 2.1,
            student_name: &amp;quot;Tom Wriggle&amp;quot;.to_string(),
            student_age: 12,
        };
        println!(&amp;quot;{:?}&amp;quot;, report_card);
    }
    generate_numeric_report_card();

    fn generate_alphabetic_report_card() {
        let report_card = ReportCard {
            grade: &amp;quot;A+&amp;quot;,
            student_name: &amp;quot;Gary Plotter&amp;quot;.to_string(),
            student_age: 12,
        };
        println!(&amp;quot;{:?}&amp;quot;, report_card);
    }
    generate_alphabetic_report_card();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this exercise, we learned how to use generics to make our &lt;code&gt;ReportCard&lt;&#x2F;code&gt; struct more flexible, allowing it to handle both numerical and alphabetical grades. We also saw how to constrain our generic types to those that implement specific traits, in this case, the &lt;code&gt;Display&lt;&#x2F;code&gt; trait. This ensures that we can format the grade regardless of its type.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>17 Rustlings Traits</title>
          <pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/17-rustlings-traits/</link>
          <guid>https://desmodrone.github.io/posts/17-rustlings-traits/</guid>
          <description xml:base="https://desmodrone.github.io/posts/17-rustlings-traits/">&lt;h1 id=&quot;traits&quot;&gt;Traits&lt;&#x2F;h1&gt;
&lt;h3 id=&quot;from-the-readme&quot;&gt;From the README&lt;&#x2F;h3&gt;
&lt;p&gt;A trait is a collection of methods.&lt;&#x2F;p&gt;
&lt;p&gt;Data types can implement traits. To do so, the methods making up the trait are defined for the data type. For example, the &lt;code&gt;String&lt;&#x2F;code&gt; data type implements the &lt;code&gt;From&amp;lt;&amp;amp;str&amp;gt;&lt;&#x2F;code&gt; trait. Will allow a user to write the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;String::from(&amp;quot;hello&amp;quot;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this way, traits are somewhat similar to Java interfaces and C++ abstract classes.&lt;&#x2F;p&gt;
&lt;p&gt;Some additional common Rust traits include:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Clone&lt;&#x2F;code&gt; (the &lt;code&gt;clone&lt;&#x2F;code&gt; method)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Display&lt;&#x2F;code&gt; (which allows formatted display via &lt;code&gt;{}&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Debug&lt;&#x2F;code&gt; (which allows formatted display via &lt;code&gt;{:?}&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Because traits indicate shared behavior between data types, they are useful when writing generics.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-02-traits.html&quot;&gt;Traits&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;traits1-rs&quot;&gt;Traits1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; traits1.rs
&amp;#x2F;&amp;#x2F; Time to implement some traits!
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Your task is to implement the trait
&amp;#x2F;&amp;#x2F; `AppendBar` for the type `String`.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; The trait AppendBar has only one function,
&amp;#x2F;&amp;#x2F; which appends &amp;quot;Bar&amp;quot; to any object
&amp;#x2F;&amp;#x2F; implementing this trait.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

trait AppendBar {
    fn append_bar(self) -&amp;gt; Self;
}

impl AppendBar for String {
    &amp;#x2F;&amp;#x2F; TODO: Implement `AppendBar` for type `String`.
}

fn main() {
    let s = String::from(&amp;quot;Foo&amp;quot;);
    let s = s.append_bar();
    println!(&amp;quot;s: {}&amp;quot;, s);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_foo_bar() {
        assert_eq!(String::from(&amp;quot;Foo&amp;quot;).append_bar(), String::from(&amp;quot;FooBar&amp;quot;));
    }

    #[test]
    fn is_bar_bar() {
        assert_eq!(
            String::from(&amp;quot;&amp;quot;).append_bar().append_bar(),
            String::from(&amp;quot;BarBar&amp;quot;)
        );
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this first Trait exercise we are tasked with implementing the trait &lt;code&gt;AppendBar&lt;&#x2F;code&gt; for the type &lt;code&gt;String&lt;&#x2F;code&gt;. We get the additional details that the &lt;code&gt;AppendBar&lt;&#x2F;code&gt; has only one function and it appends &amp;quot;Bar&amp;quot; to any object that is implementing this trait. Now, let&#x27;s look at the errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits1-rs-errors&quot;&gt;Traits1.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;traits&amp;#x2F;traits1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0046]: not all trait items implemented, missing: `append_bar`
  --&amp;gt; exercises&amp;#x2F;traits&amp;#x2F;traits1.rs:18:1
   |
15 |     fn append_bar(self) -&amp;gt; Self;
   |     ---------------------------- `append_bar` from trait
...
18 | impl AppendBar for String {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^ missing `append_bar` in implementation

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Nothing special here, so let&#x27;s move on to solving our problem.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits1-rs-solution&quot;&gt;Traits1.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;Alright so again, our job is to finish implementing the &lt;code&gt;AppendBar&lt;&#x2F;code&gt; trait and I can think of a couple of different ways of doing this so let&#x27;s try the easiest. First we start by creating the function inside of our &lt;code&gt;impl&lt;&#x2F;code&gt; block.
We know we have to define a function called &lt;code&gt;append_bar&lt;&#x2F;code&gt; and we also know that it should return a &lt;code&gt;String&lt;&#x2F;code&gt;, and the other thing we know is that we need to pass in &lt;code&gt;self&lt;&#x2F;code&gt; as a parameter.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl AppendBar for String {
    fn append_bar(self) -&amp;gt; String{

    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is our basic structure but now we have to make it do something inside of the body...however, if we save the code at this point, we get a big hint from the compiler.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;traits&amp;#x2F;traits1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;traits&amp;#x2F;traits1.rs:20:28
   |
20 |     fn append_bar(self) -&amp;gt; String {}
   |        ----------          ^^^^^^ expected `String`, found `()`
   |        |
   |        implicitly returns `()` as its body has no tail or `return` expression
   |
help: consider returning the local binding `self`
   |
20 |     fn append_bar(self) -&amp;gt; String { self }
   |                                     ++++

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This error shows us that we are not returning anything, which is clear to us because we are not doing anything inside of our function body, however it does give us the a big hint &lt;code&gt;help: consider returning the local binding&lt;&#x2F;code&gt; &lt;code&gt;self&lt;&#x2F;code&gt;, so let&#x27;s try that!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl AppendBar for String {
    &amp;#x2F;&amp;#x2F; TODO: Implement `AppendBar` for type `String`.
    fn append_bar(self) -&amp;gt; String {
        self &amp;#x2F;&amp;#x2F; returning `self` here note no `;`
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By returning &lt;code&gt;self&lt;&#x2F;code&gt; we are now compiling, but we still have a problem, we are not passing our tests:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Testing of exercises&amp;#x2F;traits&amp;#x2F;traits1.rs failed! Please try again. Here&amp;#x27;s the output:

running 2 tests
test tests::is_foo_bar ... FAILED
test tests::is_bar_bar ... FAILED

successes:

successes:

failures:

---- tests::is_foo_bar stdout ----
thread &amp;#x27;tests::is_foo_bar&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `&amp;quot;Foo&amp;quot;`,
 right: `&amp;quot;FooBar&amp;quot;`&amp;#x27;, exercises&amp;#x2F;traits&amp;#x2F;traits1.rs:39:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

---- tests::is_bar_bar stdout ----
thread &amp;#x27;tests::is_bar_bar&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `&amp;quot;&amp;quot;`,
 right: `&amp;quot;BarBar&amp;quot;`&amp;#x27;, exercises&amp;#x2F;traits&amp;#x2F;traits1.rs:44:9


failures:
    tests::is_bar_bar
    tests::is_foo_bar

test result: FAILED. 0 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can clearly see the issue is that our code is not adding or appending &lt;code&gt;Bar&lt;&#x2F;code&gt; to our String&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;thread &amp;#x27;tests::is_foo_bar&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `&amp;quot;Foo&amp;quot;`,
 right: `&amp;quot;FooBar&amp;quot;`&amp;#x27;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see that &lt;code&gt;left !== right&lt;&#x2F;code&gt; so what&#x27;s the easiest way to fix that?&lt;&#x2F;p&gt;
&lt;p&gt;Can we just add &lt;code&gt;Bar&lt;&#x2F;code&gt;? Let&#x27;s try...&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl AppendBar for String {
    &amp;#x2F;&amp;#x2F; TODO: Implement `AppendBar` for type `String`.
    fn append_bar(self) -&amp;gt; String {
        self + &amp;quot;Bar&amp;quot;
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Yep and with that we are compiling and passing our tests.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âœ… Successfully tested exercises&amp;#x2F;traits&amp;#x2F;traits1.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I did mentioned that there might be 2 different ways to do this, I was thinking about using the &lt;code&gt;format!&lt;&#x2F;code&gt; macro, let&#x27;s see if that works. So instead of simply returning &lt;code&gt;self + &amp;quot;Bar&amp;quot;&lt;&#x2F;code&gt; , we can use &lt;code&gt;format!&lt;&#x2F;code&gt; to layout the contents of the &lt;code&gt;String&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl AppendBar for String {
    &amp;#x2F;&amp;#x2F; TODO: Implement `AppendBar` for type `String`.
    fn append_bar(self) -&amp;gt; String {
        format!(&amp;quot;{}{}&amp;quot;, self, &amp;quot;Bar&amp;quot;)
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This also works! So there you have it, two different ways to solve this problem. It&#x27;s really a matter of preference and although they&#x27;re both valid they have different pro&#x27;s and con&#x27;s:&lt;&#x2F;p&gt;
&lt;h3 id=&quot;using-format&quot;&gt;Using &lt;code&gt;format!&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Flexibility&lt;&#x2F;strong&gt;: The &lt;code&gt;format!&lt;&#x2F;code&gt; macro is more flexible and can handle complex string manipulations, including variable interpolation and formatting options.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Readability&lt;&#x2F;strong&gt;: For more complex operations, &lt;code&gt;format!&lt;&#x2F;code&gt; can be easier to read and understand.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;using&quot;&gt;Using &lt;code&gt;+&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Simplicity&lt;&#x2F;strong&gt;: The &lt;code&gt;+&lt;&#x2F;code&gt; operator is simpler and more straightforward for basic string concatenation tasks.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Performance&lt;&#x2F;strong&gt;: For very simple concatenations, using &lt;code&gt;+&lt;&#x2F;code&gt; can be slightly more efficient because it doesn&#x27;t involve parsing a format string.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;final-code&quot;&gt;Final Code&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;trait AppendBar {
    fn append_bar(self) -&amp;gt; Self;
}

impl AppendBar for String {
    &amp;#x2F;&amp;#x2F; TODO: Implement `AppendBar` for type `String`.
    fn append_bar(self) -&amp;gt; String {
        format!(&amp;quot;{}{}&amp;quot;, self, &amp;quot;Bar&amp;quot;)
    }
}

fn main() {
    let s = String::from(&amp;quot;Foo&amp;quot;);
    let s = s.append_bar();
    println!(&amp;quot;s: {}&amp;quot;, s);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;traits2-rs&quot;&gt;Traits2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; traits2.rs
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Your task is to implement the trait
&amp;#x2F;&amp;#x2F; `AppendBar` for a vector of strings.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; To implement this trait, consider for
&amp;#x2F;&amp;#x2F; a moment what it means to &amp;#x27;append &amp;quot;Bar&amp;quot;&amp;#x27;
&amp;#x2F;&amp;#x2F; to a vector of strings.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; No boiler plate code this time,
&amp;#x2F;&amp;#x2F; you can do this!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

trait AppendBar {
    fn append_bar(self) -&amp;gt; Self;
}

&amp;#x2F;&amp;#x2F; TODO: Implement trait `AppendBar` for a vector of strings.

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_vec_pop_eq_bar() {
        let mut foo = vec![String::from(&amp;quot;Foo&amp;quot;)].append_bar();
        assert_eq!(foo.pop().unwrap(), String::from(&amp;quot;Bar&amp;quot;));
        assert_eq!(foo.pop().unwrap(), String::from(&amp;quot;Foo&amp;quot;));
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are to create our &lt;code&gt;impl&lt;&#x2F;code&gt; block for the &lt;code&gt;AppendBar&lt;&#x2F;code&gt; function. We get zero boilerplate code and we have to consider what it means to append &lt;code&gt;&amp;quot;Bar&amp;quot;&lt;&#x2F;code&gt;. By looking at code we see that the trait has a method &lt;code&gt;append_bar&lt;&#x2F;code&gt; that should modify the vector by appending the string &amp;quot;Bar&amp;quot; to it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits2-rs-errors&quot;&gt;Traits2.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;traits&amp;#x2F;traits2.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0599]: no method named `append_bar` found for struct `Vec&amp;lt;String&amp;gt;` in the current scope
  --&amp;gt; exercises&amp;#x2F;traits&amp;#x2F;traits2.rs:28:49
   |
28 |         let mut foo = vec![String::from(&amp;quot;Foo&amp;quot;)].append_bar();
   |                                                 ^^^^^^^^^^ help: there is a method with a similar name: `append`
   |
   = help: items from traits can only be used if the trait is implemented and in scope
note: `AppendBar` defines an item `append_bar`, perhaps you need to implement it
  --&amp;gt; exercises&amp;#x2F;traits&amp;#x2F;traits2.rs:16:1
   |
16 | trait AppendBar {
   | ^^^^^^^^^^^^^^^

warning: unused import: `super`
  --&amp;gt; exercises&amp;#x2F;traits&amp;#x2F;traits2.rs:24:9
   |
24 |     use super::*;
   |         ^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

error: aborting due to previous error; 1 warning emitted
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our errors show what we should expect and tell us that items from traits can only be used if the trait is implemented in scope. Alright although it&#x27;s nothing specifically new, it&#x27;s nice how the compiler also gives you the hint that &lt;code&gt;perhaps you need to implement it&lt;&#x2F;code&gt;. Alright moving on.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits2-rs-solution&quot;&gt;Traits2.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;So let&#x27;s start implementing, we had something similar in the previous exercise, right? So it shouldn&#x27;t be too difficult.
What we need to do is tell Rust how a &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;&#x2F;code&gt; should behave when the &lt;code&gt;append_bar&lt;&#x2F;code&gt; method is called. We do this by implementing the &lt;code&gt;AppendBar&lt;&#x2F;code&gt; trait.
If we remember our instructions we are reminded to think of what it means to append &lt;code&gt;&amp;quot;Bar&amp;quot;&lt;&#x2F;code&gt; to a vector of &lt;code&gt;String&lt;&#x2F;code&gt; we doesn&#x27;t that mean that we need to &lt;code&gt;.push()&lt;&#x2F;code&gt; on to the Vector? Let&#x27;s try&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;trait AppendBar {
    fn append_bar(self) -&amp;gt; Self;
}

&amp;#x2F;&amp;#x2F; TODO: Implement trait `AppendBar` for a vector of strings.

impl AppendBar for Vec&amp;lt;String&amp;gt; {
	fn append_bar(mut self) -&amp;gt; Vec&amp;lt;Strings&amp;gt; {
		self.push(String::from(&amp;quot;Bar&amp;quot;));
		self
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here&#x27;s what&#x27;s happening in this block:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;impl AppendBar for Vec&amp;lt;String&amp;gt;&lt;&#x2F;code&gt;: This line says we&#x27;re implementing the &lt;code&gt;AppendBar&lt;&#x2F;code&gt; trait specifically for &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;fn append_bar(mut self) -&amp;gt; Vec&amp;lt;String&amp;gt;&lt;&#x2F;code&gt;: This is the method we&#x27;re implementing. It takes a mutable version of &lt;code&gt;self&lt;&#x2F;code&gt; (the &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;&#x2F;code&gt; you&#x27;re calling the method on) and returns a new &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;self.push(String::from(&amp;quot;Bar&amp;quot;))&lt;&#x2F;code&gt;: This line appends the string &amp;quot;Bar&amp;quot; to the vector.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;self&lt;&#x2F;code&gt;: Finally, you return the modified vector.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Let&#x27;s save and see if that does the trick.&lt;&#x2F;p&gt;
&lt;p&gt;Yes, we&#x27;ve done it!&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âœ… Successfully tested exercises&amp;#x2F;traits&amp;#x2F;traits2.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;traits3-rs&quot;&gt;Traits3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; traits3.rs
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Your task is to implement the Licensed trait for
&amp;#x2F;&amp;#x2F; both structures and have them return the same
&amp;#x2F;&amp;#x2F; information without writing the same function twice.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Consider what you can add to the Licensed trait.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint traits3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub trait Licensed {
    fn licensing_info(&amp;amp;self) -&amp;gt; String;
}

struct SomeSoftware {
    version_number: i32,
}

struct OtherSoftware {
    version_number: String,
}

impl Licensed for SomeSoftware {} &amp;#x2F;&amp;#x2F; Don&amp;#x27;t edit this line
impl Licensed for OtherSoftware {} &amp;#x2F;&amp;#x2F; Don&amp;#x27;t edit this line

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_licensing_info_the_same() {
        let licensing_info = String::from(&amp;quot;Some information&amp;quot;);
        let some_software = SomeSoftware { version_number: 1 };
        let other_software = OtherSoftware {
            version_number: &amp;quot;v2.0.0&amp;quot;.to_string(),
        };
        assert_eq!(some_software.licensing_info(), licensing_info);
        assert_eq!(other_software.licensing_info(), licensing_info);
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have two structs, &lt;code&gt;SomeSoftware&lt;&#x2F;code&gt; and &lt;code&gt;OtherSoftware&lt;&#x2F;code&gt;, and a trait &lt;code&gt;Licensed&lt;&#x2F;code&gt; with a method &lt;code&gt;licensing_info&lt;&#x2F;code&gt;. The task is to implement the &lt;code&gt;Licensed&lt;&#x2F;code&gt; trait for both structs so that they return the same licensing information. The challenge is to do this without writing the same function twice.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits3-rs-errors&quot;&gt;Traits3.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;traits&amp;#x2F;traits3.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0046]: not all trait items implemented, missing: `licensing_info`
  --&amp;gt; exercises&amp;#x2F;traits&amp;#x2F;traits3.rs:24:1
   |
13 |     fn licensing_info(&amp;amp;self) -&amp;gt; String;
   |     ----------------------------------- `licensing_info` from trait
...
24 | impl Licensed for SomeSoftware {} &amp;#x2F;&amp;#x2F; Don&amp;#x27;t edit this line
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `licensing_info` in implementation

error[E0046]: not all trait items implemented, missing: `licensing_info`
  --&amp;gt; exercises&amp;#x2F;traits&amp;#x2F;traits3.rs:25:1
   |
13 |     fn licensing_info(&amp;amp;self) -&amp;gt; String;
   |     ----------------------------------- `licensing_info` from trait
...
25 | impl Licensed for OtherSoftware {} &amp;#x2F;&amp;#x2F; Don&amp;#x27;t edit this line
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `licensing_info` in implementation

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Errors tell us we have to implement our traits, let&#x27;s see how we can do this.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits3-rs-solution&quot;&gt;Traits3.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;One way to achieve this is to provide a default implementation for the &lt;code&gt;licensing_info&lt;&#x2F;code&gt; method within the &lt;code&gt;Licensed&lt;&#x2F;code&gt; trait itself. This way, both structs will inherit this default behavior, and we won&#x27;t have to implement the method twice.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub trait Licensed {
	&amp;#x2F;&amp;#x2F; Provide a default implementation for the licensing_info method
	fn licensing_info(&amp;amp;self) -&amp;gt; String {
		String::from(&amp;quot;Some information&amp;quot;)
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Default Implementation in Trait&lt;&#x2F;strong&gt;: In the &lt;code&gt;Licensed&lt;&#x2F;code&gt; trait, we provide a default implementation for the &lt;code&gt;licensing_info&lt;&#x2F;code&gt; method. This default implementation returns a string &amp;quot;Some information&amp;quot;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Implementing the Trait for Structs&lt;&#x2F;strong&gt;: We keep the lines &lt;code&gt;impl Licensed for SomeSoftware {}&lt;&#x2F;code&gt; and &lt;code&gt;impl Licensed for OtherSoftware {}&lt;&#x2F;code&gt; as they are. Since we&#x27;ve provided a default implementation in the trait, these structs will inherit that behavior.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Tests&lt;&#x2F;strong&gt;: The test function &lt;code&gt;is_licensing_info_the_same&lt;&#x2F;code&gt; should now pass, as both &lt;code&gt;SomeSoftware&lt;&#x2F;code&gt; and &lt;code&gt;OtherSoftware&lt;&#x2F;code&gt; will return &amp;quot;Some information&amp;quot; when their &lt;code&gt;licensing_info&lt;&#x2F;code&gt; methods are called.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Great! It works our code is compiling and our tests are passing&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âœ… Successfully tested exercises&amp;#x2F;traits&amp;#x2F;traits3.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;traits4-rs&quot;&gt;Traits4.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; traits4.rs
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Your task is to replace the &amp;#x27;??&amp;#x27; sections so the code compiles.
&amp;#x2F;&amp;#x2F; Don&amp;#x27;t change any line other than the marked one.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint traits4` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub trait Licensed {
    fn licensing_info(&amp;amp;self) -&amp;gt; String {
        &amp;quot;some information&amp;quot;.to_string()
    }
}

struct SomeSoftware {}

struct OtherSoftware {}

impl Licensed for SomeSoftware {}
impl Licensed for OtherSoftware {}

&amp;#x2F;&amp;#x2F; YOU MAY ONLY CHANGE THE NEXT LINE
fn compare_license_types(software: ??, software_two: ??) -&amp;gt; bool {
    software.licensing_info() == software_two.licensing_info()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn compare_license_information() {
        let some_software = SomeSoftware {};
        let other_software = OtherSoftware {};

        assert!(compare_license_types(some_software, other_software));
    }

    #[test]
    fn compare_license_information_backwards() {
        let some_software = SomeSoftware {};
        let other_software = OtherSoftware {};

        assert!(compare_license_types(other_software, some_software));
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This problem tells us that we can only change the code where we see the &lt;code&gt;??&lt;&#x2F;code&gt; question marks. So let&#x27;s take a look at the errors as we always do but I&#x27;m guessing there will be no surprises there.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits4-rs-errors&quot;&gt;Traits4.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;traits&amp;#x2F;traits4.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected identifier, found `,`
  --&amp;gt; exercises&amp;#x2F;traits&amp;#x2F;traits4.rs:23:38
   |
23 | fn compare_license_types(software: ??, software_two: ??) -&amp;gt; bool {
   |                                      ^
   |                                      |
   |                                      expected identifier
   |                                      help: remove this comma

error: expected a trait, found type
  --&amp;gt; exercises&amp;#x2F;traits&amp;#x2F;traits4.rs:23:37
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As expected, it points out where the missing code is and offers a suggestion although it&#x27;s wrong, it&#x27;s trying to figure out what is happening, so we can&#x27;t get to upset the compiler.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits4-rs-solution&quot;&gt;Traits4.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;So what does the compiler need to see inside of the parenthesis? Let&#x27;s break it down by first looking at what we already have.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-trait-and-structs&quot;&gt;The Trait and Structs&lt;&#x2F;h3&gt;
&lt;p&gt;First, we have a trait &lt;code&gt;Licensed&lt;&#x2F;code&gt; with a default implementation for a method called &lt;code&gt;licensing_info&lt;&#x2F;code&gt;. This method returns a string &amp;quot;some information&amp;quot;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub trait Licensed {
    fn licensing_info(&amp;amp;self) -&amp;gt; String {
        &amp;quot;some information&amp;quot;.to_string()
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then, we have two structs, &lt;code&gt;SomeSoftware&lt;&#x2F;code&gt; and &lt;code&gt;OtherSoftware&lt;&#x2F;code&gt;, that implement this trait.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct SomeSoftware {}
struct OtherSoftware {}

impl Licensed for SomeSoftware {}
impl Licensed for OtherSoftware {}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By doing this, both structs inherit the default behavior of the &lt;code&gt;licensing_info&lt;&#x2F;code&gt; method from the &lt;code&gt;Licensed&lt;&#x2F;code&gt; trait.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-function-to-compare-licenses&quot;&gt;The Function to Compare Licenses&lt;&#x2F;h3&gt;
&lt;p&gt;Now we get to the problem. We have the function &lt;code&gt;compare_license_types&lt;&#x2F;code&gt; takes two parameters, &lt;code&gt;software&lt;&#x2F;code&gt; and &lt;code&gt;software_two&lt;&#x2F;code&gt;. Both of which need to implement the &lt;code&gt;Licensed&lt;&#x2F;code&gt; trait. We do this by adding the by the syntax &lt;code&gt;impl Licensed&lt;&#x2F;code&gt; where the &lt;code&gt;??&lt;&#x2F;code&gt; were, and this should solve our problem.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn compare_license_types(software: impl Licensed, software_two: impl Licensed) -&amp;gt; bool {
    software.licensing_info() == software_two.licensing_info()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here&#x27;s what&#x27;s happening:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;software: impl Licensed&lt;&#x2F;code&gt;: This means that the function expects a parameter &lt;code&gt;software&lt;&#x2F;code&gt; that implements the &lt;code&gt;Licensed&lt;&#x2F;code&gt; trait.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;software_two: impl Licensed&lt;&#x2F;code&gt;: Similarly, this function expects another parameter &lt;code&gt;software_two&lt;&#x2F;code&gt; that also implements the &lt;code&gt;Licensed&lt;&#x2F;code&gt; trait.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;software.licensing_info() == software_two.licensing_info()&lt;&#x2F;code&gt;: This line compares the licensing information of both software. Since both &lt;code&gt;SomeSoftware&lt;&#x2F;code&gt; and &lt;code&gt;OtherSoftware&lt;&#x2F;code&gt; implement the &lt;code&gt;Licensed&lt;&#x2F;code&gt; trait, they both have a &lt;code&gt;licensing_info&lt;&#x2F;code&gt; method that returns &amp;quot;some information&amp;quot;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;with the added &lt;code&gt;impl Licensed&lt;&#x2F;code&gt; parameters our code compiles and passes it&#x27;s test. Now let&#x27;s move on to our final exercise on Traits.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits5-rs&quot;&gt;Traits5.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; traits5.rs
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Your task is to replace the &amp;#x27;??&amp;#x27; sections so the code compiles.
&amp;#x2F;&amp;#x2F; Don&amp;#x27;t change any line other than the marked one.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint traits5` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub trait SomeTrait {
    fn some_function(&amp;amp;self) -&amp;gt; bool {
        true
    }
}

pub trait OtherTrait {
    fn other_function(&amp;amp;self) -&amp;gt; bool {
        true
    }
}

struct SomeStruct {}
struct OtherStruct {}

impl SomeTrait for SomeStruct {}
impl OtherTrait for SomeStruct {}
impl SomeTrait for OtherStruct {}
impl OtherTrait for OtherStruct {}

&amp;#x2F;&amp;#x2F; YOU MAY ONLY CHANGE THE NEXT LINE
fn some_func(item: ??) -&amp;gt; bool {
    item.some_function() &amp;amp;&amp;amp; item.other_function()
}

fn main() {
    some_func(SomeStruct {});
    some_func(OtherStruct {});
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We get a similar type of problem where we have to replace the &lt;code&gt;??&lt;&#x2F;code&gt; question marks, and it&#x27;s only in one spot. Let&#x27;s look at the errors for any hints.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits5-rs-errors&quot;&gt;Traits5.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;traits&amp;#x2F;traits5.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected identifier, found `)`
  --&amp;gt; exercises&amp;#x2F;traits&amp;#x2F;traits5.rs:30:22
   |
30 | fn some_func(item: ??) -&amp;gt; bool {
   |                      ^ expected identifier

error[E0425]: cannot find value `item` in this scope
  --&amp;gt; exercises&amp;#x2F;traits&amp;#x2F;traits5.rs:31:5
   |
31 |     item.some_function() &amp;amp;&amp;amp; item.other_function()
   |     ^^^^ not found in this scope

error[E0425]: cannot find value `item` in this scope
  --&amp;gt; exercises&amp;#x2F;traits&amp;#x2F;traits5.rs:31:29
   |
31 |     item.some_function() &amp;amp;&amp;amp; item.other_function()
   |                             ^^^^ not found in this scope

error: aborting due to 3 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have 3 errors all together, one pointing at the &lt;code&gt;expected identifier&lt;&#x2F;code&gt; where the questions marks are and the next  2 pointing at the &lt;code&gt;item&lt;&#x2F;code&gt; not found in scope.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits5-rs-solution&quot;&gt;Traits5.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;If we look at our code we have a similar set-up to the previous exercise but we have two different traits &lt;code&gt;SomeTrait&lt;&#x2F;code&gt; and &lt;code&gt;OtherTrait&lt;&#x2F;code&gt; since we have been instructed to change only the parameter in &lt;code&gt;some_func&lt;&#x2F;code&gt; we can deduce that it will be a similar situation as the the previous exercise with using the &lt;code&gt;impl&lt;&#x2F;code&gt; and the &lt;code&gt;Trait&lt;&#x2F;code&gt; however in this case we have two different traits so how do we handle that? Easily enough we can use the &lt;code&gt;+&lt;&#x2F;code&gt; syntax to use allow our function to take both of these traits. This would look something like this: &lt;code&gt;impl &amp;lt;&amp;gt; + &amp;lt;&amp;gt;&lt;&#x2F;code&gt; so let&#x27;s try this.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn some_func(item: impl SomeTrait + OtherTrait) -&amp;gt; bool {
    item.some_function() &amp;amp;&amp;amp; item.other_function()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And with this it compiles!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this post, we explored various exercises related to traits in Rust. Here&#x27;s a quick summary of what we learned:&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits-in-rust&quot;&gt;Traits in Rust&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Traits are similar to interfaces in other languages.&lt;&#x2F;li&gt;
&lt;li&gt;They define shared behavior across data types.&lt;&#x2F;li&gt;
&lt;li&gt;Traits can have default implementations.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;exercises&quot;&gt;Exercises&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;traits1-rs-1&quot;&gt;Traits1.rs&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;Implemented the &lt;code&gt;AppendBar&lt;&#x2F;code&gt; trait for &lt;code&gt;String&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Explored two ways to append &amp;quot;Bar&amp;quot; to a string: using &lt;code&gt;+&lt;&#x2F;code&gt; and &lt;code&gt;format!&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;traits2-rs-1&quot;&gt;Traits2.rs&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;Implemented the &lt;code&gt;AppendBar&lt;&#x2F;code&gt; trait for &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Used the &lt;code&gt;push&lt;&#x2F;code&gt; method to append &amp;quot;Bar&amp;quot; to the vector.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;traits3-rs-1&quot;&gt;Traits3.rs&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;Provided a default implementation for the &lt;code&gt;licensing_info&lt;&#x2F;code&gt; method in the &lt;code&gt;Licensed&lt;&#x2F;code&gt; trait.&lt;&#x2F;li&gt;
&lt;li&gt;Both &lt;code&gt;SomeSoftware&lt;&#x2F;code&gt; and &lt;code&gt;OtherSoftware&lt;&#x2F;code&gt; structs inherited this default behavior.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;traits4-rs-1&quot;&gt;Traits4.rs&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;Used &lt;code&gt;impl Licensed&lt;&#x2F;code&gt; to specify that the function &lt;code&gt;compare_license_types&lt;&#x2F;code&gt; expects parameters that implement the &lt;code&gt;Licensed&lt;&#x2F;code&gt; trait.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;traits5-rs-1&quot;&gt;Traits5.rs&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;Used &lt;code&gt;impl SomeTrait + OtherTrait&lt;&#x2F;code&gt; to specify that the function &lt;code&gt;some_func&lt;&#x2F;code&gt; expects a parameter that implements both &lt;code&gt;SomeTrait&lt;&#x2F;code&gt; and &lt;code&gt;OtherTrait&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;By working through these exercises, we gained a deeper understanding of how traits work in Rust and how they can be used to write more flexible and reusable code.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>16 Rustlings Generics</title>
          <pubDate>Wed, 16 Aug 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/16-rustlings-generics/</link>
          <guid>https://desmodrone.github.io/posts/16-rustlings-generics/</guid>
          <description xml:base="https://desmodrone.github.io/posts/16-rustlings-generics/">&lt;h1 id=&quot;generics&quot;&gt;Generics&lt;&#x2F;h1&gt;
&lt;h3 id=&quot;from-the-readme&quot;&gt;From the README&lt;&#x2F;h3&gt;
&lt;p&gt;Generics is the topic of generalizing types and functionalities to broader cases.
This is extremely useful for reducing code duplication in many ways, but can call for rather involving syntax.
Namely, being generic requires taking great care to specify over which types a generic type is actually considered valid.
The simplest and most common use of generics is for type parameters.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch10-01-syntax.html&quot;&gt;Generic Data Types&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;generics&#x2F;bounds.html&quot;&gt;Bounds&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;generics1-rs&quot;&gt;Generics1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; This shopping list program isn&amp;#x27;t compiling!
&amp;#x2F;&amp;#x2F; Use your knowledge of generics to fix it.

&amp;#x2F;&amp;#x2F; Execute `rustlings hint generics1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let mut shopping_list: Vec&amp;lt;?&amp;gt; = Vec::new();
    shopping_list.push(&amp;quot;milk&amp;quot;);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions tells to make this code compile using generics. We clearly have a question mark out of place, so what do we put there? Let&#x27;s first look at our errors to see if we get any additional information.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;generics1-rs-errors&quot;&gt;Generics1.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;generics&amp;#x2F;generics1.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected identifier, found `&amp;gt;`
 --&amp;gt; exercises&amp;#x2F;generics&amp;#x2F;generics1.rs:9:33
  |
9 |     let mut shopping_list: Vec&amp;lt;?&amp;gt; = Vec::new();
  |         -----------------       ^ expected identifier
  |         |
  |         while parsing the type for `mut shopping_list`

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Not much to see here. We see what we already knew. Alright so how do we solve this issue?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;generics1-rs-solution&quot;&gt;Generics1.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;It seems like the easiest way to solve this exercise is to give the compiler what it&#x27;s asking for, the &lt;code&gt;identifier&lt;&#x2F;code&gt; which in this case should be a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let mut shopping_list: Vec&amp;lt;&amp;amp;str&amp;gt; = Vec::new();
    shopping_list.push(&amp;quot;milk&amp;quot;);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By specifying &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; as the type parameter for the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;, we are utilizing Rust&#x27;s generics mechanism. In Rust, &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; is a generic type where &lt;code&gt;T&lt;&#x2F;code&gt; can be any type. In our solution, &lt;code&gt;T&lt;&#x2F;code&gt; is explicitly set to &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;, making the type of the vector &lt;code&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;&#x2F;code&gt;. This demonstrates the power and flexibility of generics, allowing us to define a collection that can hold specific types of data, in this case, string slices.&lt;&#x2F;p&gt;
&lt;p&gt;and with that we are compiling!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;generics2-rs&quot;&gt;Generics2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; This powerful wrapper provides the ability to store a positive integer value.
&amp;#x2F;&amp;#x2F; Rewrite it using generics so that it supports wrapping ANY type.

&amp;#x2F;&amp;#x2F; Execute `rustlings hint generics2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

struct Wrapper {
    value: u32,
}

impl Wrapper {
    pub fn new(value: u32) -&amp;gt; Self {
        Wrapper { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn store_u32_in_wrapper() {
        assert_eq!(Wrapper::new(42).value, 42);
    }

    #[test]
    fn store_str_in_wrapper() {
        assert_eq!(Wrapper::new(&amp;quot;Foo&amp;quot;).value, &amp;quot;Foo&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this exercise we are being asked to refactor this code to be able to handle any type instead of just positive integers.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;generics2-rs-errors&quot;&gt;Generics2.rs Errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;generics&amp;#x2F;generics2.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;generics&amp;#x2F;generics2.rs:27:33
   |
27 |         assert_eq!(Wrapper::new(&amp;quot;Foo&amp;quot;).value, &amp;quot;Foo&amp;quot;);
   |                    ------------ ^^^^^ expected `u32`, found `&amp;amp;str`
   |                    |
   |                    arguments to this function are incorrect
   |
note: associated function defined here
  --&amp;gt; exercises&amp;#x2F;generics&amp;#x2F;generics2.rs:11:12
   |
11 |     pub fn new(value: u32) -&amp;gt; Self {
   |            ^^^ ----------

error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;generics&amp;#x2F;generics2.rs:27:9
   |
27 |         assert_eq!(Wrapper::new(&amp;quot;Foo&amp;quot;).value, &amp;quot;Foo&amp;quot;);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         expected `u32`, found `&amp;amp;str`
   |         expected because this is `u32`
   |
   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the errors we see problems with our tests, because they are not handling generics so let&#x27;s fix that&lt;&#x2F;p&gt;
&lt;h2 id=&quot;generic2-rs-solution&quot;&gt;Generic2.rs Solution&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s start by updating our struct to handle any kind of value, not just a specific type.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
struct Wrapper&amp;lt;T&amp;gt; {
    value: T,
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, instead of saying our &lt;code&gt;value&lt;&#x2F;code&gt; is a specific type (like &lt;code&gt;u32&lt;&#x2F;code&gt; or &lt;code&gt;String&lt;&#x2F;code&gt;), we&#x27;re using &lt;code&gt;T&lt;&#x2F;code&gt;. Think of &lt;code&gt;T&lt;&#x2F;code&gt; as a placeholder that says, &amp;quot;Hey, I can be any type you want!&amp;quot; It&#x27;s like when you have a toy where you can swap out the pieces; &lt;code&gt;T&lt;&#x2F;code&gt; is our swappable piece.&lt;&#x2F;p&gt;
&lt;p&gt;By writing &lt;code&gt;&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; next to &lt;code&gt;Wrapper&lt;&#x2F;code&gt;, we&#x27;re telling Rust, &amp;quot;This &lt;code&gt;Wrapper&lt;&#x2F;code&gt; can work with many types, and we&#x27;re going to call the type we&#x27;re working with &lt;code&gt;T&lt;&#x2F;code&gt;.&amp;quot; It&#x27;s a common thing you&#x27;ll see in Rust, and while &lt;code&gt;T&lt;&#x2F;code&gt; is just a convention (we could use other letters or names), it&#x27;s widely used to mean &amp;quot;some type.&amp;quot;&lt;&#x2F;p&gt;
&lt;p&gt;With this change, our &lt;code&gt;Wrapper&lt;&#x2F;code&gt; is now flexible and can wrap around any type of value.&lt;&#x2F;p&gt;
&lt;p&gt;Now let&#x27;s work on the &lt;code&gt;impl&lt;&#x2F;code&gt; block or the method which we have to also change to be able to handle generic values.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl&amp;lt;T&amp;gt; Wrapper&amp;lt;T&amp;gt; {
    pub fn new(value: u32) -&amp;gt; Self {
        Wrapper { value }
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s start with the signature where we have to add the &lt;code&gt;&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; to the &lt;code&gt;impl&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; so we can use the generic value in &lt;code&gt;Wrapper&lt;&#x2F;code&gt;. Next we also have to add the &lt;code&gt;T&lt;&#x2F;code&gt; to &lt;code&gt;Wrapper&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;  to make it match our struct.&lt;&#x2F;p&gt;
&lt;p&gt;Finally we have to fix our &lt;code&gt;new()&lt;&#x2F;code&gt; function to pass in a generic type and not a &lt;code&gt;u32&lt;&#x2F;code&gt; as a &lt;code&gt;value:&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    pub fn new(value: T) -&amp;gt; Self {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This should be it, let&#x27;s save and see what happens.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Yes, we&#x27;re compiling, we&#x27;ve successfully refactored from only accepting &lt;code&gt;u32&lt;&#x2F;code&gt;&#x27;s  to accepting any type.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;The exercises on generics provide a hands-on introduction to one of Rust&#x27;s powerful features: the ability to write code that operates on a variety of types. Generics enable us to write flexible and reusable code without sacrificing performance. Through the exercises, we&#x27;ve seen how to refactor specific types into generic ones, allowing our code to handle a broader range of use cases.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>15 Rustlings Errors Part 2</title>
          <pubDate>Fri, 11 Aug 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/15-rustlings-errors2/</link>
          <guid>https://desmodrone.github.io/posts/15-rustlings-errors2/</guid>
          <description xml:base="https://desmodrone.github.io/posts/15-rustlings-errors2/">&lt;h1 id=&quot;error-handling-part-2&quot;&gt;Error Handling Part 2&lt;&#x2F;h1&gt;
&lt;p&gt;We&#x27;re back with the 2nd part of our Error handling post we&#x27;ll cover exercises 3-6. If you haven&#x27;t read &lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;15-rustlings-errors1&#x2F;&quot;&gt;Error Handling Part 1&lt;&#x2F;a&gt; it&#x27;s a good idea to go through that first before moving on to these.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;this-is-from-the-rustlings-readme&quot;&gt;This is from the Rustlings README:&lt;&#x2F;h3&gt;
&lt;p&gt;Most errors arenâ€™t serious enough to require the program to stop entirely.
Sometimes, when a function fails, itâ€™s for a reason that you can easily interpret and respond to.
For example, if you try to open a file and that operation fails because the file doesnâ€™t exist, you might want to create the file instead of terminating the process.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch09-02-recoverable-errors-with-result.html&quot;&gt;Error Handling&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-01-syntax.html&quot;&gt;Generics&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;error&#x2F;result.html&quot;&gt;Result&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;error&#x2F;multiple_error_types&#x2F;boxing_errors.html&quot;&gt;Boxing errors&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;errors4-rs&quot;&gt;Errors4.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; errors4.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint errors4` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&amp;gt; Result&amp;lt;PositiveNonzeroInteger, CreationError&amp;gt; {
        &amp;#x2F;&amp;#x2F; Hmm...? Why is this only returning an Ok value?
        Ok(PositiveNonzeroInteger(value as u64))
    }
}

#[test]
fn test_creation() {
    assert!(PositiveNonzeroInteger::new(10).is_ok());
    assert_eq!(
        Err(CreationError::Negative),
        PositiveNonzeroInteger::new(-10)
    );
    assert_eq!(Err(CreationError::Zero), PositiveNonzeroInteger::new(0));
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We don&#x27;t get much for hints and description, other than a comment that asks &lt;code&gt;Hmm...? Why is this only reguring an Ok value?&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look at our Rust compiler errors and see if we get any additional hints on how to fix this.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;errors4-rs-errors&quot;&gt;Errors4.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Testing of exercises&amp;#x2F;error_handling&amp;#x2F;errors4.rs failed! Please try again. Here&amp;#x27;s the output:

running 1 test
test test_creation ... FAILED

successes:

successes:

failures:

---- test_creation stdout ----
thread &amp;#x27;test_creation&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `Err(Negative)`,
 right: `Ok(PositiveNonzeroInteger(18446744073709551606))`&amp;#x27;, exercises&amp;#x2F;error_handling&amp;#x2F;errors4.rs:25:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    test_creation

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It looks like our code is compiling but panicking and we see that our test is failing. If we look at the actual test we see that &lt;code&gt;(left == right)&lt;&#x2F;code&gt; failed we&#x27;re getting different values. The test is expecting &lt;code&gt;Err(Negative)&lt;&#x2F;code&gt; but instead it&#x27;s seeing &lt;code&gt;Ok(PositiveNonzero...))&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;errors4-rs-solution&quot;&gt;Errors4.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;It looks like we have to handle our error&#x27;s, as nothing is being done to take care of them in our code right now. Maybe an &lt;code&gt;if&lt;&#x2F;code&gt; or maybe a &lt;code&gt;match&lt;&#x2F;code&gt; statement will do the trick. Let&#x27;s try.
Let&#x27;s use a match statement first. If we look at the code and tests, we know that there is 3 different scenarios we have to account for:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Negative &lt;code&gt;Err&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Zero &lt;code&gt;Err&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Positive &lt;code&gt;Ok&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;so let&#x27;s us &lt;code&gt;match&lt;&#x2F;code&gt; to handle each one of these cases.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;For &lt;code&gt;Negative&lt;&#x2F;code&gt; we create a simple &lt;code&gt;if&lt;&#x2F;code&gt; statement, saying that if our &lt;code&gt;v(alue)&lt;&#x2F;code&gt; is less than &lt;code&gt;0&lt;&#x2F;code&gt; we return an error&lt;&#x2F;li&gt;
&lt;li&gt;For &lt;code&gt;Zero&lt;&#x2F;code&gt; we simply have to match an actual &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;For positive, it can be anything positive meaning we can use the &lt;code&gt;_&lt;&#x2F;code&gt; wildcard underscore character&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;match value {
	v if v &amp;lt; 0 =&amp;gt; Err(CreationError::Negative), &amp;#x2F;&amp;#x2F; v represents `value` here
	0 =&amp;gt; Err(CreationError::Zero),
	_ =&amp;gt; Ok(PositiveNonzeroInteger(value as u64)),
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It would look like this in the context of our code.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&amp;gt; Result&amp;lt;PositiveNonzeroInteger, CreationError&amp;gt; {
        match value {
            v if v &amp;lt; 0 =&amp;gt; Err(CreationError::Negative),
            0 =&amp;gt; Err(CreationError::Zero),
            _ =&amp;gt; Ok(PositiveNonzeroInteger(value as u64)),
        }
    }
}

#[test]
fn test_creation() {
    assert!(PositiveNonzeroInteger::new(10).is_ok());
    assert_eq!(
        Err(CreationError::Negative),
        PositiveNonzeroInteger::new(-10)
    );
    assert_eq!(Err(CreationError::Zero), PositiveNonzeroInteger::new(0));
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And this compiles ðŸŽ‰ but can we use &lt;code&gt;if&lt;&#x2F;code&gt; in this as well?&lt;&#x2F;p&gt;
&lt;h3 id=&quot;what-about-if&quot;&gt;What about &lt;code&gt;if&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s take a stab at it.
So, again we have to deal with the 3 different scenarios here&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;if our value is less than zero&lt;&#x2F;li&gt;
&lt;li&gt;if our value is equal to zero&lt;&#x2F;li&gt;
&lt;li&gt;if it&#x27;s positive&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;So writing that looks  like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt; if value &amp;lt; 0 {
            Err(CreationError::Negative)
        } else if value == 0 {
            Err(CreationError::Zero)
        } else {
            Ok(PositiveNonzeroInteger(value as u64))
        }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here&#x27;s what it looks like in context of the full problem:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&amp;gt; Result&amp;lt;PositiveNonzeroInteger, CreationError&amp;gt; {
        if value &amp;lt; 0 {
            Err(CreationError::Negative)
        } else if value == 0 {
            Err(CreationError::Zero)
        } else {
            Ok(PositiveNonzeroInteger(value as u64))
        }
    }
}

#[test]
fn test_creation() {
    assert!(PositiveNonzeroInteger::new(10).is_ok());
    assert_eq!(
        Err(CreationError::Negative),
        PositiveNonzeroInteger::new(-10)
    );
    assert_eq!(Err(CreationError::Zero), PositiveNonzeroInteger::new(0));
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and with that we have solved &lt;code&gt;errors4.rs&lt;&#x2F;code&gt; we have our code compiling:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âœ… Successfully tested exercises&amp;#x2F;error_handling&amp;#x2F;errors4.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright. On to &lt;code&gt;Errors5.rs&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;errors5-rs&quot;&gt;Errors5.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; errors5.rs

&amp;#x2F;&amp;#x2F; This program uses an altered version of the code from errors4.

&amp;#x2F;&amp;#x2F; This exercise uses some concepts that we won&amp;#x27;t get to until later in the course, like `Box` and the
&amp;#x2F;&amp;#x2F; `From` trait. It&amp;#x27;s not important to understand them in detail right now, but you can read ahead if you like.
&amp;#x2F;&amp;#x2F; For now, think of the `Box&amp;lt;dyn ???&amp;gt;` type as an &amp;quot;I want anything that does ???&amp;quot; type, which, given
&amp;#x2F;&amp;#x2F; Rust&amp;#x27;s usual standards for runtime safety, should strike you as somewhat lenient!

&amp;#x2F;&amp;#x2F; In short, this particular use case for boxes is for when you want to own a value and you care only that it is a
&amp;#x2F;&amp;#x2F; type which implements a particular trait. To do so, The Box is declared as of type Box&amp;lt;dyn Trait&amp;gt; where Trait is the trait
&amp;#x2F;&amp;#x2F; the compiler looks for on any value used in that context. For this exercise, that context is the potential errors
&amp;#x2F;&amp;#x2F; which can be returned in a Result.

&amp;#x2F;&amp;#x2F; What can we use to describe both errors? In other words, is there a trait which both errors implement?

&amp;#x2F;&amp;#x2F; Execute `rustlings hint errors5` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::error;
use std::fmt;
use std::num::ParseIntError;

&amp;#x2F;&amp;#x2F; TODO: update the return type of `main()` to make this compile.
fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn ???&amp;gt;&amp;gt; {
    let pretend_user_input = &amp;quot;42&amp;quot;;
    let x: i64 = pretend_user_input.parse()?;
    println!(&amp;quot;output={:?}&amp;quot;, PositiveNonzeroInteger::new(x)?);
    Ok(())
}

&amp;#x2F;&amp;#x2F; Don&amp;#x27;t change anything below this line.

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&amp;gt; Result&amp;lt;PositiveNonzeroInteger, CreationError&amp;gt; {
        match value {
            x if x &amp;lt; 0 =&amp;gt; Err(CreationError::Negative),
            x if x == 0 =&amp;gt; Err(CreationError::Zero),
            x =&amp;gt; Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

&amp;#x2F;&amp;#x2F; This is required so that `CreationError` can implement `error::Error`.
impl fmt::Display for CreationError {
    fn fmt(&amp;amp;self, f: &amp;amp;mut fmt::Formatter) -&amp;gt; fmt::Result {
        let description = match *self {
            CreationError::Negative =&amp;gt; &amp;quot;number is negative&amp;quot;,
            CreationError::Zero =&amp;gt; &amp;quot;number is zero&amp;quot;,
        };
        f.write_str(description)
    }
}

impl error::Error for CreationError {}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is an interesting one as it has a lot of comments above the code but it mainly provides hints about what &lt;code&gt;Box&lt;&#x2F;code&gt; can do. Our task is to determine the correct return type in the &lt;code&gt;Rusult&amp;lt;(), Box&amp;lt;dyn ???&amp;gt;&amp;gt;&lt;&#x2F;code&gt; part of the code. The easy thought is that it has to return an &lt;code&gt;Error&lt;&#x2F;code&gt; but is it that simple? Let&#x27;s try, but first let&#x27;s take a look at the errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;errors5-rs-errors&quot;&gt;Errors5.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;error_handling&amp;#x2F;errors5.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected identifier, found `&amp;gt;&amp;gt;`
  --&amp;gt; exercises&amp;#x2F;error_handling&amp;#x2F;errors5.rs:26:36
   |
26 | fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn ???&amp;gt;&amp;gt; {
   |                                    ^^ expected identifier

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Nothing to specific here but we see where we are missing our code and it&#x27;s expecting an identifier.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;errors5-rs-solution&quot;&gt;Errors5.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;So let&#x27;s try simply entering &lt;code&gt;Error&lt;&#x2F;code&gt; because that&#x27;s what we should be expecting to see correct?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; TODO: update the return type of `main()` to make this compile.
fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn ???&amp;gt;&amp;gt; {
    let pretend_user_input = &amp;quot;42&amp;quot;;
    let x: i64 = pretend_user_input.parse()?;
    println!(&amp;quot;output={:?}&amp;quot;, PositiveNonzeroInteger::new(x)?);
    Ok(())
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Well, we still get some errors but we have some help.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;error_handling&amp;#x2F;errors5.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0405]: cannot find trait `Error` in this scope
  --&amp;gt; exercises&amp;#x2F;error_handling&amp;#x2F;errors5.rs:26:33
   |
26 | fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt; {
   |                                 ^^^^^ not found in this scope
   |
help: consider importing one of these items
   |
21 + use core::error::Error;
   |
21 + use crate::error::Error;
   |
21 + use std::error::Error;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So the compiler is telling us that that &lt;code&gt;Error&lt;&#x2F;code&gt; is not found in scope and gives us a bunch of different options to use in our &lt;code&gt;Box&amp;lt;dyn &amp;gt;&lt;&#x2F;code&gt;. But before we implement one of these let&#x27;s continue looking at our code. I had missed this comment earlier:&lt;code&gt;&#x2F;&#x2F; This is required so that `CreationError` can implement `error::Error`&lt;&#x2F;code&gt;. It looks like we might have a hint here too. This comment is telling us that this function is being created to allow us to use &lt;code&gt;error::Error&lt;&#x2F;code&gt; for &lt;code&gt;CreationError&lt;&#x2F;code&gt; which means that we could use &lt;code&gt;error::Error&lt;&#x2F;code&gt; as our error handler in the return type right? Let&#x27;s try.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; TODO: update the return type of `main()` to make this compile.
fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn error::Error&amp;gt;&amp;gt; {
    let pretend_user_input = &amp;quot;42&amp;quot;;
    let x: i64 = pretend_user_input.parse()?;
    println!(&amp;quot;output={:?}&amp;quot;, PositiveNonzeroInteger::new(x)?);
    Ok(())
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It compiles! This is our output:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âœ… Successfully ran exercises&amp;#x2F;error_handling&amp;#x2F;errors5.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰

Output:
====================
output=PositiveNonzeroInteger(42)

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;errors6-rs&quot;&gt;Errors6.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; errors6.rs

&amp;#x2F;&amp;#x2F; Using catch-all error types like `Box&amp;lt;dyn error::Error&amp;gt;` isn&amp;#x27;t recommended
&amp;#x2F;&amp;#x2F; for library code, where callers might want to make decisions based on the
&amp;#x2F;&amp;#x2F; error content, instead of printing it out or propagating it further. Here,
&amp;#x2F;&amp;#x2F; we define a custom error type to make it possible for callers to decide
&amp;#x2F;&amp;#x2F; what to do next when our function returns an error.

&amp;#x2F;&amp;#x2F; Execute `rustlings hint errors6` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::num::ParseIntError;

&amp;#x2F;&amp;#x2F; This is a custom error type that we will be using in `parse_pos_nonzero()`.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl ParsePosNonzeroError {
    fn from_creation(err: CreationError) -&amp;gt; ParsePosNonzeroError {
        ParsePosNonzeroError::Creation(err)
    }
    &amp;#x2F;&amp;#x2F; TODO: add another error conversion function here.
    &amp;#x2F;&amp;#x2F; fn from_parseint...

}

fn parse_pos_nonzero(s: &amp;amp;str) -&amp;gt; Result&amp;lt;PositiveNonzeroInteger, ParsePosNonzeroError&amp;gt; {
    &amp;#x2F;&amp;#x2F; TODO: change this to return an appropriate error instead of panicking
    &amp;#x2F;&amp;#x2F; when `parse()` returns an error.
    let x: i64 = s.parse().unwrap();
    PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)
}

&amp;#x2F;&amp;#x2F; Don&amp;#x27;t change anything below this line.

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&amp;gt; Result&amp;lt;PositiveNonzeroInteger, CreationError&amp;gt; {
        match value {
            x if x &amp;lt; 0 =&amp;gt; Err(CreationError::Negative),
            x if x == 0 =&amp;gt; Err(CreationError::Zero),
            x =&amp;gt; Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_parse_error() {
        &amp;#x2F;&amp;#x2F; We can&amp;#x27;t construct a ParseIntError, so we have to pattern match.
        assert!(matches!(
            parse_pos_nonzero(&amp;quot;not a number&amp;quot;),
            Err(ParsePosNonzeroError::ParseInt(_))
        ));
    }

    #[test]
    fn test_negative() {
        assert_eq!(
            parse_pos_nonzero(&amp;quot;-555&amp;quot;),
            Err(ParsePosNonzeroError::Creation(CreationError::Negative))
        );
    }

    #[test]
    fn test_zero() {
        assert_eq!(
            parse_pos_nonzero(&amp;quot;0&amp;quot;),
            Err(ParsePosNonzeroError::Creation(CreationError::Zero))
        );
    }

    #[test]
    fn test_positive() {
        let x = PositiveNonzeroInteger::new(42);
        assert!(x.is_ok());
        assert_eq!(parse_pos_nonzero(&amp;quot;42&amp;quot;), Ok(x.unwrap()));
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this exercise we are defining a custom error type and we have 3 clear instructions.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;We have to add an error conversion function&lt;&#x2F;li&gt;
&lt;li&gt;Change the &lt;code&gt;parse_pos_nonzero&lt;&#x2F;code&gt; function to allow proper error handling&lt;&#x2F;li&gt;
&lt;li&gt;Don&#x27;t change anything below code line 38 or after the &lt;code&gt;parse_pos_nonzero&lt;&#x2F;code&gt; function ends.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;errors6-rs-errors&quot;&gt;Errors6.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Testing of exercises&amp;#x2F;error_handling&amp;#x2F;errors6.rs failed! Please try again. Here&amp;#x27;s the output:

running 4 tests
test test::test_negative ... ok
test test::test_positive ... ok
test test::test_zero ... ok
test test::test_parse_error ... FAILED

successes:

successes:
    test::test_negative
    test::test_positive
    test::test_zero

failures:

---- test::test_parse_error stdout ----
thread &amp;#x27;test::test_parse_error&amp;#x27; panicked at &amp;#x27;called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }&amp;#x27;, exercises&amp;#x2F;error_handling&amp;#x2F;errors6.rs:33:28
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    test::test_parse_error

test result: FAILED. 3 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our errors show us we have 3 passing test but the &lt;code&gt;test_parse_error&lt;&#x2F;code&gt; test is failing.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;errors6-rs-solution&quot;&gt;Errors6.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s first start by creating that 2nd function.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
use std::num::ParseIntError;

&amp;#x2F;&amp;#x2F; This is a custom error type that we will be using in `parse_pos_nonzero()`.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl ParsePosNonzeroError {
    fn from_creation(err: CreationError) -&amp;gt; ParsePosNonzeroError {
        ParsePosNonzeroError::Creation(err)
    }
    fn from_parseint(err: ParseIntError) -&amp;gt; ParsePosNonzeroError {
        ParsePosNonzeroError::ParseInt(err)
    }

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here i&#x27;m creating a new function using the same structure as the &lt;code&gt;from_creation&lt;&#x2F;code&gt; and this should help us finish our custom error types. When we save though, nothing changes, we still get 3 passing tests, and one fail.&lt;&#x2F;p&gt;
&lt;p&gt;So let&#x27;s move on to the next &lt;code&gt;todo&lt;&#x2F;code&gt; on our list.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn parse_pos_nonzero(s: &amp;amp;str) -&amp;gt; Result&amp;lt;PositiveNonzeroInteger, ParsePosNonzeroError&amp;gt; {
    &amp;#x2F;&amp;#x2F; TODO: change this to return an appropriate error instead of panicking
    &amp;#x2F;&amp;#x2F; when `parse()` returns an error.
    let x: i64 = s.parse().unwrap();
    PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;parse-error-approach&quot;&gt;Parse Error Approach&lt;&#x2F;h3&gt;
&lt;p&gt;So we know that we have to remove the &lt;code&gt;.unwrap()&lt;&#x2F;code&gt; method because this is what makes the code panic, and if we look at the hints we get this:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Below the line that TODO asks you to change, there is an example of using the &lt;code&gt;map_err()&lt;&#x2F;code&gt; method on a &lt;code&gt;Result&lt;&#x2F;code&gt; to transform one type of error into another. Try using something similar on the &lt;code&gt;Result&lt;&#x2F;code&gt; from &lt;code&gt;parse()&lt;&#x2F;code&gt;. You might use the &lt;code&gt;?&lt;&#x2F;code&gt; operator to return early from the function, or you might use a &lt;code&gt;match&lt;&#x2F;code&gt; expression, or maybe there&#x27;s another way! You can create another function inside &lt;code&gt;impl ParsePosNonzeroError&lt;&#x2F;code&gt; to use with &lt;code&gt;map_err()&lt;&#x2F;code&gt;. Read more about &lt;code&gt;map_err()&lt;&#x2F;code&gt; in the &lt;code&gt;std::result&lt;&#x2F;code&gt; documentation: https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;result&#x2F;enum.Result.html#method.map_err&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;So let&#x27;s try this approach.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We attempt to parse &lt;code&gt;s&lt;&#x2F;code&gt; into an &lt;code&gt;i64&lt;&#x2F;code&gt;. If this fails, we convert the error and return early because of the &lt;code&gt;?&lt;&#x2F;code&gt; operator.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;If parsing succeeds, we then attempt to create a &lt;code&gt;PositiveNonzeroInteger&lt;&#x2F;code&gt;. If this fails, we convert the error using &lt;code&gt;map_err()&lt;&#x2F;code&gt;, but since there&#x27;s no &lt;code&gt;?&lt;&#x2F;code&gt; operator here, we don&#x27;t return early (because this is the last line of the function and the resulting &lt;code&gt;Result&lt;&#x2F;code&gt; is directly returned).&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn parse_pos_nonzero(s: &amp;amp;str) -&amp;gt; Result&amp;lt;PositiveNonzeroInteger, ParsePosNonzeroError&amp;gt; {
    &amp;#x2F;&amp;#x2F; Try parsing the string into an i64.
    let x = s.parse::&amp;lt;i64&amp;gt;().map_err(ParsePosNonzeroError::from_parseint)?;

    &amp;#x2F;&amp;#x2F; Create a PositiveNonzeroInteger, and if this fails, transform the error.
    PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;using-match&quot;&gt;Using Match&lt;&#x2F;h3&gt;
&lt;p&gt;We can also use matching to get our result, using something called a &lt;code&gt;turbofish&lt;&#x2F;code&gt; (unofficially) the full scoop on this this should be later, but for now let&#x27;s say this &lt;code&gt;::&amp;lt;&amp;gt;&lt;&#x2F;code&gt; or &lt;code&gt;turbofish&lt;&#x2F;code&gt; (see it kinda looks like a fish) is used to help the compiler understand the exact type you intend when type inference might be insufficient or ambiguous.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn parse_pos_nonzero(s: &amp;amp;str) -&amp;gt; Result&amp;lt;PositiveNonzeroInteger, ParsePosNonzeroError&amp;gt; {
    &amp;#x2F;&amp;#x2F; TODO: change this to return an appropriate error instead of panicking
    &amp;#x2F;&amp;#x2F; when `parse()` returns an error.
    let x = s.parse::&amp;lt;i64&amp;gt;();

    match x {
        Ok(val) =&amp;gt; PositiveNonzeroInteger::new(val).map_err(ParsePosNonzeroError::from_creation),
        Err(e) =&amp;gt; Err(ParsePosNonzeroError::from_parseint(e)),
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this second part of our exploration into Rust error handling, we delved into exercises 3 to 6 to understand and tackle various aspects of working with errors in Rust programming. We built upon the concepts introduced in the first part and extended our knowledge to handle more intricate scenarios.&lt;&#x2F;p&gt;
&lt;p&gt;We began with &lt;strong&gt;Errors4.rs&lt;&#x2F;strong&gt;, where we encountered a situation involving custom error types. By using the &lt;code&gt;match&lt;&#x2F;code&gt; expression, we effectively handled different error cases and returned appropriate results based on the input. This exercise illuminated the power of pattern matching in Rust&#x27;s error handling mechanism.&lt;&#x2F;p&gt;
&lt;p&gt;Moving on to &lt;strong&gt;Errors5.rs&lt;&#x2F;strong&gt;, we tackled a case involving the &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;&#x2F;code&gt; type. By correctly choosing the appropriate return type for the &lt;code&gt;main()&lt;&#x2F;code&gt; function, we demonstrated how Rust&#x27;s error system allows for flexibility in dealing with various error types in a generic manner. This exercise reinforced the importance of choosing the right error type depending on the context of your program.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, in &lt;strong&gt;Errors6.rs&lt;&#x2F;strong&gt;, we showcased our ability to create custom error types and handle complex error propagation scenarios. We introduced a custom error type &lt;code&gt;ParsePosNonzeroError&lt;&#x2F;code&gt; and skillfully converted different error types into this unified form using methods like &lt;code&gt;map_err()&lt;&#x2F;code&gt;. This exercise highlighted Rust&#x27;s expressive error handling capabilities and provided insight into creating ergonomic APIs that clearly communicate errors to the caller.&lt;&#x2F;p&gt;
&lt;p&gt;Throughout this journey, we harnessed Rust&#x27;s powerful error handling constructs, including &lt;code&gt;Result&lt;&#x2F;code&gt;, &lt;code&gt;match&lt;&#x2F;code&gt; expressions, &lt;code&gt;?&lt;&#x2F;code&gt; operator, &lt;code&gt;map_err()&lt;&#x2F;code&gt;, and custom error types. These exercises reinforced the idea that errors in Rust are not just exceptions but a fundamental part of the language that guides developers in creating robust and reliable software.&lt;&#x2F;p&gt;
&lt;p&gt;By mastering error handling in Rust, we equip ourselves with the tools to write code that elegantly handles failures and provides meaningful feedback to users. As we continue our Rust learning journey, these skills will prove invaluable in building resilient and dependable applications.&lt;&#x2F;p&gt;
&lt;p&gt;Continue to explore the rich Rust ecosystem, experiment with error handling in different scenarios, and always remember that Rust&#x27;s error handling philosophy encourages us to embrace errors, not fear them.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>15 Rustlings Errors Part 1</title>
          <pubDate>Tue, 08 Aug 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/15-rustlings-errors1/</link>
          <guid>https://desmodrone.github.io/posts/15-rustlings-errors1/</guid>
          <description xml:base="https://desmodrone.github.io/posts/15-rustlings-errors1/">&lt;h1 id=&quot;error-handling-part-1&quot;&gt;Error Handling Part 1&lt;&#x2F;h1&gt;
&lt;p&gt;There&#x27;s 6 exercises so I&#x27;m breaking them up into batches of 3.&lt;&#x2F;p&gt;
&lt;p&gt;Most errors arenâ€™t serious enough to require the program to stop entirely.
Sometimes, when a function fails, itâ€™s for a reason that you can easily interpret and respond to.
For example, if you try to open a file and that operation fails because the file doesnâ€™t exist, you might want to create the file instead of terminating the process.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch09-02-recoverable-errors-with-result.html&quot;&gt;Error Handling&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-01-syntax.html&quot;&gt;Generics&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;error&#x2F;result.html&quot;&gt;Result&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;error&#x2F;multiple_error_types&#x2F;boxing_errors.html&quot;&gt;Boxing errors&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;errors1-rs&quot;&gt;errors1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; errors1.rs
&amp;#x2F;&amp;#x2F; This function refuses to generate text to be printed on a nametag if
&amp;#x2F;&amp;#x2F; you pass it an empty string. It&amp;#x27;d be nicer if it explained what the problem
&amp;#x2F;&amp;#x2F; was, instead of just sometimes returning `None`. Thankfully, Rust has a similar
&amp;#x2F;&amp;#x2F; construct to `Option` that can be used to express error conditions. Let&amp;#x27;s use it!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint errors1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub fn generate_nametag_text(name: String) -&amp;gt; Option&amp;lt;String&amp;gt; {
    if name.is_empty() {
        &amp;#x2F;&amp;#x2F; Empty names aren&amp;#x27;t allowed.
        None
    } else {
        Some(format!(&amp;quot;Hi! My name is {}&amp;quot;, name))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generates_nametag_text_for_a_nonempty_name() {
        assert_eq!(
            generate_nametag_text(&amp;quot;BeyoncÃ©&amp;quot;.into()),
            Ok(&amp;quot;Hi! My name is BeyoncÃ©&amp;quot;.into())
        );
    }

    #[test]
    fn explains_why_generating_nametag_text_fails() {
        assert_eq!(
            generate_nametag_text(&amp;quot;&amp;quot;.into()),
            &amp;#x2F;&amp;#x2F; Don&amp;#x27;t change this line
            Err(&amp;quot;`name` was empty; it must be nonempty.&amp;quot;.into())
        );
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are to convert our &lt;code&gt;Option&lt;&#x2F;code&gt; to a &lt;code&gt;Result&lt;&#x2F;code&gt;, where we can change the the outcome, or rather specify an error as we like vs just returning &lt;code&gt;None&lt;&#x2F;code&gt; with an &lt;code&gt;Option&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;errors1-rs-errors&quot;&gt;errors1.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;error_handling&amp;#x2F;errors1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;error_handling&amp;#x2F;errors1.rs:25:9
   |
25 | &amp;#x2F;         assert_eq!(
26 | |             generate_nametag_text(&amp;quot;BeyoncÃ©&amp;quot;.into()),
27 | |             Ok(&amp;quot;Hi! My name is BeyoncÃ©&amp;quot;.into())
28 | |         );
   | |         ^
   | |         |
   | |_________expected `Option&amp;lt;String&amp;gt;`, found `Result&amp;lt;_, _&amp;gt;`
   |           expected because this is `Option&amp;lt;String&amp;gt;`
   |
   = note: expected enum `Option&amp;lt;String&amp;gt;`
              found enum `Result&amp;lt;_, _&amp;gt;`
   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;error_handling&amp;#x2F;errors1.rs:33:9
   |
33 | &amp;#x2F;         assert_eq!(
34 | |             generate_nametag_text(&amp;quot;&amp;quot;.into()),
35 | |             &amp;#x2F;&amp;#x2F; Don&amp;#x27;t change this line
36 | |             Err(&amp;quot;`name` was empty; it must be nonempty.&amp;quot;.into())
37 | |         );
   | |         ^
   | |         |
   | |_________expected `Option&amp;lt;String&amp;gt;`, found `Result&amp;lt;_, _&amp;gt;`
   |           expected because this is `Option&amp;lt;String&amp;gt;`
   |
   = note: expected enum `Option&amp;lt;String&amp;gt;`
              found enum `Result&amp;lt;_, _&amp;gt;`
   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our errors here are showing us that we have a mismatch with our types, since the tests are already expecting a &lt;code&gt;Result&lt;&#x2F;code&gt; but not the &lt;code&gt;Option&lt;&#x2F;code&gt; that is currently being used. So, let&#x27;s try and fix that, it doesn&#x27;t seem too difficult.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;errors1-rs-solution&quot;&gt;errors1.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s start by changing the return type, we know that it has to be a result, so let&#x27;s do that in the &lt;code&gt;generate_nametag_text&lt;&#x2F;code&gt; signature.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn generate_nametag_text(name: String) -&amp;gt; Result&amp;lt;String&amp;gt; {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The next thing we have to do is update the return value, because it&#x27;s going from returning one string to two, so instead of having one String in our &lt;code&gt;Result&lt;&#x2F;code&gt; we need two &lt;code&gt;Result&amp;lt;String, String&amp;gt;&lt;&#x2F;code&gt;, and because we&#x27;ve changed the type of from &lt;code&gt;Option&lt;&#x2F;code&gt; to &lt;code&gt;Result&lt;&#x2F;code&gt; we also have to update our &lt;code&gt;Some&lt;&#x2F;code&gt;
and &lt;code&gt;None&lt;&#x2F;code&gt; to what a &lt;code&gt;Result&lt;&#x2F;code&gt; should have which is &lt;code&gt;Ok&lt;&#x2F;code&gt; and &lt;code&gt;Err&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Our code now looks like this. Let&#x27;s save our file and see what our compiler says.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;

pub fn generate_nametag_text(name: String) -&amp;gt; Result&amp;lt;String, String&amp;gt; {
    if name.is_empty() {
        &amp;#x2F;&amp;#x2F; Empty names aren&amp;#x27;t allowed.
        Err
    } else {
        Ok(format!(&amp;quot;Hi! My name is {}&amp;quot;, name))
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Close but not quite, we see that we still have an error and it&#x27;s telling us that after our &lt;code&gt;Err&lt;&#x2F;code&gt; it&#x27;s expecting a value.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;error_handling&amp;#x2F;errors1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;error_handling&amp;#x2F;errors1.rs:13:9
   |
10 | pub fn generate_nametag_text(name: String) -&amp;gt; Result&amp;lt;String, String&amp;gt; {
   |                                               ---------------------- expected `Result&amp;lt;String, String&amp;gt;` because of return type
...
13 |         Err
   |         ^^^ expected `Result&amp;lt;String, String&amp;gt;`, found enum constructor
   |
   = note:          expected enum `Result&amp;lt;String, String&amp;gt;`
           found enum constructor `fn(_) -&amp;gt; Result&amp;lt;_, _&amp;gt; {Result::&amp;lt;_, _&amp;gt;::Err}`
help: use parentheses to construct this tuple variant
   |
13 |         Err(&amp;#x2F;* value *&amp;#x2F;)
   |            +++++++++++++

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler even shows us where to put the value:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;13 |         Err(&amp;#x2F;* value *&amp;#x2F;)
   |            +++++++++++++
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But what value should it be? ðŸ¤” Well in our case we can look at the test value and see what we are expected to write in there.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt; #[test]
    fn explains_why_generating_nametag_text_fails() {
        assert_eq!(
            generate_nametag_text(&amp;quot;&amp;quot;.into()),
            &amp;#x2F;&amp;#x2F; Don&amp;#x27;t change this line
            Err(&amp;quot;`name` was empty; it must be nonempty.&amp;quot;.into())
        );
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we can clearly see what the text should be that&#x27;s associated with the &lt;code&gt;Err&lt;&#x2F;code&gt;, so let&#x27;s add that to our code.&lt;&#x2F;p&gt;
&lt;p&gt;We use the same &lt;code&gt;format!&lt;&#x2F;code&gt; macro and it should look like this now:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn generate_nametag_text(name: String) -&amp;gt; Result&amp;lt;String, String&amp;gt; {
    if name.is_empty() {
        &amp;#x2F;&amp;#x2F; Empty names aren&amp;#x27;t allowed.
        Err(format!(&amp;quot;`name` was empty; it must be nonempty.&amp;quot;))
    } else {
        Ok(format!(&amp;quot;Hi! My name is {}&amp;quot;, name))
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and with that our code is compiling and our tests are passing:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;yay us.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;errors2-rs&quot;&gt;Errors2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; errors2.rs
&amp;#x2F;&amp;#x2F; Say we&amp;#x27;re writing a game where you can buy items with tokens. All items cost
&amp;#x2F;&amp;#x2F; 5 tokens, and whenever you purchase items there is a processing fee of 1
&amp;#x2F;&amp;#x2F; token. A player of the game will type in how many items they want to buy,
&amp;#x2F;&amp;#x2F; and the `total_cost` function will calculate the total number of tokens.
&amp;#x2F;&amp;#x2F; Since the player typed in the quantity, though, we get it as a string-- and
&amp;#x2F;&amp;#x2F; they might have typed anything, not just numbers!

&amp;#x2F;&amp;#x2F; Right now, this function isn&amp;#x27;t handling the error case at all (and isn&amp;#x27;t
&amp;#x2F;&amp;#x2F; handling the success case properly either). What we want to do is:
&amp;#x2F;&amp;#x2F; if we call the `parse` function on a string that is not a number, that
&amp;#x2F;&amp;#x2F; function will return a `ParseIntError`, and in that case, we want to
&amp;#x2F;&amp;#x2F; immediately return that error from our function and not try to multiply
&amp;#x2F;&amp;#x2F; and add.

&amp;#x2F;&amp;#x2F; There are at least two ways to implement this that are both correct-- but
&amp;#x2F;&amp;#x2F; one is a lot shorter!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint errors2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::num::ParseIntError;

pub fn total_cost(item_quantity: &amp;amp;str) -&amp;gt; Result&amp;lt;i32, ParseIntError&amp;gt; {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::&amp;lt;i32&amp;gt;();

    Ok(qty * cost_per_item + processing_fee)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn item_quantity_is_a_valid_number() {
        assert_eq!(total_cost(&amp;quot;34&amp;quot;), Ok(171));
    }

    #[test]
    fn item_quantity_is_an_invalid_number() {
        assert_eq!(
            total_cost(&amp;quot;beep boop&amp;quot;).unwrap_err().to_string(),
            &amp;quot;invalid digit found in string&amp;quot;
        );
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions tell us that the &lt;code&gt;total_cost&lt;&#x2F;code&gt; function is not handling the error case but also not handling the success case properly either. So what we want to is:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;if we call the &lt;code&gt;parse&lt;&#x2F;code&gt; function on a string that is not a number it will return an error and that case we want to immediately return that error from our function and not attempt to multiply and add.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We get the hint that we can do this correctly in a couple of ways and one of them is much shorter.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;errors2-rs-errors&quot;&gt;Errors2.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;error_handling&amp;#x2F;errors2.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0369]: cannot multiply `Result&amp;lt;i32, ParseIntError&amp;gt;` by `{integer}`
  --&amp;gt; exercises&amp;#x2F;error_handling&amp;#x2F;errors2.rs:29:12
   |
29 |     Ok(qty * cost_per_item + processing_fee)
   |        --- ^ ------------- {integer}
   |        |
   |        Result&amp;lt;i32, ParseIntError&amp;gt;

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Errors tell us that we cannot multiply &lt;code&gt;Results&amp;lt;i32, ParseIntError&amp;gt;&lt;&#x2F;code&gt; by &lt;code&gt;{integer}&lt;&#x2F;code&gt;. Alright let&#x27;s try to work on our solution.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;erros2-rs-solution&quot;&gt;Erros2.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;My gut tells me to use matching to set up the &lt;code&gt;Ok&lt;&#x2F;code&gt; and &lt;code&gt;Err&lt;&#x2F;code&gt;, let&#x27;s try:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn total_cost(item_quantity: &amp;amp;str) -&amp;gt; Result&amp;lt;i32, ParseIntError&amp;gt; {
    let processing_fee = 1;
    let cost_per_item = 5;
    &amp;#x2F;&amp;#x2F; adding `match` statement
    let qty = match item_quantity.parse::&amp;lt;i32&amp;gt;() {
	    Ok(qty) =&amp;gt; qty, &amp;#x2F;&amp;#x2F; matching `Ok`
	    Err(e) =&amp;gt; return Err(e), &amp;#x2F;&amp;#x2F; matching `Err`
    };

    Ok(qty * cost_per_item + processing_fee)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So,  we added &lt;code&gt;match&lt;&#x2F;code&gt; right before &lt;code&gt;item_quanity.parse::&amp;lt;i32&amp;gt;()&lt;&#x2F;code&gt; and then filled out the two match arms with &lt;code&gt;Ok&lt;&#x2F;code&gt; returning &lt;code&gt;qty&lt;&#x2F;code&gt; as an &lt;code&gt;int&lt;&#x2F;code&gt; and if it&#x27;s not an &lt;code&gt;int&lt;&#x2F;code&gt; then we match the &lt;code&gt;Err&lt;&#x2F;code&gt; arm and quit out of the process all together by using &lt;code&gt;return Err(e)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;But if we remember we also were given the idea that we could do this in two ways and although this wasn&#x27;t particularly long, is there a shorter way?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;errors2-rs-solution-2&quot;&gt;Errors2.rs solution 2&lt;&#x2F;h2&gt;
&lt;p&gt;Yes, there is! If we place a &lt;code&gt;?&lt;&#x2F;code&gt; operator after a &lt;code&gt;Result&lt;&#x2F;code&gt; value it functions in a similar way as a &lt;code&gt;match&lt;&#x2F;code&gt; statement, there is a difference but for the purposes it does the job just fine, so yea it&#x27;s a much much shorter way to handle this type of where a couple of lines of code are reduced to one character &lt;code&gt;?&lt;&#x2F;code&gt; .&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::num::ParseIntError;

pub fn total_cost(item_quantity: &amp;amp;str) -&amp;gt; Result&amp;lt;i32, ParseIntError&amp;gt; {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::&amp;lt;i32&amp;gt;()?;

    Ok(qty * cost_per_item + processing_fee)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;errors3-rs&quot;&gt;Errors3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; errors3.rs
&amp;#x2F;&amp;#x2F; This is a program that is trying to use a completed version of the
&amp;#x2F;&amp;#x2F; `total_cost` function from the previous exercise. It&amp;#x27;s not working though!
&amp;#x2F;&amp;#x2F; Why not? What should we do to fix it?
&amp;#x2F;&amp;#x2F; Execute `rustlings hint errors3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::num::ParseIntError;

fn main() {
    let mut tokens = 100;
    let pretend_user_input = &amp;quot;8&amp;quot;;

    let cost = total_cost(pretend_user_input)?;

    if cost &amp;gt; tokens {
        println!(&amp;quot;You can&amp;#x27;t afford that many!&amp;quot;);
    } else {
        tokens -= cost;
        println!(&amp;quot;You now have {} tokens.&amp;quot;, tokens);
    }
}

pub fn total_cost(item_quantity: &amp;amp;str) -&amp;gt; Result&amp;lt;i32, ParseIntError&amp;gt; {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::&amp;lt;i32&amp;gt;()?;

    Ok(qty * cost_per_item + processing_fee)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this exercise we are presented with &lt;code&gt;fn main()&lt;&#x2F;code&gt; which is trying to us our &lt;code&gt;fn total_cost&lt;&#x2F;code&gt; that we worked on in the previous exercise but there&#x27;s a problem and we have to figure out. So as always let&#x27;s look at our errors and see what we can learn there.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;errors3-rs-errors&quot;&gt;Errors3.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;error_handling&amp;#x2F;errors3.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
  --&amp;gt; exercises&amp;#x2F;error_handling&amp;#x2F;errors3.rs:15:46
   |
11 | fn main() {
   | --------- this function should return `Result` or `Option` to accept `?`
...
15 |     let cost = total_cost(pretend_user_input)?;
   |                                              ^ cannot use the `?` operator in a function that returns `()`
   |
   = help: the trait `FromResidual&amp;lt;Result&amp;lt;Infallible, ParseIntError&amp;gt;&amp;gt;` is not implemented for `()`

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our error seems quite obvious and the compiler does a great job of pointing it out. We&#x27;re trying to us the &lt;code&gt;?&lt;&#x2F;code&gt; operator, but we have no &lt;code&gt;Rusult&lt;&#x2F;code&gt; or &lt;code&gt;Option&lt;&#x2F;code&gt; to use it on since our &lt;code&gt;fn main()&lt;&#x2F;code&gt; does not define one in it&#x27;s signature, so let&#x27;s do that.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;errors3-rs-solution&quot;&gt;Errors3.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; updating `main` signature to return a result
fn main() -&amp;gt; Result&amp;lt;(), ParseIntError&amp;gt; {
    let mut tokens = 100;
    let pretend_user_input = &amp;quot;8&amp;quot;;

    let cost = total_cost(pretend_user_input)?;

    if cost &amp;gt; tokens {
        println!(&amp;quot;You can&amp;#x27;t afford that many!&amp;quot;);
    } else {
        tokens -= cost;
        println!(&amp;quot;You now have {} tokens.&amp;quot;, tokens);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So if you&#x27;ve read through the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;error&#x2F;result.html&quot;&gt;Rust by Example&lt;&#x2F;a&gt; provided in the Rustlings README (and above) you would see that we can return the &lt;code&gt;Result&lt;&#x2F;code&gt; type in &lt;code&gt;main&lt;&#x2F;code&gt; but it must be the &lt;code&gt;unit&lt;&#x2F;code&gt; &lt;code&gt;()&lt;&#x2F;code&gt; type.&lt;&#x2F;p&gt;
&lt;p&gt;Using &lt;code&gt;Result&amp;lt;(), ErrorType&amp;gt;&lt;&#x2F;code&gt; as the return type for the &lt;code&gt;main&lt;&#x2F;code&gt; function is a common pattern in Rust for error handling. It allows you to handle errors explicitly and propagate them up the call stack if necessary.&lt;&#x2F;p&gt;
&lt;p&gt;If the &lt;code&gt;main&lt;&#x2F;code&gt; function returns an &lt;code&gt;Err&lt;&#x2F;code&gt; value, it will be treated as an error by the Rust runtime, and the program will exit with a non-zero exit code.&lt;&#x2F;p&gt;
&lt;p&gt;Alright our code has a proper function signature let&#x27;s try and run this...Uh oh. Still not compiling we know get these erros.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;error_handling&amp;#x2F;errors3.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;error_handling&amp;#x2F;errors3.rs:17:22
   |
17 |       if cost &amp;gt; tokens {
   |  ______________________^
18 | |         println!(&amp;quot;You can&amp;#x27;t afford that many!&amp;quot;);
19 | |     } else {
   | |_____^ expected `Result&amp;lt;(), ParseIntError&amp;gt;`, found `()`
   |
   = note:   expected enum `Result&amp;lt;(), ParseIntError&amp;gt;`
           found unit type `()`

error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;error_handling&amp;#x2F;errors3.rs:19:12
   |
19 |       } else {
   |  ____________^
20 | |         tokens -= cost;
21 | |         println!(&amp;quot;You now have {} tokens.&amp;quot;, tokens);
22 | |     }
   | |_____^ expected `Result&amp;lt;(), ParseIntError&amp;gt;`, found `()`
   |
   = note:   expected enum `Result&amp;lt;(), ParseIntError&amp;gt;`
           found unit type `()`

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This error is telling us that there are type mismatches in the &lt;code&gt;main&lt;&#x2F;code&gt; function of the &lt;code&gt;errors3.rs&lt;&#x2F;code&gt; file. Specifically, the &lt;code&gt;if&lt;&#x2F;code&gt; and &lt;code&gt;else&lt;&#x2F;code&gt; blocks have different return types: the &lt;code&gt;if&lt;&#x2F;code&gt; block should return &lt;code&gt;Result&amp;lt;(), ParseIntError&amp;gt;&lt;&#x2F;code&gt;, but it&#x27;s returning &lt;code&gt;()&lt;&#x2F;code&gt;, which is a unit type. The compiler is expecting both branches to return a &lt;code&gt;Result&lt;&#x2F;code&gt; with the same error type, but it found a unit type instead.&lt;&#x2F;p&gt;
&lt;p&gt;So how do we fix this? To follow the rules of the &lt;code&gt;Result&lt;&#x2F;code&gt; type in the &lt;code&gt;main&lt;&#x2F;code&gt; function, we use &lt;code&gt;return Ok(())&lt;&#x2F;code&gt; in both the &lt;code&gt;if&lt;&#x2F;code&gt; and &lt;code&gt;else&lt;&#x2F;code&gt; blocks to indicate success, even though the &lt;code&gt;if&lt;&#x2F;code&gt; block deals with a case where the user can&#x27;t afford the items. This way, the compiler knows that we are handling the error properly and can ensure the code is correct.&lt;&#x2F;p&gt;
&lt;p&gt;Our &lt;code&gt;main()&lt;&#x2F;code&gt; should now look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() -&amp;gt; Result&amp;lt;(), ParseIntError&amp;gt; {
    let mut tokens = 100;
    let pretend_user_input = &amp;quot;8&amp;quot;;

    let cost = total_cost(pretend_user_input)?;

    if cost &amp;gt; tokens {
        println!(&amp;quot;You can&amp;#x27;t afford that many!&amp;quot;);
        return Ok(()); &amp;#x2F;&amp;#x2F; adding the Ok(()) return value
    } else {
        tokens -= cost;
        println!(&amp;quot;You now have {} tokens.&amp;quot;, tokens);
        return Ok(()); &amp;#x2F;&amp;#x2F; adding the Ok(()) return value
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the given block of code, there is no need to contain an &lt;code&gt;Err&lt;&#x2F;code&gt; section because the &lt;code&gt;total_cost&lt;&#x2F;code&gt; function is already responsible for handling errors related to parsing the input string into an integer. The &lt;code&gt;total_cost&lt;&#x2F;code&gt; function has the return type &lt;code&gt;Result&amp;lt;i32, ParseIntError&amp;gt;&lt;&#x2F;code&gt;, and it uses the &lt;code&gt;?&lt;&#x2F;code&gt; operator to propagate the error when parsing fails.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;?&lt;&#x2F;code&gt; operator in the &lt;code&gt;total_cost&lt;&#x2F;code&gt; function allows the error to be returned immediately from the function if there is a parsing error. The calling code in the &lt;code&gt;main&lt;&#x2F;code&gt; function does not need to handle the &lt;code&gt;Err&lt;&#x2F;code&gt; case again because it is already being handled in the &lt;code&gt;total_cost&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;p&gt;To put it in simpler terms, the &lt;code&gt;total_cost&lt;&#x2F;code&gt; function is like a &amp;quot;guard&amp;quot; that ensures that the parsing is successful. If there is an error, it will return the error to the calling code (the &lt;code&gt;main&lt;&#x2F;code&gt; function in this case). Since the &lt;code&gt;total_cost&lt;&#x2F;code&gt; function already handles the error, the &lt;code&gt;main&lt;&#x2F;code&gt; function doesn&#x27;t need to worry about it. Instead, it only needs to deal with the case where parsing is successful (&lt;code&gt;Ok&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;So, in this particular case, we don&#x27;t need an &lt;code&gt;Err&lt;&#x2F;code&gt; section in the &lt;code&gt;main&lt;&#x2F;code&gt; function because the error handling is taken care of by the &lt;code&gt;total_cost&lt;&#x2F;code&gt; function. The &lt;code&gt;main&lt;&#x2F;code&gt; function only needs to handle the successful case (&lt;code&gt;Ok&lt;&#x2F;code&gt;), and if the parsing is successful, it will proceed with the code inside the &lt;code&gt;else&lt;&#x2F;code&gt; block. If parsing fails, the error will be propagated and handled by Rust automatically.&lt;&#x2F;p&gt;
&lt;p&gt;When we save we get this output:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Output:
====================
You now have 59 tokens.

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion-of-part-1&quot;&gt;Conclusion of Part 1&lt;&#x2F;h2&gt;
&lt;p&gt;In this first part of the Rustlings error handling exercises, we learned about using &lt;code&gt;Result&lt;&#x2F;code&gt; and &lt;code&gt;Option&lt;&#x2F;code&gt; types to handle errors and cases where there might not be a valid value. We encountered different scenarios and learned how to convert functions returning &lt;code&gt;Option&lt;&#x2F;code&gt; into ones returning &lt;code&gt;Result&lt;&#x2F;code&gt; to provide more specific error messages. Additionally, we saw how to use the &lt;code&gt;?&lt;&#x2F;code&gt; operator to propagate errors up the call stack automatically, simplifying the error handling process.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s essential to handle errors properly in Rust, as it ensures that your program remains robust and can gracefully recover from unexpected situations. Using &lt;code&gt;Result&lt;&#x2F;code&gt; and &lt;code&gt;Option&lt;&#x2F;code&gt; types, along with pattern matching and the &lt;code&gt;?&lt;&#x2F;code&gt; operator, we can create code that is not only correct but also more readable and maintainable. Rust&#x27;s strong type system helps catch errors at compile time and guides us in writing safer and more reliable software.&lt;&#x2F;p&gt;
&lt;p&gt;In the next part of the error handling exercises, we will delve deeper into handling different types of errors, exploring how to use &lt;code&gt;Result&lt;&#x2F;code&gt; with custom error types and how to combine and chain errors effectively. Keep learning and practicing, and happy coding!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>14 Rustlings Options</title>
          <pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/14-rustlings-options/</link>
          <guid>https://desmodrone.github.io/posts/14-rustlings-options/</guid>
          <description xml:base="https://desmodrone.github.io/posts/14-rustlings-options/">&lt;h1 id=&quot;options&quot;&gt;Options&lt;&#x2F;h1&gt;
&lt;h5 id=&quot;from-the-rustlings-readme&quot;&gt;From the Rustlings README&lt;&#x2F;h5&gt;
&lt;p&gt;Type Option represents an optional value: every Option is either Some and contains a value, or None, and does not.
Option types are very common in Rust code, as they have a number of uses:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Initial values&lt;&#x2F;li&gt;
&lt;li&gt;Return values for functions that are not defined over their entire input range (partial functions)&lt;&#x2F;li&gt;
&lt;li&gt;Return value for otherwise reporting simple errors, where None is returned on error&lt;&#x2F;li&gt;
&lt;li&gt;Optional struct fields&lt;&#x2F;li&gt;
&lt;li&gt;Struct fields that can be loaned or &amp;quot;taken&amp;quot;&lt;&#x2F;li&gt;
&lt;li&gt;Optional function arguments&lt;&#x2F;li&gt;
&lt;li&gt;Nullable pointers&lt;&#x2F;li&gt;
&lt;li&gt;Swapping things out of difficult situations&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further Information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch10-01-syntax.html#in-enum-definitions&quot;&gt;Option Enum Format&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;option&#x2F;&quot;&gt;Option Module Documentation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;option&#x2F;enum.Option.html&quot;&gt;Option Enum Documentation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;flow_control&#x2F;if_let.html&quot;&gt;if let&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;flow_control&#x2F;while_let.html&quot;&gt;while let&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;options1-rs&quot;&gt;Options1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; options1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint options1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

&amp;#x2F;&amp;#x2F; This function returns how much icecream there is left in the fridge.
&amp;#x2F;&amp;#x2F; If it&amp;#x27;s before 10PM, there&amp;#x27;s 5 pieces left. At 10PM, someone eats them
&amp;#x2F;&amp;#x2F; all, so there&amp;#x27;ll be no more left :(
fn maybe_icecream(time_of_day: u16) -&amp;gt; Option&amp;lt;u16&amp;gt; {
    &amp;#x2F;&amp;#x2F; We use the 24-hour system here, so 10PM is a value of 22 and 12AM is a value of 0
    &amp;#x2F;&amp;#x2F; The Option output should gracefully handle cases where time_of_day &amp;gt; 23.
    &amp;#x2F;&amp;#x2F; TODO: Complete the function body - remember to return an Option!
    ???
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn check_icecream() {
        assert_eq!(maybe_icecream(9), Some(5));
        assert_eq!(maybe_icecream(10), Some(5));
        assert_eq!(maybe_icecream(23), Some(0));
        assert_eq!(maybe_icecream(22), Some(0));
        assert_eq!(maybe_icecream(25), None);
    }

    #[test]
    fn raw_value() {
        &amp;#x2F;&amp;#x2F; TODO: Fix this test. How do you get at the value contained in the Option?
        let icecreams = maybe_icecream(12);
        assert_eq!(icecreams, 5);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions in this exercise are to create the logic in the &lt;code&gt;maybe_icecream&lt;&#x2F;code&gt; body which should tell us how much ice cream is left depending on the time of day -- for example if it&#x27;s 9pm there should be some ice cream but if it&#x27;s 11pm there should be no ice-cream. Next, we have to fix the text so we get the value that is contained inside of the Option.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;options1-rs-errors&quot;&gt;Options1.rs Errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;options&amp;#x2F;options1.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;options&amp;#x2F;options1.rs:13:5
   |
13 |     ???
   |     ^ expected expression

error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;options&amp;#x2F;options1.rs:33:9
   |
33 |         assert_eq!(icecreams, 5);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         expected enum `Option`, found integer
   |         expected because this is `Option&amp;lt;u16&amp;gt;`
   |
   = note: expected enum `Option&amp;lt;u16&amp;gt;`
              found type `{integer}`
   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)
help: try wrapping the expression in `Some`
  --&amp;gt; &amp;#x2F;Users&amp;#x2F;desmo&amp;#x2F;.rustup&amp;#x2F;toolchains&amp;#x2F;stable-aarch64-apple-darwin&amp;#x2F;lib&amp;#x2F;rustlib&amp;#x2F;src&amp;#x2F;rust&amp;#x2F;library&amp;#x2F;core&amp;#x2F;src&amp;#x2F;macros&amp;#x2F;mod.rs:40:35
   |
40 |                 if !(*left_val == Some(*right_val)) {
   |                                   +++++          +

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There are some clear hints on how to fix this issues in the errors&lt;&#x2F;p&gt;
&lt;h2 id=&quot;options1-rs-solution&quot;&gt;Options1.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;Looking at the errors the Rust compiler offers a direct hint for how to solve the test. Let&#x27;s tackle that one first since it looks super easy the compiler we fix it by wrapping our value in &lt;code&gt;Some()&lt;&#x2F;code&gt; as suggested like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;  #[test]
    fn raw_value() {
        &amp;#x2F;&amp;#x2F; TODO: Fix this test. How do you get at the value contained in the Option?
        let icecreams = maybe_icecream(12);
        assert_eq!(icecreams, Some(5));
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This fixes the issue in our test, now on to the &lt;code&gt;maybe_icecream&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;maybe-ice-cream&quot;&gt;Maybe Ice Cream&lt;&#x2F;h3&gt;
&lt;p&gt;So our instructions are to return the amount of ice cream left in the fridge. So from this we understand that we have to return a value as an &lt;code&gt;Option&amp;lt;u16&amp;gt;&lt;&#x2F;code&gt; by looking at the function signature. So, in the next sentence we get a big hint as to the type of function body we have to write because the instructions start with an &amp;quot;If&amp;quot; meaning we should be able to use a &lt;code&gt;If&lt;&#x2F;code&gt; statement in our function body. Let&#x27;s see what that could look like. In pseudo code:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;if time of day is &amp;lt; 10pm
	then 5
if time of day &amp;gt; 10pm
	then 0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now, I started implementing this pseudo code but then realized that we actually have to pass 3 different test cases. Let&#x27;s write this in the 24 hour clock system because it&#x27;s easier.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Before 22&lt;&#x2F;li&gt;
&lt;li&gt;After 22 or 23&lt;&#x2F;li&gt;
&lt;li&gt;Something else: 25&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;For item 3, we can see it explicitly stated in our test code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    fn check_icecream() {
        assert_eq!(maybe_icecream(9), Some(5));
        assert_eq!(maybe_icecream(10), Some(5));
        assert_eq!(maybe_icecream(23), Some(0));
        assert_eq!(maybe_icecream(22), Some(0));
        assert_eq!(maybe_icecream(25), None);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So now, we know that we have to cover three different test cases &lt;code&gt;Some(5)&lt;&#x2F;code&gt;, &lt;code&gt;Some(0)&lt;&#x2F;code&gt; and &lt;code&gt;None&lt;&#x2F;code&gt;.  Let&#x27;s implement this in Rust, keeping in mind the  instructions to use a 24 clock system.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn maybe_icecream(time_of_day: u16) -&amp;gt; Option&amp;lt;u16&amp;gt; {
    if time_of_day &amp;lt; 22 {
        Some(5)
    } else if time_of_day == 22 || time_of_day == 23 {
        Some(0)
    } else {
        None
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;using-match&quot;&gt;Using &lt;code&gt;match&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Another way to solve this problem in a more concise way would be to use a match statement and that could look something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn maybe_icecream(time_of_day: u16) -&amp;gt; Option&amp;lt;u16&amp;gt; {
    match time_of_day {
        0..=21 =&amp;gt; Some(5),
        22..=23 =&amp;gt; Some(0),
        _ =&amp;gt; None,
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;as you can see this is cleaner way of implementing a solution that handles all of our cases. Remember when using ranges you can use the &lt;code&gt;..=&lt;&#x2F;code&gt; to include the element in the range so in our case &lt;code&gt;0...=21&lt;&#x2F;code&gt; means from midnight to 9pm, and &lt;code&gt;22..=23&lt;&#x2F;code&gt; means from 10pm to 11pm.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;options2-rs&quot;&gt;Options2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; options2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint options2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[cfg(test)]
mod tests {
    #[test]
    fn simple_option() {
        let target = &amp;quot;rustlings&amp;quot;;
        let optional_target = Some(target);

        &amp;#x2F;&amp;#x2F; TODO: Make this an if let statement whose value is &amp;quot;Some&amp;quot; type
        if let Some(word) = optional_target {
            assert_eq!(word, target);
        }
    }

    #[test]
    fn layered_option() {
        let mut range = 10;
        let mut optional_integers: Vec&amp;lt;Option&amp;lt;i8&amp;gt;&amp;gt; = Vec::new();
        for i in 0..(range + 1) {
            optional_integers.push(Some(i));
        }

        &amp;#x2F;&amp;#x2F; TODO: make this a while let statement - remember that vector.pop also adds another layer of Option&amp;lt;T&amp;gt;
        &amp;#x2F;&amp;#x2F; You can stack `Option&amp;lt;T&amp;gt;`&amp;#x27;s into while let and if let
        integer = optional_integers.pop() {
            assert_eq!(integer, range);
            range -= 1;
        }
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have a couple of TODO&#x27;s here one in the &lt;code&gt;simple_option&lt;&#x2F;code&gt; function that asks us to use a &lt;code&gt;if let&lt;&#x2F;code&gt; statement and then the next on the list asks for a &lt;code&gt;while let&lt;&#x2F;code&gt; statement with a reminder that using &lt;code&gt;vector.pop&lt;&#x2F;code&gt; also adds another layer of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;, noting that we can &#x27;stack&#x27; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;&#x27;s when using &lt;code&gt;while let&lt;&#x2F;code&gt; and &lt;code&gt;if let&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;options2-rs-errors&quot;&gt;Options2.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;options&amp;#x2F;options2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected one of `,`, `:`, or `}`, found `!`
  --&amp;gt; exercises&amp;#x2F;options&amp;#x2F;options2.rs:15:22
   |
14 |         word = optional_target {
   |                --------------- while parsing this struct
15 |             assert_eq!(word, target);
   |                      ^ expected one of `,`, `:`, or `}`

error: expected one of `,`, `:`, or `}`, found `)`
  --&amp;gt; exercises&amp;#x2F;options&amp;#x2F;options2.rs:15:36
   |
14 |         word = optional_target {
   |                --------------- while parsing this struct
15 |             assert_eq!(word, target);
   |                                    ^ expected one of `,`, `:`, or `}`

error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`
  --&amp;gt; exercises&amp;#x2F;options&amp;#x2F;options2.rs:29:43
   |
29 |         integer = optional_integers.pop() {
   |                                           ^ expected one of `.`, `;`, `?`, `}`, or an operator

error[E0425]: cannot find value `word` in this scope
  --&amp;gt; exercises&amp;#x2F;options&amp;#x2F;options2.rs:14:9
   |
14 |         word = optional_target {
   |         ^^^^
   |
help: you might have meant to introduce a new binding
   |
14 |         let word = optional_target {
   |         +++

error[E0574]: expected struct, variant or union type, found local variable `optional_target`
  --&amp;gt; exercises&amp;#x2F;options&amp;#x2F;options2.rs:14:16
   |
14 |         word = optional_target {
   |                ^^^^^^^^^^^^^^^ not a struct, variant or union type

error: aborting due to 5 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The error&#x27;s don&#x27;t give us a lot of a lot of hints in this case other letting us know that we probably want to introduce a new binding at line 14. So let&#x27;s start there.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;options2-rs-solution&quot;&gt;Options2.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;Using &lt;code&gt;if let&lt;&#x2F;code&gt; bindings allow us to sort of use a match statement, that is less awkward in cases where there is only one correct outcome and we&#x27;d have to use &lt;code&gt;_&lt;&#x2F;code&gt; to be exhaustive. which would lead to some cluncky code like in this example from &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;flow_control&#x2F;if_let.html&quot;&gt;Rust by Example&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Make `optional` of type `Option&amp;lt;i32&amp;gt;`
let optional = Some(7);

match optional {
    Some(i) =&amp;gt; {
        println!(&amp;quot;This is a really long string and `{:?}`&amp;quot;, i);
        &amp;#x2F;&amp;#x2F; ^ Needed 2 indentations just so we could destructure
        &amp;#x2F;&amp;#x2F; `i` from the option.
    },
    _ =&amp;gt; {},
    &amp;#x2F;&amp;#x2F; ^ Required because `match` is exhaustive. Doesn&amp;#x27;t it seem
    &amp;#x2F;&amp;#x2F; like wasted space?
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So let&#x27;s try using &lt;code&gt;if let&lt;&#x2F;code&gt; on our first TODO.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;if let Some(word) = optional_target { &amp;#x2F;&amp;#x2F; binding with `if let` wrapping `word` with Some
	assert_eq!(word, target);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this we can save and see how our error&#x27;s look.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;options&amp;#x2F;options2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`
  --&amp;gt; exercises&amp;#x2F;options&amp;#x2F;options2.rs:29:43
   |
29 |         integer = optional_integers.pop() {
   |                                           ^ expected one of `.`, `;`, `?`, `}`, or an operator

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Okay we went from 5 error&#x27;s to 1, great let&#x27;s work on that next part of the code with &lt;code&gt;while let&lt;&#x2F;code&gt;. Similar to &lt;code&gt;if let&lt;&#x2F;code&gt; using &lt;code&gt;while let&lt;&#x2F;code&gt; can make matching sequences easier to use in this case in a loop type setting. So let&#x27;s try and implement the solution in the same way we did with the &lt;code&gt;if let&lt;&#x2F;code&gt; binding.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;        &amp;#x2F;&amp;#x2F; TODO: make this a while let statement - remember that vector.pop also adds another layer of Option&amp;lt;T&amp;gt;
        &amp;#x2F;&amp;#x2F; You can stack `Option&amp;lt;T&amp;gt;`&amp;#x27;s into while let and if let
        while let Some(integer) = optional_integers.pop() {
            assert_eq!(integer, range);
            range -= 1;
        }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s see what happens...wait there&#x27;s an error&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;options&amp;#x2F;options2.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;options&amp;#x2F;options2.rs:30:13
   |
30 |             assert_eq!(integer, range);
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
   |             |
   |             expected `Option&amp;lt;i8&amp;gt;`, found `i8`
   |             expected because this is `Option&amp;lt;i8&amp;gt;`
   |
   = note: expected enum `Option&amp;lt;i8&amp;gt;`
              found type `i8`
   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)
help: try wrapping the expression in `Some`
  --&amp;gt; &amp;#x2F;Users&amp;#x2F;desmo&amp;#x2F;.rustup&amp;#x2F;toolchains&amp;#x2F;stable-aarch64-apple-darwin&amp;#x2F;lib&amp;#x2F;rustlib&amp;#x2F;src&amp;#x2F;rust&amp;#x2F;library&amp;#x2F;core&amp;#x2F;src&amp;#x2F;macros&amp;#x2F;mod.rs:40:35
   |
40 |                 if !(*left_val == Some(*right_val)) {
   |                                   +++++          +

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler is telling us that it expects an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;&#x2F;code&gt; but it&#x27;s finding an &lt;code&gt;i8&lt;&#x2F;code&gt;...interesting. But wait let&#x27;s look at that TODO comment: &lt;code&gt;remember that vector.pop also adds another layer of Option&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; there it is. There&#x27;s another layer of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; that&#x27;s created with &lt;code&gt;vector.pop&lt;&#x2F;code&gt; so does that mean that we have to wrap our &lt;code&gt;Some()&lt;&#x2F;code&gt; with &lt;code&gt;Some()&lt;&#x2F;code&gt;? Let&#x27;s try.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;while let Some(Some(integer)) = optional_integers.pop() {
            assert_eq!(integer, range);
            range -= 1;
        }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Success! This is our output&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âœ… Successfully tested exercises&amp;#x2F;options&amp;#x2F;options2.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s move on to our final Option exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;options3-rs&quot;&gt;Options3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; options3.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint options3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let y: Option&amp;lt;Point&amp;gt; = Some(Point { x: 100, y: 200 });

    match y {
        Some(p) =&amp;gt; println!(&amp;quot;Co-ordinates are {},{} &amp;quot;, p.x, p.y),
        _ =&amp;gt; println!(&amp;quot;no match&amp;quot;),
    }
    y; &amp;#x2F;&amp;#x2F; Fix without deleting this line.
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;re not getting a lot of instruction here but we&#x27;re being told to fix this code without removing the &lt;code&gt;y;&lt;&#x2F;code&gt; on line 18. Let&#x27;s take a look at the errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;options3-rs-errors&quot;&gt;Options3.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;options&amp;#x2F;options3.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0382]: use of partially moved value: `y`
  --&amp;gt; exercises&amp;#x2F;options&amp;#x2F;options3.rs:18:5
   |
15 |         Some(p) =&amp;gt; println!(&amp;quot;Co-ordinates are {},{} &amp;quot;, p.x, p.y),
   |              - value partially moved here
...
18 |     y; &amp;#x2F;&amp;#x2F; Fix without deleting this line.
   |     ^ value used here after partial move
   |
   = note: partial move occurs because value has type `Point`, which does not implement the `Copy` trait
help: borrow this binding in the pattern to avoid moving the value
   |
15 |         Some(ref p) =&amp;gt; println!(&amp;quot;Co-ordinates are {},{} &amp;quot;, p.x, p.y),
   |              +++

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this case we get a big hint as to what is going on with the code and a very direct suggestion as to how to fix it it, let&#x27;s see what happens if we implement the compiler suggestion.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let y: Option&amp;lt;Point&amp;gt; = Some(Point { x: 100, y: 200 });

    match y {
        Some(ref p) =&amp;gt; println!(&amp;quot;Co-ordinates are {},{} &amp;quot;, p.x, p.y), &amp;#x2F;&amp;#x2F; adding `ref`
        _ =&amp;gt; println!(&amp;quot;no match&amp;quot;),
    }
    y; &amp;#x2F;&amp;#x2F; Fix without deleting this line.
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;...and it compiles! Easy enough but let&#x27;s take a deeper look at this, what is this &lt;code&gt;ref&lt;&#x2F;code&gt; and is it the same as &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt;?&lt;&#x2F;p&gt;
&lt;p&gt;So first let&#x27;s understand a little bit more about what is happening in this code and when we should use &lt;code&gt;ref&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In Rust, the &lt;code&gt;ref&lt;&#x2F;code&gt; keyword is used in patterns to create a reference to a value instead of moving it. This is particularly useful when dealing with non-&lt;code&gt;Copy&lt;&#x2F;code&gt; types (types that don&#x27;t implement the &lt;code&gt;Copy&lt;&#x2F;code&gt; trait) to avoid moving the value out of its original location, which would leave the original variable uninitialized or unusable.&lt;&#x2F;p&gt;
&lt;p&gt;When pattern matching on a non-&lt;code&gt;Copy&lt;&#x2F;code&gt; value, Rust requires us to either move the value or borrow it explicitly. The &lt;code&gt;ref&lt;&#x2F;code&gt; keyword helps us create a reference to the value instead of moving it.&lt;&#x2F;p&gt;
&lt;p&gt;In our error message, the compiler is complaining about a partially moved value, specifically the variable &lt;code&gt;y&lt;&#x2F;code&gt;, which is of type &lt;code&gt;Point&lt;&#x2F;code&gt;. Since &lt;code&gt;Point&lt;&#x2F;code&gt; does not implement the &lt;code&gt;Copy&lt;&#x2F;code&gt; trait, the pattern matching on &lt;code&gt;Some(p)&lt;&#x2F;code&gt; is attempting to move the value of &lt;code&gt;p&lt;&#x2F;code&gt;, causing a partial move of the variable &lt;code&gt;y&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;With &lt;code&gt;ref p&lt;&#x2F;code&gt;, we are now creating a reference to the &lt;code&gt;Point&lt;&#x2F;code&gt; value inside the &lt;code&gt;Some&lt;&#x2F;code&gt; variant, which avoids the move and allows you to access the &lt;code&gt;x&lt;&#x2F;code&gt; and &lt;code&gt;y&lt;&#x2F;code&gt; fields without any issues.&lt;&#x2F;p&gt;
&lt;p&gt;Remember that we need to use &lt;code&gt;ref&lt;&#x2F;code&gt; in the pattern for non-&lt;code&gt;Copy&lt;&#x2F;code&gt; types when matching on references. When using &lt;code&gt;ref&lt;&#x2F;code&gt;, you are borrowing the value, and if we don&#x27;t use &lt;code&gt;ref&lt;&#x2F;code&gt;, you are moving the value out of the original variable. This is crucial to understand when dealing with non-&lt;code&gt;Copy&lt;&#x2F;code&gt; types in pattern matching.&lt;&#x2F;p&gt;
&lt;p&gt;Alright, but what was the difference between &lt;code&gt;ref&lt;&#x2F;code&gt; and &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; again?&lt;&#x2F;p&gt;
&lt;p&gt;Using &lt;code&gt;ref&lt;&#x2F;code&gt; in a pattern and using &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; in a pattern are related concepts but serve slightly different purposes in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Using &lt;code&gt;ref&lt;&#x2F;code&gt; in a pattern:
- The &lt;code&gt;ref&lt;&#x2F;code&gt; keyword is used in pattern matching to create a reference to a value inside a pattern. It allows you to match on the reference to the value rather than moving the value out of the original variable.
- It is particularly useful when dealing with non-&lt;code&gt;Copy&lt;&#x2F;code&gt; types, as it allows you to borrow the value instead of moving it, preserving the original variable&#x27;s ownership.
- &lt;code&gt;ref&lt;&#x2F;code&gt; can only be used in patterns, specifically in match arms or when destructuring tuples or structs.&lt;&#x2F;p&gt;
&lt;p&gt;Our example code using &lt;code&gt;ref&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct Point {
    x: i32,
    y: i32,
}

fn print_coordinates(point: Option&amp;lt;Point&amp;gt;) {
    match point {
        Some(ref p) =&amp;gt; println!(&amp;quot;Co-ordinates are {},{} &amp;quot;, p.x, p.y),
        None =&amp;gt; println!(&amp;quot;No point found!&amp;quot;),
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Using &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; in a pattern:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; symbol in a pattern is used to destructure a reference. It allows you to match on the value being referenced instead of matching on the reference itself.&lt;&#x2F;li&gt;
&lt;li&gt;It is commonly used when working with references to allow pattern matching without consuming the reference.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; can also be used in match arms and when destructuring tuples or structs, just like &lt;code&gt;ref&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Example using &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn print_coordinates_ref(point: Option&amp;lt;&amp;amp;Point&amp;gt;) {
    match point {
        Some(p) =&amp;gt; println!(&amp;quot;Co-ordinates are {},{} &amp;quot;, p.x, p.y),
        None =&amp;gt; println!(&amp;quot;No point found!&amp;quot;),
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the first example, we use &lt;code&gt;ref&lt;&#x2F;code&gt; to match on the &lt;code&gt;Point&lt;&#x2F;code&gt; value by creating a reference &lt;code&gt;&amp;amp;Point&lt;&#x2F;code&gt; and avoid moving the original value out of the &lt;code&gt;Option&lt;&#x2F;code&gt;. In the second example, we take a reference as an argument to the function and use &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; to destructure the reference and match on the underlying &lt;code&gt;Point&lt;&#x2F;code&gt; value.&lt;&#x2F;p&gt;
&lt;p&gt;Both &lt;code&gt;ref&lt;&#x2F;code&gt; and &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; in patterns are essential tools when working with pattern matching and references in Rust. They allow you to control ownership and borrowing behavior while pattern matching on non-&lt;code&gt;Copy&lt;&#x2F;code&gt; types.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In conclusion, the Rust &lt;code&gt;Option&lt;&#x2F;code&gt; type is a fundamental concept that plays a crucial role in handling optional values in Rust code. It provides a safe and elegant way to deal with scenarios where a value may or may not be present. With &lt;code&gt;Option&lt;&#x2F;code&gt;, Rust encourages developers to handle potential absence of values explicitly, reducing the risk of null-related errors that are prevalent in other programming languages.&lt;&#x2F;p&gt;
&lt;p&gt;Throughout this blog post, we explored the versatility of &lt;code&gt;Option&lt;&#x2F;code&gt; and its various applications in Rust code. We learned that &lt;code&gt;Option&lt;&#x2F;code&gt; is commonly used for representing initial values, handling partial functions, reporting errors, working with optional struct fields, and more.&lt;&#x2F;p&gt;
&lt;p&gt;In addition to understanding the basics of &lt;code&gt;Option&lt;&#x2F;code&gt;, we also explored important Rust concepts like pattern matching, &lt;code&gt;if let&lt;&#x2F;code&gt;, and &lt;code&gt;while let&lt;&#x2F;code&gt;. These powerful language features allow us to handle &lt;code&gt;Option&lt;&#x2F;code&gt; values efficiently, making our code concise and expressive.&lt;&#x2F;p&gt;
&lt;p&gt;When working with non-&lt;code&gt;Copy&lt;&#x2F;code&gt; types, we encountered the use of &lt;code&gt;ref&lt;&#x2F;code&gt; in patterns, which creates a reference to the value, preventing it from being moved. This is particularly useful when matching on references to avoid unnecessary ownership transfers.&lt;&#x2F;p&gt;
&lt;p&gt;Furthermore, we compared &lt;code&gt;ref&lt;&#x2F;code&gt; with using &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; in patterns, noting that both have distinct purposes. While &lt;code&gt;ref&lt;&#x2F;code&gt; is primarily used for pattern matching, &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; is used for destructuring references.&lt;&#x2F;p&gt;
&lt;p&gt;In summary, mastering the Rust &lt;code&gt;Option&lt;&#x2F;code&gt; type and related language features empowers developers to write robust, safe, and efficient code. Embracing the principles of handling optional values in Rust not only improves code quality but also fosters better programming practices. By avoiding null-related issues, Rust&#x27;s &lt;code&gt;Option&lt;&#x2F;code&gt; encourages developers to write more reliable software, making Rust a language of choice for projects requiring high-level safety and correctness guarantees.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>13 Rustlings Quiz2</title>
          <pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/13-rustlings-quiz2/</link>
          <guid>https://desmodrone.github.io/posts/13-rustlings-quiz2/</guid>
          <description xml:base="https://desmodrone.github.io/posts/13-rustlings-quiz2/">&lt;h2 id=&quot;quiz-2&quot;&gt;Quiz 2&lt;&#x2F;h2&gt;
&lt;p&gt;It&#x27;s quiz time again! We&#x27;ve been through a bunch of different exercises and now we&#x27;ll be putting in action what we&#x27;ve learned.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;quiz2-rs&quot;&gt;quiz2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; quiz2.rs
&amp;#x2F;&amp;#x2F; This is a quiz for the following sections:
&amp;#x2F;&amp;#x2F; - Strings
&amp;#x2F;&amp;#x2F; - Vecs
&amp;#x2F;&amp;#x2F; - Move semantics
&amp;#x2F;&amp;#x2F; - Modules
&amp;#x2F;&amp;#x2F; - Enums

&amp;#x2F;&amp;#x2F; Let&amp;#x27;s build a little machine in the form of a function.
&amp;#x2F;&amp;#x2F; As input, we&amp;#x27;re going to give a list of strings and commands. These commands
&amp;#x2F;&amp;#x2F; determine what action is going to be applied to the string. It can either be:
&amp;#x2F;&amp;#x2F; - Uppercase the string
&amp;#x2F;&amp;#x2F; - Trim the string
&amp;#x2F;&amp;#x2F; - Append &amp;quot;bar&amp;quot; to the string a specified amount of times
&amp;#x2F;&amp;#x2F; The exact form of this will be:
&amp;#x2F;&amp;#x2F; - The input is going to be a Vector of a 2-length tuple,
&amp;#x2F;&amp;#x2F;   the first element is the string, the second one is the command.
&amp;#x2F;&amp;#x2F; - The output element is going to be a Vector of strings.
&amp;#x2F;&amp;#x2F; No hints this time!

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub enum Command {
    Uppercase,
    Trim,
    Append(usize),
}

mod my_module {
    use super::Command;

    &amp;#x2F;&amp;#x2F; TODO: Complete the function signature!
    pub fn transformer(input: ???) -&amp;gt; ??? {
        &amp;#x2F;&amp;#x2F; TODO: Complete the output declaration!
        let mut output: ??? = vec![];
        for (string, command) in input.iter() {
            &amp;#x2F;&amp;#x2F; TODO: Complete the function body. You can do it!
        }
        output
    }
}

#[cfg(test)]
mod tests {
    &amp;#x2F;&amp;#x2F; TODO: What do we need to import to have `transformer` in scope?
    use ???;
    use super::Command;

    #[test]
    fn it_works() {
        let output = transformer(vec![
            (&amp;quot;hello&amp;quot;.into(), Command::Uppercase),
            (&amp;quot; all roads lead to rome! &amp;quot;.into(), Command::Trim),
            (&amp;quot;foo&amp;quot;.into(), Command::Append(1)),
            (&amp;quot;bar&amp;quot;.into(), Command::Append(5)),
        ]);
        assert_eq!(output[0], &amp;quot;HELLO&amp;quot;);
        assert_eq!(output[1], &amp;quot;all roads lead to rome!&amp;quot;);
        assert_eq!(output[2], &amp;quot;foobar&amp;quot;);
        assert_eq!(output[3], &amp;quot;barbarbarbarbarbar&amp;quot;);
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have instructions in the comments and four &lt;code&gt;TODOs&lt;&#x2F;code&gt; annotated in the code. Let&#x27;s first take a look at the instructions and make sure we understand what is being asked of us.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;general-instructions&quot;&gt;General Instructions&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;We&#x27;re building a function&lt;&#x2F;li&gt;
&lt;li&gt;We&#x27;re inputing a list of strings and commands into our function&lt;&#x2F;li&gt;
&lt;li&gt;The commands can be
&lt;ol&gt;
&lt;li&gt;Uppercase the string&lt;&#x2F;li&gt;
&lt;li&gt;Trim the string&lt;&#x2F;li&gt;
&lt;li&gt;Append &amp;quot;bar&amp;quot; to the string a specified amount of times&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;details&quot;&gt;Details&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;Input will be a Vector of a 2-length tuple&lt;&#x2F;li&gt;
&lt;li&gt;First element is a string, second one is a command&lt;&#x2F;li&gt;
&lt;li&gt;Output is going to be a Vector of strings.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;quiz2-rs-errors&quot;&gt;quiz2.rs errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;quiz2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected identifier, found `)`
  --&amp;gt; exercises&amp;#x2F;quiz2.rs:33:34
   |
33 |     pub fn transformer(input: ???) -&amp;gt; ??? {
   |                                  ^ expected identifier

error: expected identifier, found `{`
  --&amp;gt; exercises&amp;#x2F;quiz2.rs:33:43
   |
33 |     pub fn transformer(input: ???) -&amp;gt; ??? {
   |                                           ^ expected identifier

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our errors are pretty self explanatory we&#x27;re missing code, so no surprises there.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s take a look at the specific areas that need to be completed.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;todo-in-transformer-function&quot;&gt;Todo in &lt;code&gt;transformer&lt;&#x2F;code&gt; function&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;mod my_module {
    use super::Command;

    &amp;#x2F;&amp;#x2F; TODO: Complete the function signature!
    pub fn transformer(input: ???) -&amp;gt; ??? {
        &amp;#x2F;&amp;#x2F; TODO: Complete the output declaration!
        let mut output: ??? = vec![];
        for (string, command) in input.iter() {
            &amp;#x2F;&amp;#x2F; TODO: Complete the function body. You can do it!
        }
        output
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A quick look at our todo&#x27;s here show us that we have to:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Complete the signature&lt;&#x2F;li&gt;
&lt;li&gt;Complete the &lt;code&gt;output&lt;&#x2F;code&gt; variable declaration&lt;&#x2F;li&gt;
&lt;li&gt;Complete the function body.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;test-todo&quot;&gt;Test Todo&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[cfg(test)]
mod tests {
    &amp;#x2F;&amp;#x2F; TODO: What do we need to import to have `transformer` in scope?
    use ???;
    use super::Command;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Our fourth todo is to make sure we have &lt;code&gt;transformer&lt;&#x2F;code&gt; in scope.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;quiz2-rs-solution&quot;&gt;quiz2.rs solution&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;completing-the-function-signature&quot;&gt;Completing the Function Signature&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s go through these in order, let&#x27;s look at the function signature, and our instructions which tell us that:  &lt;em&gt;input will be a Vector of a 2-length tuple&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    pub fn transformer(input: ???) -&amp;gt; ??? {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So a vector is declared as &lt;code&gt;Vec&amp;lt;&amp;gt;&lt;&#x2F;code&gt; but in this particular case we need a tuple stored inside of the vector which would make it look something like this &lt;code&gt;Vec&amp;lt;(,)&amp;gt;&lt;&#x2F;code&gt; when empty, but we know that we need to pass in 2 items as we&#x27;re told in our instructions: &lt;em&gt;first element is a string, second one is a command&lt;&#x2F;em&gt;
so to complete it, it should look something like this: &lt;code&gt;Vec&amp;lt;(String, command)&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now, let&#x27;s look at the return value which we were told is: &lt;em&gt;output is going to be a Vector of strings&lt;&#x2F;em&gt;  with that we can complete our function signature to look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    pub fn transformer(input: Vec&amp;lt;(String, Command)&amp;gt;) -&amp;gt; Vec&amp;lt;String&amp;gt; {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This should complete our function signature for &lt;code&gt;transformer&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;completing-the-output-declaration&quot;&gt;Completing the &lt;code&gt;output&lt;&#x2F;code&gt; declaration&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;        let mut output: ??? = vec![]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we have an incomplete variable declaration, we need to provide the type to complete it. If we reference our notes, we&#x27;ve been told that we should be expecting a &lt;em&gt;Vector of strings&lt;&#x2F;em&gt;, so we should be able to add that to our declaration to complete the line.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;        let mut output: Vec&amp;lt;String&amp;gt; = vec![]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;completing-the-function-body&quot;&gt;Completing the Function Body&lt;&#x2F;h3&gt;
&lt;p&gt;Now, let&#x27;s consider what needs to be completed in the function body and the actions that need to be performed on the strings based on the commands. Remember, the available commands are &lt;code&gt;Uppercase&lt;&#x2F;code&gt;, &lt;code&gt;Trim&lt;&#x2F;code&gt;, and &lt;code&gt;Append&lt;&#x2F;code&gt;, that are defined in our &lt;code&gt;Command&lt;&#x2F;code&gt; enum.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn transformer(input: Vec&amp;lt;(String, Command)&amp;gt;) -&amp;gt; Vec&amp;lt;String&amp;gt; {
    let mut output: Vec&amp;lt;String&amp;gt; = vec![];
    for (string, command) in input.iter() {
    &amp;#x2F;&amp;#x2F; we use a match statement to match to the correct command
        let modified_string = match command {
        &amp;#x2F;&amp;#x2F; taking each case and using the appropriate method
            Command::Uppercase =&amp;gt; string.to_uppercase(), &amp;#x2F;&amp;#x2F; uppercase the string
            Command::Trim =&amp;gt; string.trim().to_string(), &amp;#x2F;&amp;#x2F; trim the string
            Command::Append(count) =&amp;gt; { &amp;#x2F;&amp;#x2F; appending
                let appended_string = format!(&amp;quot;{}{}&amp;quot;, string, &amp;quot;bar&amp;quot;.repeat(*count));
                appended_string
            }
        };
        output.push(modified_string); &amp;#x2F;&amp;#x2F; Add the modified string to the output vector
    }
    output &amp;#x2F;&amp;#x2F; Return the output vector
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So one of the ways that we know we can use enums is with match statements, we know that if something matches a certain criteria we can perform certain actions and return a value. So matching each &lt;code&gt;Command&lt;&#x2F;code&gt; in the &lt;code&gt;enum&lt;&#x2F;code&gt; using the &lt;code&gt;Command::Uppercase =&amp;gt;&lt;&#x2F;code&gt; style  matching we can perform an action for each match.
In the first two cases, it&#x27;s pretty simple all we have to do is call the appropriate method like &lt;code&gt;.to_upercase()&lt;&#x2F;code&gt; in the first match and &lt;code&gt;.trim()&lt;&#x2F;code&gt; (along with the &lt;code&gt;.to_string()&lt;&#x2F;code&gt; method on in &lt;code&gt;Trim&lt;&#x2F;code&gt;) but when we get to &lt;code&gt;Append&lt;&#x2F;code&gt; we have to perform an additional manipulation.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;appending&quot;&gt;Appending&lt;&#x2F;h3&gt;
&lt;p&gt;If we look back to our instructions we have to &lt;em&gt;Append &amp;quot;bar&amp;quot; to a string a specified amount of times&lt;&#x2F;em&gt;. So we can simply call a method or two and be done with our string. We have to add the logic to be able to do this. First let&#x27;s create a new variable called &lt;code&gt;appended_string&lt;&#x2F;code&gt; and let&#x27;s use the &lt;code&gt;format!&lt;&#x2F;code&gt; macro to put it into the format we want to use. In this case we use:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;format!(&amp;quot;{}{}&amp;quot;, string, &amp;quot;bar&amp;quot;.repeat(*count));
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This takes the original string, and concatenates &amp;quot;bar&amp;quot; to it by using &lt;code&gt;.repeat&lt;&#x2F;code&gt; we repeat it by the &lt;code&gt;count&lt;&#x2F;code&gt; we define in the &lt;code&gt;Command::Append(count)&lt;&#x2F;code&gt; branch. Finally, we return the  &lt;code&gt;appended_string&lt;&#x2F;code&gt;, reminder this only happens if the &lt;code&gt;Append&lt;&#x2F;code&gt; arm matches.&lt;&#x2F;p&gt;
&lt;p&gt;So at this point we have one of the three arms of the match inside of &lt;code&gt;modified_string&lt;&#x2F;code&gt; at this point we need to push this modified string to our &lt;code&gt;mut output&lt;&#x2F;code&gt;
Vec. Once that is completed we can then return our &lt;code&gt;output&lt;&#x2F;code&gt; variable with the correctly modified string.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;importing-transformer&quot;&gt;Importing &lt;code&gt;transformer&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Our last &lt;code&gt;TODO&lt;&#x2F;code&gt; is in our tests and it should be fairly simple to fix. We just have to use the full path of our function and remember to use the &lt;code&gt;crate&lt;&#x2F;code&gt; keyword that looks at the crate root, which is where our file is. After crate we must use the &lt;code&gt;::&lt;&#x2F;code&gt; double colon symbols which are equivalent to using &lt;code&gt;&#x2F;&lt;&#x2F;code&gt; in traditional file path systems. So for our purposes we need: &lt;code&gt;use crate::my_module::transformer;&lt;&#x2F;code&gt; to be able to use the function in our tests.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s the full updated code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub enum Command {
    Uppercase,
    Trim,
    Append(usize),
}

mod my_module {
    use super::Command;

    pub fn transformer(input: Vec&amp;lt;(String, Command)&amp;gt;) -&amp;gt; Vec&amp;lt;String&amp;gt; {
        let mut output: Vec&amp;lt;String&amp;gt; = vec![];
        for (string, command) in input.iter() {
            let modified_string = match command {
                Command::Uppercase =&amp;gt; string.to_uppercase(),
                Command::Trim =&amp;gt; string.trim().to_string(),
                Command::Append(count) =&amp;gt; {
                    let appended_string = format!(&amp;quot;{}{}&amp;quot;, string, &amp;quot;bar&amp;quot;.repeat(*count));
                    appended_string
                }
            };
            output.push(modified_string);
        }
        output
    }
}
#[cfg(test)]
mod tests {
    use super::Command;
    use crate::my_module::transformer;

    #[test]
    fn it_works() {
        let output = transformer(vec![
            (&amp;quot;hello&amp;quot;.into(), Command::Uppercase),
            (&amp;quot; all roads lead to rome! &amp;quot;.into(), Command::Trim),
            (&amp;quot;foo&amp;quot;.into(), Command::Append(1)),
            (&amp;quot;bar&amp;quot;.into(), Command::Append(5)),
        ]);
        assert_eq!(output[0], &amp;quot;HELLO&amp;quot;);
        assert_eq!(output[1], &amp;quot;all roads lead to rome!&amp;quot;);
        assert_eq!(output[2], &amp;quot;foobar&amp;quot;);
        assert_eq!(output[3], &amp;quot;barbarbarbarbarbar&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this post, we tackled Quiz 2, which required us to build a function that performs different actions on a list of strings based on given commands. We were instructed to uppercase a string, trim it, or append &amp;quot;bar&amp;quot; to it a specified number of times.&lt;&#x2F;p&gt;
&lt;p&gt;We began by analyzing the provided instructions and understanding the requirements. The input was expected to be a vector of tuples, where each tuple consisted of a string and a command. The output was to be a vector of strings.&lt;&#x2F;p&gt;
&lt;p&gt;Next, we addressed the incomplete parts of the code. We completed the function signature by specifying the input and output types as &lt;code&gt;Vec&amp;lt;(String, Command)&amp;gt;&lt;&#x2F;code&gt; and &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;&#x2F;code&gt; respectively.&lt;&#x2F;p&gt;
&lt;p&gt;In the function body, we utilized a &lt;code&gt;match&lt;&#x2F;code&gt; statement to match the command type and performed the corresponding action on the string. For the &lt;code&gt;Append&lt;&#x2F;code&gt; command, we used the &lt;code&gt;format!&lt;&#x2F;code&gt; macro to concatenate &amp;quot;bar&amp;quot; to the string a specified number of times.&lt;&#x2F;p&gt;
&lt;p&gt;We then added the modified strings to the &lt;code&gt;output&lt;&#x2F;code&gt; vector and returned it at the end of the function.&lt;&#x2F;p&gt;
&lt;p&gt;Lastly, we resolved the test-related task by importing the &lt;code&gt;transformer&lt;&#x2F;code&gt; function into the test module using the full path: &lt;code&gt;use crate::my_module::transformer;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;With these modifications, the code was successfully compiled and passed the provided tests.&lt;&#x2F;p&gt;
&lt;p&gt;Overall, this quiz allowed us to apply our knowledge of strings, vectors, move semantics, modules, and enums in Rust to build a functional machine. It reinforced our understanding of Rust concepts and helped us gain more confidence in utilizing them.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>12 Rustlings HashMaps</title>
          <pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/12-rustlings-hashmaps/</link>
          <guid>https://desmodrone.github.io/posts/12-rustlings-hashmaps/</guid>
          <description xml:base="https://desmodrone.github.io/posts/12-rustlings-hashmaps/">&lt;h1 id=&quot;hashmaps&quot;&gt;Hashmaps&lt;&#x2F;h1&gt;
&lt;h5 id=&quot;from-the-rustlings-readme&quot;&gt;From the Rustlings README&lt;&#x2F;h5&gt;
&lt;p&gt;A &lt;em&gt;hash map&lt;&#x2F;em&gt; allows you to associate a value with a particular key.
You may also know this by the names &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;container&#x2F;unordered_map&quot;&gt;&lt;em&gt;unordered map&lt;&#x2F;em&gt; in C++&lt;&#x2F;a&gt;,
&lt;a href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;tutorial&#x2F;datastructures.html#dictionaries&quot;&gt;&lt;em&gt;dictionary&lt;&#x2F;em&gt; in Python&lt;&#x2F;a&gt; or an &lt;em&gt;associative array&lt;&#x2F;em&gt; in other languages.&lt;&#x2F;p&gt;
&lt;p&gt;This is the other data structure that we&#x27;ve been talking about before, when
talking about Vecs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch08-03-hash-maps.html&quot;&gt;Storing Keys with Associated Values in Hash Maps&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;hashmaps1-rs&quot;&gt;hashmaps1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; hashmaps1.rs
&amp;#x2F;&amp;#x2F; A basket of fruits in the form of a hash map needs to be defined.
&amp;#x2F;&amp;#x2F; The key represents the name of the fruit and the value represents
&amp;#x2F;&amp;#x2F; how many of that particular fruit is in the basket. You have to put
&amp;#x2F;&amp;#x2F; at least three different types of fruits (e.g apple, banana, mango)
&amp;#x2F;&amp;#x2F; in the basket and the total count of all the fruits should be at
&amp;#x2F;&amp;#x2F; least five.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Make me compile and pass the tests!
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Execute `rustlings hint hashmaps1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::collections::HashMap;

fn fruit_basket() -&amp;gt; HashMap&amp;lt;String, u32&amp;gt; {
    let mut basket = &amp;#x2F;&amp;#x2F; TODO: declare your hash map here.

    &amp;#x2F;&amp;#x2F; Two bananas are already given for you :)
    basket.insert(String::from(&amp;quot;banana&amp;quot;), 2);

    &amp;#x2F;&amp;#x2F; TODO: Put more fruits in your basket here.

    basket
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn at_least_three_types_of_fruits() {
        let basket = fruit_basket();
        assert!(basket.len() &amp;gt;= 3);
    }

    #[test]
    fn at_least_five_fruits() {
        let basket = fruit_basket();
        assert!(basket.values().sum::&amp;lt;u32&amp;gt;() &amp;gt;= 5);
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are to put more fruit into our &lt;code&gt;HashMap&lt;&#x2F;code&gt; basket, we need at least 3 different kinds of fruits and the total count of all fruits should be at least five. In the comments we see more instructions via &lt;code&gt;TODO&#x27;s&lt;&#x2F;code&gt; which are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;to declare a hash map&lt;&#x2F;li&gt;
&lt;li&gt;put more fruits in our basket.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;hashmaps1-rs-errors&quot;&gt;hashmaps1.rs errors&lt;&#x2F;h2&gt;
&lt;p&gt;A quick glance of our errors shows nothing unexpected:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Compiling of exercises&amp;#x2F;hashmaps&amp;#x2F;hashmaps1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0425]: cannot find value `basket` in this scope
  --&amp;gt; exercises&amp;#x2F;hashmaps&amp;#x2F;hashmaps1.rs:21:5
   |
21 |     basket.insert(String::from(&amp;quot;banana&amp;quot;), 2);
   |     ^^^^^^ not found in this scope

error: aborting due to previous error

For more information about this error, try `rustc --explain E0425`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;hashmaps1-solution&quot;&gt;hashmaps1 solution&lt;&#x2F;h2&gt;
&lt;p&gt;So now let&#x27;s move on to the solution. We first declare our &lt;code&gt;HashMap&lt;&#x2F;code&gt; by completing line 5 with &lt;code&gt;let mut basket = HashMap::new();&lt;&#x2F;code&gt;
That let&#x27;s us create our hashmap so it&#x27;s usable  in the next lines, meaning we can add some more fruit to it.
We already have our first line defined as &lt;code&gt;basket.insert(String::from(&amp;quot;banana&amp;quot;), 2);&lt;&#x2F;code&gt; so if we use this same pattern but add different fruits, keeping in mind our quantity requirements, we should be good.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::collections::HashMap;

fn fruit_basket() -&amp;gt; HashMap&amp;lt;String, u32&amp;gt; {
    &amp;#x2F;&amp;#x2F; TODO: declare your hash map here.
    let mut basket = HashMap::new();

    &amp;#x2F;&amp;#x2F; Two bananas are already given for you :)
    basket.insert(String::from(&amp;quot;banana&amp;quot;), 2);
    basket.insert(String::from(&amp;quot;apple&amp;quot;), 2);
    basket.insert(String::from(&amp;quot;mango&amp;quot;), 1);
    &amp;#x2F;&amp;#x2F; TODO: Put more fruits in your basket here.

    basket
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Easy enough, we declare a new HashMap and add some fruit.
Let&#x27;s move on to the next one!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hashmap2-rs&quot;&gt;hashmap2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; hashmaps2.rs

&amp;#x2F;&amp;#x2F; A basket of fruits in the form of a hash map is given. The key
&amp;#x2F;&amp;#x2F; represents the name of the fruit and the value represents how many
&amp;#x2F;&amp;#x2F; of that particular fruit is in the basket. You have to put *MORE
&amp;#x2F;&amp;#x2F; THAN 11* fruits in the basket. Three types of fruits - Apple (4),
&amp;#x2F;&amp;#x2F; Mango (2) and Lychee (5) are already given in the basket. You are
&amp;#x2F;&amp;#x2F; not allowed to insert any more of these fruits!
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Make me pass the tests!
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::collections::HashMap;

#[derive(Hash, PartialEq, Eq)]
enum Fruit {
    Apple,
    Banana,
    Mango,
    Lychee,
    Pineapple,
}

fn fruit_basket(basket: &amp;amp;mut HashMap&amp;lt;Fruit, u32&amp;gt;) {
    let fruit_kinds = vec![
        Fruit::Apple,
        Fruit::Banana,
        Fruit::Mango,
        Fruit::Lychee,
        Fruit::Pineapple,
    ];

    for fruit in fruit_kinds {
        &amp;#x2F;&amp;#x2F; TODO: Put new fruits if not already present. Note that you
        &amp;#x2F;&amp;#x2F; are not allowed to put any type of fruit that&amp;#x27;s already
        &amp;#x2F;&amp;#x2F; present!
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_fruit_basket() -&amp;gt; HashMap&amp;lt;Fruit, u32&amp;gt; {
        let mut basket = HashMap::&amp;lt;Fruit, u32&amp;gt;::new();
        basket.insert(Fruit::Apple, 4);
        basket.insert(Fruit::Mango, 2);
        basket.insert(Fruit::Lychee, 5);

        basket
    }

    #[test]
    fn test_given_fruits_are_not_modified() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;amp;mut basket);
        assert_eq!(*basket.get(&amp;amp;Fruit::Apple).unwrap(), 4);
        assert_eq!(*basket.get(&amp;amp;Fruit::Mango).unwrap(), 2);
        assert_eq!(*basket.get(&amp;amp;Fruit::Lychee).unwrap(), 5);
    }

    #[test]
    fn at_least_five_types_of_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;amp;mut basket);
        let count_fruit_kinds = basket.len();
        assert!(count_fruit_kinds &amp;gt;= 5);
    }

    #[test]
    fn greater_than_eleven_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;amp;mut basket);
        let count = basket.values().sum::&amp;lt;u32&amp;gt;();
        assert!(count &amp;gt; 11);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the given code, the goal is to modify the &lt;code&gt;fruit_basket&lt;&#x2F;code&gt; function to add more than 11 fruits of various kinds to a hash map (&lt;code&gt;HashMap&lt;&#x2F;code&gt;) called &lt;code&gt;basket&lt;&#x2F;code&gt;. The hash map represents a basket of fruits, where the keys are different types of fruits (represented by the &lt;code&gt;Fruit&lt;&#x2F;code&gt; enum) and the values are the number of each fruit in the basket (&lt;code&gt;u32&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;fruit_basket&lt;&#x2F;code&gt; function should insert additional fruit types into the &lt;code&gt;basket&lt;&#x2F;code&gt; hash map without modifying the quantities of the fruits that are already present (Apple, Mango, and Lychee) since they are already given in the initial basket.&lt;&#x2F;p&gt;
&lt;p&gt;The provided test cases ensure that the given fruits are not modified, that there are at least five types of fruits in the basket after the function execution, and that there are more than eleven fruits in total in the basket.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hashmap2-rs-solution&quot;&gt;hashmap2.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::collections::HashMap;

#[derive(Hash, PartialEq, Eq)]
enum Fruit {
    Apple,
    Banana,
    Mango,
    Lychee,
    Pineapple,
    Pear,
    Kiwi,
    Strawberries,
    Blueberries,
    Cherries,
    Lemons,
    Grapefruit,
}

fn fruit_basket(basket: &amp;amp;mut HashMap&amp;lt;Fruit, u32&amp;gt;) {
    let fruit_kinds = vec![
        Fruit::Apple,
        Fruit::Banana,
        Fruit::Mango,
        Fruit::Lychee,
        Fruit::Pineapple,
        Fruit::Pear,
        Fruit::Kiwi,
        Fruit::Strawberries,
        Fruit::Blueberries,
        Fruit::Cherries,
        Fruit::Lemons,
        Fruit::Grapefruit,
    ];

    for fruit in fruit_kinds {
        basket.insert(Fruit::Pear, 2);
        basket.insert(Fruit::Kiwi, 10);
        basket.insert(Fruit::Strawberries, 5);
        basket.insert(Fruit::Lemons, 6);
        basket.insert(Fruit::Strawberries, 6);
        basket.insert(Fruit::Blueberries, 6);
        basket.insert(Fruit::Grapefruit, 6);
        basket.insert(Fruit::Cherries, 6);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This solution involves adding more fruit types to the &lt;code&gt;fruit_kinds&lt;&#x2F;code&gt; vector, and then iterating through this vector to insert the new fruits into the &lt;code&gt;basket&lt;&#x2F;code&gt; hash map using the &lt;code&gt;insert&lt;&#x2F;code&gt; method. This includes adding multiple instances of new fruit types to meet the requirement of having more than eleven fruits in the basket.&lt;&#x2F;p&gt;
&lt;p&gt;In our code, we add several new fruit types (e.g., Pear, Kiwi, Strawberries, Blueberries, Cherries, Lemons, and Grapefruit), and multiple instances of each fruit are inserted into the &lt;code&gt;basket&lt;&#x2F;code&gt; hash map.&lt;&#x2F;p&gt;
&lt;p&gt;This satisfies the requirements, passing all the given test cases, and ensuring that the function can add additional fruit types to the basket while preserving the initial quantities of the given fruits.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hashmaps3-rs&quot;&gt;hashmaps3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; hashmaps3.rs

&amp;#x2F;&amp;#x2F; A list of scores (one per line) of a soccer match is given. Each line
&amp;#x2F;&amp;#x2F; is of the form :
&amp;#x2F;&amp;#x2F; &amp;lt;team_1_name&amp;gt;,&amp;lt;team_2_name&amp;gt;,&amp;lt;team_1_goals&amp;gt;,&amp;lt;team_2_goals&amp;gt;
&amp;#x2F;&amp;#x2F; Example: England,France,4,2 (England scored 4 goals, France 2).

&amp;#x2F;&amp;#x2F; You have to build a scores table containing the name of the team, goals
&amp;#x2F;&amp;#x2F; the team scored, and goals the team conceded. One approach to build
&amp;#x2F;&amp;#x2F; the scores table is to use a Hashmap. The solution is partially
&amp;#x2F;&amp;#x2F; written to use a Hashmap, complete it to pass the test.

&amp;#x2F;&amp;#x2F; Make me pass the tests!

&amp;#x2F;&amp;#x2F; Execute `rustlings hint hashmaps3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::collections::HashMap;

&amp;#x2F;&amp;#x2F; A structure to store team name and its goal details.
struct Team {
    name: String,
    goals_scored: u8,
    goals_conceded: u8,
}

fn build_scores_table(results: String) -&amp;gt; HashMap&amp;lt;String, Team&amp;gt; {
    &amp;#x2F;&amp;#x2F; The name of the team is the key and its associated struct is the value.
    let mut scores: HashMap&amp;lt;String, Team&amp;gt; = HashMap::new();

    for r in results.lines() {
        let v: Vec&amp;lt;&amp;amp;str&amp;gt; = r.split(&amp;#x27;,&amp;#x27;).collect();
        let team_1_name = v[0].to_string();
        let team_1_score: u8 = v[2].parse().unwrap();
        let team_2_name = v[1].to_string();
        let team_2_score: u8 = v[3].parse().unwrap();
        &amp;#x2F;&amp;#x2F; TODO: Populate the scores table with details extracted from the
        &amp;#x2F;&amp;#x2F; current line. Keep in mind that goals scored by team_1
        &amp;#x2F;&amp;#x2F; will be the number of goals conceded from team_2, and similarly
        &amp;#x2F;&amp;#x2F; goals scored by team_2 will be the number of goals conceded by
        &amp;#x2F;&amp;#x2F; team_1.
    }
    scores
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_results() -&amp;gt; String {
        let results = &amp;quot;&amp;quot;.to_string()
            + &amp;quot;England,France,4,2\n&amp;quot;
            + &amp;quot;France,Italy,3,1\n&amp;quot;
            + &amp;quot;Poland,Spain,2,0\n&amp;quot;
            + &amp;quot;Germany,England,2,1\n&amp;quot;;
        results
    }

    #[test]
    fn build_scores() {
        let scores = build_scores_table(get_results());

        let mut keys: Vec&amp;lt;&amp;amp;String&amp;gt; = scores.keys().collect();
        keys.sort();
        assert_eq!(
            keys,
            vec![&amp;quot;England&amp;quot;, &amp;quot;France&amp;quot;, &amp;quot;Germany&amp;quot;, &amp;quot;Italy&amp;quot;, &amp;quot;Poland&amp;quot;, &amp;quot;Spain&amp;quot;]
        );
    }

    #[test]
    fn validate_team_score_1() {
        let scores = build_scores_table(get_results());
        let team = scores.get(&amp;quot;England&amp;quot;).unwrap();
        assert_eq!(team.goals_scored, 5);
        assert_eq!(team.goals_conceded, 4);
    }

    #[test]
    fn validate_team_score_2() {
        let scores = build_scores_table(get_results());
        let team = scores.get(&amp;quot;Spain&amp;quot;).unwrap();
        assert_eq!(team.goals_scored, 0);
        assert_eq!(team.goals_conceded, 2);
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our task in this exercise is to build a scores table for soccer matches using a HashMap. We are given a list of match scores in the form of &lt;code&gt;&amp;lt;team_1_name&amp;gt;,&amp;lt;team_2_name&amp;gt;,&amp;lt;team_1_goals&amp;gt;,&amp;lt;team_2_goals&amp;gt;&lt;&#x2F;code&gt;. For example, &amp;quot;England,France,4,2&amp;quot; means England scored 4 goals, and France scored 2 goals in a match.&lt;&#x2F;p&gt;
&lt;p&gt;To build the scores table, we need to use a HashMap to store each team&#x27;s name, the goals they scored, and the goals they conceded in the matches.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hashmaps3-rs-errors&quot;&gt;hashmaps3.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;âš ï¸  Testing of exercises&amp;#x2F;hashmaps&amp;#x2F;hashmaps3.rs failed! Please try again. Here&amp;#x27;s the output:

running 3 tests
test tests::build_scores ... FAILED
test tests::validate_team_score_1 ... FAILED
test tests::validate_team_score_2 ... FAILED

successes:

successes:

failures:

---- tests::build_scores stdout ----
thread &amp;#x27;tests::build_scores&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `[]`,
 right: `[&amp;quot;England&amp;quot;, &amp;quot;France&amp;quot;, &amp;quot;Germany&amp;quot;, &amp;quot;Italy&amp;quot;, &amp;quot;Poland&amp;quot;, &amp;quot;Spain&amp;quot;]`&amp;#x27;, exercises&amp;#x2F;hashmaps&amp;#x2F;hashmaps3.rs:66:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

---- tests::validate_team_score_1 stdout ----
thread &amp;#x27;tests::validate_team_score_1&amp;#x27; panicked at &amp;#x27;called `Option::unwrap()` on a `None` value&amp;#x27;, exercises&amp;#x2F;hashmaps&amp;#x2F;hashmaps3.rs:75:42

---- tests::validate_team_score_2 stdout ----
thread &amp;#x27;tests::validate_team_score_2&amp;#x27; panicked at &amp;#x27;called `Option::unwrap()` on a `None` value&amp;#x27;, exercises&amp;#x2F;hashmaps&amp;#x2F;hashmaps3.rs:83:40


failures:
    tests::build_scores
    tests::validate_team_score_1
    tests::validate_team_score_2

test result: FAILED. 0 passed; 3 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;hasmap3-rs-solution&quot;&gt;hasmap3.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
use std::collections::HashMap;

&amp;#x2F;&amp;#x2F; A structure to store team name and its goal details.
struct Team {
    name: String,
    goals_scored: u8,
    goals_conceded: u8,
}

fn build_scores_table(results: String) -&amp;gt; HashMap&amp;lt;String, Team&amp;gt; {
    &amp;#x2F;&amp;#x2F; The name of the team is the key and its associated struct is the value.
    let mut scores: HashMap&amp;lt;String, Team&amp;gt; = HashMap::new();

    for r in results.lines() {
        let v: Vec&amp;lt;&amp;amp;str&amp;gt; = r.split(&amp;#x27;,&amp;#x27;).collect();
        let team_1_name = v[0].to_string();
        let team_1_score: u8 = v[2].parse().unwrap();
        let team_2_name = v[1].to_string();
        let team_2_score: u8 = v[3].parse().unwrap();

        &amp;#x2F;&amp;#x2F; Try to get a mutable reference to the first team&amp;#x27;s Team struct in the scores HashMap
        scores
            .entry(team_1_name.clone())
            &amp;#x2F;&amp;#x2F; If the Team struct exists, modify it by incrementing the goals_scored and goals_conceded fields
            .and_modify(|team| {
                team.goals_scored += team_1_score;
                team.goals_conceded += team_2_score;
            })
            &amp;#x2F;&amp;#x2F; If the Team struct does not exist, insert a new one with the initial scores
            .or_insert(Team {
                name: team_1_name,
                goals_scored: team_1_score,
                goals_conceded: team_2_score,
            });

        &amp;#x2F;&amp;#x2F; Repeat the same process for the second team
        scores
            .entry(team_2_name.clone())
            .and_modify(|team| {
                team.goals_scored += team_2_score;
                team.goals_conceded += team_1_score;
            })
            .or_insert(Team {
                name: team_2_name,
                goals_scored: team_2_score,
                goals_conceded: team_1_score,
            });
    }
    scores
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The code already provides a &lt;code&gt;Team&lt;&#x2F;code&gt; struct with fields for the team&#x27;s name, goals scored, and goals conceded. Our task is to complete the &lt;code&gt;build_scores_table&lt;&#x2F;code&gt; function to create and populate the HashMap with the match results.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s our plan to complete the function:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We&#x27;ll start by creating an empty HashMap called &lt;code&gt;scores&lt;&#x2F;code&gt; to store the team details.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Next, we&#x27;ll iterate through each line of the &lt;code&gt;results&lt;&#x2F;code&gt; string using &lt;code&gt;results.lines()&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;For each line, we&#x27;ll split it into components using &lt;code&gt;.split(&#x27;,&#x27;)&lt;&#x2F;code&gt; to extract the team names and goals.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;We&#x27;ll convert the necessary fields to their correct types (e.g., team names as strings, goals as u8).&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Then, we&#x27;ll populate the &lt;code&gt;scores&lt;&#x2F;code&gt; HashMap with the team details. We need to be careful because goals scored by one team are the goals conceded by the other team.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Finally, we&#x27;ll return the &lt;code&gt;scores&lt;&#x2F;code&gt; HashMap from the function.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Once we complete the function, the provided test cases will validate that the scores table is correctly built, and each team&#x27;s goals scored and conceded are accurate.&lt;&#x2F;p&gt;
&lt;p&gt;This would print &lt;code&gt;&amp;quot;England,France,4,2\nFrance,Italy,3,1\n&amp;quot;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Each line of the results string represents one match, with the teams and their respective scores separated by commas. This loop goes through each line one at a time, parsing the teams and scores and updating the &lt;code&gt;scores&lt;&#x2F;code&gt; HashMap accordingly.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;entry()&lt;&#x2F;code&gt; method tries to get a mutable reference to the &lt;code&gt;Team&lt;&#x2F;code&gt; struct associated with a team&#x27;s name. If the &lt;code&gt;Team&lt;&#x2F;code&gt; struct exists, the &lt;code&gt;and_modify()&lt;&#x2F;code&gt; method modifies it by adding the new scores to the &lt;code&gt;goals_scored&lt;&#x2F;code&gt; and &lt;code&gt;goals_conceded&lt;&#x2F;code&gt; fields. If the &lt;code&gt;Team&lt;&#x2F;code&gt; struct doesn&#x27;t exist, the &lt;code&gt;or_insert()&lt;&#x2F;code&gt; method inserts a new &lt;code&gt;Team&lt;&#x2F;code&gt; struct with the initial scores.
This is done for both teams in each match. After all the matches have been processed, the &lt;code&gt;scores&lt;&#x2F;code&gt; HashMap is returned, with each team&#x27;s total goals scored and conceded updated to reflect all the matches.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;alternate-solution-using-if-let&quot;&gt;Alternate Solution using If &#x2F; Let&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn build_scores_table(results: String) -&amp;gt; HashMap&amp;lt;String, Team&amp;gt; {
    &amp;#x2F;&amp;#x2F; The name of the team is the key and its associated struct is the value.
    let mut scores: HashMap&amp;lt;String, Team&amp;gt; = HashMap::new();

    for r in results.lines() {
        let v: Vec&amp;lt;&amp;amp;str&amp;gt; = r.split(&amp;#x27;,&amp;#x27;).collect();
        let team_1_name = v[0].to_string();
        let team_1_score: u8 = v[2].parse().unwrap();
        let team_2_name = v[1].to_string();
        let team_2_score: u8 = v[3].parse().unwrap();

        &amp;#x2F;&amp;#x2F; Check if the first team exists in the scores HashMap
        if let Some(team) = scores.get_mut(&amp;amp;team_1_name) {
            &amp;#x2F;&amp;#x2F; If the team exists, increment the goals_scored and goals_conceded fields
            team.goals_scored += team_1_score;
            team.goals_conceded += team_2_score;
        } else {
            &amp;#x2F;&amp;#x2F; If the team does not exist, insert a new one with the initial scores
            scores.insert(
                team_1_name.clone(),
                Team {
                    name: team_1_name.clone(),
                    goals_scored: team_1_score,
                    goals_conceded: team_2_score,
                },
            );
        }

        &amp;#x2F;&amp;#x2F; Repeat the same process for the second team
        if let Some(team) = scores.get_mut(&amp;amp;team_2_name) {
            team.goals_scored += team_2_score;
            team.goals_conceded += team_1_score;
        } else {
            scores.insert(
                team_2_name.clone(),
                Team {
                    name: team_2_name.clone(),
                    goals_scored: team_2_score,
                    goals_conceded: team_1_score,
                },
            );
        }
    }
    scores
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this version, &lt;code&gt;if let Some(team) = scores.get_mut(&amp;amp;team_1_name)&lt;&#x2F;code&gt; tries to get a mutable reference to the team in the &lt;code&gt;scores&lt;&#x2F;code&gt; HashMap. If the team exists, &lt;code&gt;Some(team)&lt;&#x2F;code&gt; is returned and the team&#x27;s scores are updated. If the team does not exist, &lt;code&gt;None&lt;&#x2F;code&gt; is returned and a new &lt;code&gt;Team&lt;&#x2F;code&gt; struct is inserted into the &lt;code&gt;scores&lt;&#x2F;code&gt; HashMap with the &lt;code&gt;scores.insert()&lt;&#x2F;code&gt; method. This is repeated for both teams.&lt;&#x2F;p&gt;
&lt;p&gt;The logic is the same as in the previous version that uses closures, but the control flow is more explicit here. However, this version is slightly more verbose and arguably less idiomatic in Rust. Closures and method chaining using &lt;code&gt;and_modify&lt;&#x2F;code&gt; and &lt;code&gt;or_insert&lt;&#x2F;code&gt; on &lt;code&gt;HashMap::entry&lt;&#x2F;code&gt; are common patterns in Rust code.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;3rd-possible-solution&quot;&gt;3rd Possible Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn build_scores_table(results: String) -&amp;gt; HashMap&amp;lt;String, Team&amp;gt; {
    let mut scores: HashMap&amp;lt;String, Team&amp;gt; = HashMap::new();

    for r in results.lines() {
        let v: Vec&amp;lt;&amp;amp;str&amp;gt; = r.split(&amp;#x27;,&amp;#x27;).collect();
        let team_1_name = v[0].to_string();
        let team_1_score: u8 = v[2].parse().unwrap();
        let team_2_name = v[1].to_string();
        let team_2_score: u8 = v[3].parse().unwrap();

        &amp;#x2F;&amp;#x2F; Handle team 1
        let team_1 = scores.remove(&amp;amp;team_1_name);
        if let Some(mut t) = team_1 {
            t.goals_scored += team_1_score;
            t.goals_conceded += team_2_score;
            scores.insert(team_1_name, t);
        } else {
            scores.insert(team_1_name, Team { name: team_1_name.clone(), goals_scored: team_1_score, goals_conceded: team_2_score });
        }

        &amp;#x2F;&amp;#x2F; Handle team 2
        let team_2 = scores.remove(&amp;amp;team_2_name);
        if let Some(mut t) = team_2 {
            t.goals_scored += team_2_score;
            t.goals_conceded += team_1_score;
            scores.insert(team_2_name, t);
        } else {
            scores.insert(team_2_name, Team { name: team_2_name.clone(), goals_scored: team_2_score, goals_conceded: team_1_score });
        }
    }
    scores
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this version, &lt;code&gt;scores.remove(&amp;amp;team_1_name)&lt;&#x2F;code&gt; attempts to remove the &lt;code&gt;Team&lt;&#x2F;code&gt; struct associated with &lt;code&gt;team_1_name&lt;&#x2F;code&gt; from the HashMap. If the team exists, the &lt;code&gt;Team&lt;&#x2F;code&gt; struct is returned and removed from the HashMap, the team&#x27;s scores are updated, and the updated &lt;code&gt;Team&lt;&#x2F;code&gt; struct is re-inserted into the HashMap. If the team does not exist, a new &lt;code&gt;Team&lt;&#x2F;code&gt; struct is inserted into the HashMap. This process is repeated for both teams.&lt;&#x2F;p&gt;
&lt;p&gt;Although this version is simpler and doesn&#x27;t use closures, it&#x27;s also less efficient because it requires additional lookups and insertions into the HashMap. The previous two versions that use &lt;code&gt;HashMap::entry&lt;&#x2F;code&gt; are generally more efficient and idiomatic in Rust.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this post, we explored the concept of HashMaps in Rust and how they allow us to associate values with specific keys. HashMaps are similar to unordered maps in C++, dictionaries in Python, or associative arrays in other languages. We learned how to use the HashMap data structure to build collections with key-value pairs.&lt;&#x2F;p&gt;
&lt;p&gt;We worked through three exercises that involved using HashMaps to store and manipulate data:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;In &lt;code&gt;hashmaps1.rs&lt;&#x2F;code&gt;, we had to create a basket of fruits using a HashMap. We needed to ensure that the basket contained at least three different types of fruits and a total of at least five fruits. By declaring a new HashMap and adding the required fruits with their quantities, we successfully completed this task.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;In &lt;code&gt;hashmaps2.rs&lt;&#x2F;code&gt;, we were given a pre-defined basket of fruits and had to add more than eleven fruits of various kinds to it. However, we were not allowed to modify the quantities of the given fruits (Apple, Mango, and Lychee). By iterating through a list of new fruit types and inserting them into the HashMap, we successfully met the requirements of this exercise.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;In the exercise &lt;code&gt;hashmaps3.rs&lt;&#x2F;code&gt;, we were tasked with building a scores table for soccer matches using a &lt;code&gt;HashMap&lt;&#x2F;code&gt;. Three possible solutions were provided to achieve this goal:&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;Solution 1:&lt;&#x2F;strong&gt; &lt;em&gt;Using Closures and &lt;code&gt;entry()&lt;&#x2F;code&gt; Method Chaining&lt;&#x2F;em&gt;
This solution utilized closures and method chaining with &lt;code&gt;entry()&lt;&#x2F;code&gt; to efficiently handle the teams&#x27; scores and update the &lt;code&gt;HashMap&lt;&#x2F;code&gt; accordingly.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Solution 2:&lt;&#x2F;strong&gt; &lt;em&gt;Using &lt;code&gt;if let&lt;&#x2F;code&gt; Statements for Handling Entries&lt;&#x2F;em&gt;
In this solution, &lt;code&gt;if let&lt;&#x2F;code&gt; statements were used to handle entries in the &lt;code&gt;HashMap&lt;&#x2F;code&gt;, removing and updating teams&#x27; scores as needed.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Solution 3:&lt;&#x2F;strong&gt; &lt;em&gt;Using &lt;code&gt;if let&lt;&#x2F;code&gt; and &lt;code&gt;match&lt;&#x2F;code&gt; for Handling Entries&lt;&#x2F;em&gt;
This solution combined &lt;code&gt;if let&lt;&#x2F;code&gt; with &lt;code&gt;match&lt;&#x2F;code&gt; to handle the entries in the &lt;code&gt;HashMap&lt;&#x2F;code&gt;, similar to Solution 2, but with a slight variation in the syntax.&lt;&#x2F;p&gt;
&lt;p&gt;All three solutions achieved the goal of building the scores table and were valid approaches to solving the problem. The choice between these solutions may depend on personal coding style and preferences.&lt;&#x2F;p&gt;
&lt;p&gt;Key Takeaways:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;HashMaps in Rust provide fast lookup and insertion times.&lt;&#x2F;li&gt;
&lt;li&gt;They enable efficient data retrieval and manipulation based on unique keys.&lt;&#x2F;li&gt;
&lt;li&gt;HashMaps are valuable tools for various scenarios, such as building scores tables or maintaining associations between data elements.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;By mastering the usage of HashMaps, we expand our ability to manage and organize data efficiently in Rust. These skills are valuable for building robust and performant applications in a wide range of domains.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>11 Rustlings Modules</title>
          <pubDate>Mon, 17 Jul 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/11-rustlings-modules/</link>
          <guid>https://desmodrone.github.io/posts/11-rustlings-modules/</guid>
          <description xml:base="https://desmodrone.github.io/posts/11-rustlings-modules/">&lt;h1 id=&quot;modules&quot;&gt;Modules&lt;&#x2F;h1&gt;
&lt;p&gt;In this section we&#x27;ll give you an introduction to Rust&#x27;s module system.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch07-00-managing-growing-projects-with-packages-crates-and-modules.html&quot;&gt;The Module System&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;modules1-rs&quot;&gt;modules1.rs&lt;&#x2F;h2&gt;
&lt;p&gt;The first exercise focuses on controlling the visibility of functions within a module. The goal is to restrict access to the &lt;code&gt;get_secret_recipe&lt;&#x2F;code&gt; function outside the &lt;code&gt;sausage_factory&lt;&#x2F;code&gt; module. Let&#x27;s take a look at the initial code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; modules1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

mod sausage_factory {
    &amp;#x2F;&amp;#x2F; Don&amp;#x27;t let anybody outside of this module see this!
    fn get_secret_recipe() -&amp;gt; String {
        String::from(&amp;quot;Ginger&amp;quot;)
    }

    fn make_sausage() {
        get_secret_recipe();
        println!(&amp;quot;sausage!&amp;quot;);
    }
}

fn main() {
    sausage_factory::make_sausage();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions in this first exercise are to not let anyone outside of the &lt;code&gt;sausage_factory&lt;&#x2F;code&gt; module see the &lt;code&gt;get_secret_recipe&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modules1-rs-errors&quot;&gt;modules1.rs errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;modules&amp;#x2F;modules1.rs failed! Please try again. Here is the output:
error[E0603]: function `make_sausage` is private
  --&amp;gt; exercises&amp;#x2F;modules&amp;#x2F;modules1.rs:19:22
   |
19 |     sausage_factory::make_sausage();
   |                      ^^^^^^^^^^^^ private function
   |
note: the function `make_sausage` is defined here
  --&amp;gt; exercises&amp;#x2F;modules&amp;#x2F;modules1.rs:12:5
   |
12 |     fn make_sausage() {
   |     ^^^^^^^^^^^^^^^^^

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see that our errors tell us that our &lt;code&gt;make_sausage()&lt;&#x2F;code&gt; function is private and we can see that we are trying to access it in our &lt;code&gt;fn main()&lt;&#x2F;code&gt; so, our fix is simple, make the function that we need to see outside of the &lt;code&gt;sausage_factory&lt;&#x2F;code&gt; module accessible by adding a &lt;code&gt;pub&lt;&#x2F;code&gt; keyword. Let&#x27;s try this.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modules1-rs-solution&quot;&gt;modules1.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;mod sausage_factory {
    &amp;#x2F;&amp;#x2F; Don&amp;#x27;t let anybody outside of this module see this!
    fn get_secret_recipe() -&amp;gt; String {
        String::from(&amp;quot;Ginger&amp;quot;)
    }

    pub fn make_sausage() { &amp;#x2F;&amp;#x2F; adding `pub` here fixes our issue
        get_secret_recipe();
        println!(&amp;quot;sausage!&amp;quot;);
    }
}

fn main() {
    sausage_factory::make_sausage();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Simple solution by adding the &lt;code&gt;pub&lt;&#x2F;code&gt; keyword to our &lt;code&gt;make_sausage()&lt;&#x2F;code&gt; function we get access to it from our &lt;code&gt;main()&lt;&#x2F;code&gt; function and our code compiles and prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;sausage!
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;modules2-rs&quot;&gt;modules2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; modules2.rs
&amp;#x2F;&amp;#x2F; You can bring module paths into scopes and provide new names for them with the
&amp;#x2F;&amp;#x2F; &amp;#x27;use&amp;#x27; and &amp;#x27;as&amp;#x27; keywords. Fix these &amp;#x27;use&amp;#x27; statements to make the code compile.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

mod delicious_snacks {
    &amp;#x2F;&amp;#x2F; TODO: Fix these use statements
	use self::fruits::{PEAR as fruit};
    use self::veggies::CUCUMBER as ???

    mod fruits {
        pub const PEAR: &amp;amp;&amp;#x27;static str = &amp;quot;Pear&amp;quot;;
        pub const APPLE: &amp;amp;&amp;#x27;static str = &amp;quot;Apple&amp;quot;;
    }

    mod veggies {
        pub const CUCUMBER: &amp;amp;&amp;#x27;static str = &amp;quot;Cucumber&amp;quot;;
        pub const CARROT: &amp;amp;&amp;#x27;static str = &amp;quot;Carrot&amp;quot;;
    }
}

fn main() {
    println!(
        &amp;quot;favorite snacks: {} and {}&amp;quot;,
        delicious_snacks::fruit,
        delicious_snacks::veggie
    );
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions here are to bring our module into scope by using &lt;code&gt;use&lt;&#x2F;code&gt; and &lt;code&gt;as&lt;&#x2F;code&gt; keywords. We can see and incomplete &lt;code&gt;use&lt;&#x2F;code&gt; statement on line 11. Let&#x27;s take a quick look at the errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modules2-rs-errors&quot;&gt;modules2.rs errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;modules&amp;#x2F;modules2.rs failed! Please try again. Here is the output:
error: expected identifier, found `?`
  --&amp;gt; exercises&amp;#x2F;modules&amp;#x2F;modules2.rs:10:31
   |
10 |     use self::fruits::PEAR as ???
   |                               ^ expected identifier

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler confirms what we already know, but it actually gives us a big hint in telling us that it expects an identifier. So, let&#x27;s add the identifier.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modules2-rs-solution&quot;&gt;modules2.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;By looking at our code we can understand what the code is expecting as an identifier. It specifically shows in our &lt;code&gt;main()&lt;&#x2F;code&gt; function that we need to print the &lt;code&gt;delicious_snacks::fruit,&lt;&#x2F;code&gt; and the &lt;code&gt;delicious_snacks::veggie,&lt;&#x2F;code&gt; so this is a clear indication that we must identify our cucumber &amp;quot;as&amp;quot; a &lt;code&gt;veggie&lt;&#x2F;code&gt;. We also need to add the &lt;code&gt;pub&lt;&#x2F;code&gt; keyword to make sure that they can be accessed outside of &lt;code&gt;delicious_snacks&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;mod delicious_snacks {
    &amp;#x2F;&amp;#x2F; TODO: Fix these use statements
    pub use self::fruits::PEAR as fruit;
    pub use self::veggies::CUCUMBER as veggie; &amp;#x2F;&amp;#x2F; adding veggie identifier here

    mod fruits {
        pub const PEAR: &amp;amp;&amp;#x27;static str = &amp;quot;Pear&amp;quot;;
        pub const APPLE: &amp;amp;&amp;#x27;static str = &amp;quot;Apple&amp;quot;;
    }

    mod veggies {
        pub const CUCUMBER: &amp;amp;&amp;#x27;static str = &amp;quot;Cucumber&amp;quot;;
        pub const CARROT: &amp;amp;&amp;#x27;static str = &amp;quot;Carrot&amp;quot;;
    }
}

fn main() {
    println!(
        &amp;quot;favorite snacks: {} and {}&amp;quot;,
        delicious_snacks::fruit,
        delicious_snacks::veggie
    );
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And it works, we&#x27;re printing out of favorite snacks a pear and  cucumber using the &lt;code&gt;as&lt;&#x2F;code&gt; keyword.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
favorite snacks: Pear and Cucumber

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;modules3-rs&quot;&gt;modules3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; modules3.rs
&amp;#x2F;&amp;#x2F; You can use the &amp;#x27;use&amp;#x27; keyword to bring module paths from modules from anywhere
&amp;#x2F;&amp;#x2F; and especially from the Rust standard library into your scope.
&amp;#x2F;&amp;#x2F; Bring SystemTime and UNIX_EPOCH
&amp;#x2F;&amp;#x2F; from the std::time module. Bonus style points if you can do it with one line!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

&amp;#x2F;&amp;#x2F; TODO: Complete this use statement
use ???

fn main() {
    match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(n) =&amp;gt; println!(&amp;quot;1970-01-01 00:00:00 UTC was {} seconds ago!&amp;quot;, n.as_secs()),
        Err(_) =&amp;gt; panic!(&amp;quot;SystemTime before UNIX EPOCH!&amp;quot;),
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this third exercise, we encounter code that involves the use of &lt;code&gt;UNIX_EPOCH&lt;&#x2F;code&gt; and &lt;code&gt;SystemTime&lt;&#x2F;code&gt;. Let&#x27;s take a closer look at what these terms mean and how they relate to each other.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;UNIX_EPOCH&lt;&#x2F;code&gt; represents a specific point in time: the start of the Unix time system. In Unix-based operating systems, time is often measured as the number of seconds that have elapsed since January 1, 1970, at 00:00:00 UTC (Coordinated Universal Time). This point in time is commonly referred to as the Unix epoch.&lt;&#x2F;p&gt;
&lt;p&gt;On the other hand, &lt;code&gt;SystemTime&lt;&#x2F;code&gt; is a type provided by the Rust standard library that represents the system&#x27;s current time or a specific point in time. It is a flexible type that can handle different platforms and allows us to perform various operations on time values.&lt;&#x2F;p&gt;
&lt;p&gt;In the code snippet provided, the &lt;code&gt;match&lt;&#x2F;code&gt; statement is used to handle the result of calculating the duration between the current time (&lt;code&gt;SystemTime::now()&lt;&#x2F;code&gt;) and the Unix epoch (&lt;code&gt;UNIX_EPOCH&lt;&#x2F;code&gt;). By subtracting the Unix epoch from the current time, we can determine the duration that has passed since the Unix epoch.&lt;&#x2F;p&gt;
&lt;p&gt;If the calculation is successful (&lt;code&gt;Ok(n)&lt;&#x2F;code&gt;), we print the number of seconds that have elapsed since the Unix epoch. If an error occurs (&lt;code&gt;Err(_)&lt;&#x2F;code&gt;), indicating that the system time is before the Unix epoch, we panic with an appropriate error message.&lt;&#x2F;p&gt;
&lt;p&gt;By utilizing &lt;code&gt;UNIX_EPOCH&lt;&#x2F;code&gt; and &lt;code&gt;SystemTime&lt;&#x2F;code&gt;, we can work with time-related operations in Rust and perform calculations based on the Unix time system. Understanding these concepts enhances our ability to handle and manipulate time data effectively.&lt;&#x2F;p&gt;
&lt;p&gt;Now that we have a better understanding of &lt;code&gt;UNIX_EPOCH&lt;&#x2F;code&gt; and &lt;code&gt;SystemTime&lt;&#x2F;code&gt;, let&#x27;s proceed with the code solution to complete the exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modules3-rs-errors&quot;&gt;modules3.rs errors&lt;&#x2F;h2&gt;
&lt;p&gt;When analyzing the error messages in the &lt;code&gt;modules3.rs&lt;&#x2F;code&gt; exercise, we can see that they don&#x27;t provide any additional insights beyond the fact that an import statement is expected after the &lt;code&gt;use&lt;&#x2F;code&gt; keyword. The error message explicitly states that an identifier is anticipated after the &lt;code&gt;use&lt;&#x2F;code&gt; keyword. Therefore, to resolve this issue, we need to provide a valid identifier in our import statement.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;modules&amp;#x2F;modules3.rs failed! Please try again. Here is the output:
error: expected identifier, found `?`
  --&amp;gt; exercises&amp;#x2F;modules&amp;#x2F;modules3.rs:11:5
   |
11 | use ???
   |     ^ expected identifier

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;modules3-rs-solution&quot;&gt;modules3.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;Our hints are pretty direct we need to import from the &lt;code&gt;std::time&lt;&#x2F;code&gt; module both &lt;code&gt;UNIX_EPOCH&lt;&#x2F;code&gt; and &lt;code&gt;SystemTime&lt;&#x2F;code&gt; into our code, and in order to save space and time we should it in one line. The way we do this is by including adding curly braces&lt;code&gt;{}&lt;&#x2F;code&gt; into our import statement and separating each item with a comma, easy enough.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(n) =&amp;gt; println!(&amp;quot;19-01-01 00:00:00 UTC was {} seconds ago!&amp;quot;, n.as_secs()),
        Err(_) =&amp;gt; panic!(&amp;quot;SystemTime before UNIX EPOCH!&amp;quot;),
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the output we get&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
1970-01-01 00:00:00 UTC was 1687044064 seconds ago!

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we explored three exercises related to Rust&#x27;s module system. Here are the key takeaways:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Modules allow us to organize code by grouping related functionality together.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;pub&lt;&#x2F;code&gt; keyword is used to make items (functions, types, etc.) accessible outside their module.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;use&lt;&#x2F;code&gt; keyword can be used to bring module paths into scope, allowing us to use items from other modules with ease.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;as&lt;&#x2F;code&gt; keyword in the &lt;code&gt;use&lt;&#x2F;code&gt; statement allows us to provide new names for imported items.&lt;&#x2F;li&gt;
&lt;li&gt;The Rust standard library provides various modules that can be imported using the &lt;code&gt;use&lt;&#x2F;code&gt; keyword to leverage pre-existing functionality.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;By understanding and utilizing Rust&#x27;s module system effectively, we can write well-structured and maintainable code. Keep practicing and exploring different aspects of Rust to deepen your understanding of the language.&lt;&#x2F;p&gt;
&lt;p&gt;For further information on Rust&#x27;s module system, refer to the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch07-00-managing-growing-projects-with-packages-crates-and-modules.html&quot;&gt;official documentation&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>10 Rustlings Strings</title>
          <pubDate>Wed, 28 Jun 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/10-rustlings-strings/</link>
          <guid>https://desmodrone.github.io/posts/10-rustlings-strings/</guid>
          <description xml:base="https://desmodrone.github.io/posts/10-rustlings-strings/">&lt;h3 id=&quot;from-the-readme&quot;&gt;From the ReadMe:&lt;&#x2F;h3&gt;
&lt;p&gt;Rust has two string types, a string slice (&lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;) and an owned string (&lt;code&gt;String&lt;&#x2F;code&gt;).
We&#x27;re not going to dictate when you should use which one, but we&#x27;ll show you how
to identify and create them, as well as use them.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch08-02-strings.html&quot;&gt;Strings&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;strings1-rs&quot;&gt;strings1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; strings1.rs
&amp;#x2F;&amp;#x2F; Make me compile without changing the function signature!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let answer = current_favorite_color();
    println!(&amp;quot;My current favorite color is {}&amp;quot;, answer);
}

fn current_favorite_color() -&amp;gt; String {
    &amp;quot;blue&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are pretty straight forward we must make this code compile without changing the function signature.
As always we&#x27;ll take a look at the errors to and see if we get any hints.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings1-rs-errors&quot;&gt;strings1.rs errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;strings&amp;#x2F;strings1.rs failed! Please try again. Here is the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;strings&amp;#x2F;strings1.rs:13:5
   |
12 | fn current_favorite_color() -&amp;gt; String {
   |                                ------ expected `String` because of return type
13 |     &amp;quot;blue&amp;quot;
   |     ^^^^^^- help: try using a conversion method: `.to_string()`
   |     |
   |     expected struct `String`, found `&amp;amp;str`

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We do get a hint, it tells us to try using a conversion method: &lt;code&gt;.to_string()&lt;&#x2F;code&gt;, so why not let&#x27;s try that.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings1-rs-solution&quot;&gt;strings1.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let answer = current_favorite_color();
    println!(&amp;quot;My current favorite color is {}&amp;quot;, answer);
}

fn current_favorite_color() -&amp;gt; String {
    &amp;quot;blue&amp;quot;.to_string()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Just like this, it works appending our &lt;code&gt;&amp;quot;blue&amp;quot;&lt;&#x2F;code&gt; string with &lt;code&gt;.to_string&lt;&#x2F;code&gt; converts our &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; to a &lt;code&gt;String&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Converting &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; to &lt;code&gt;String&lt;&#x2F;code&gt; with &lt;code&gt;.to_string()&lt;&#x2F;code&gt;:&lt;&#x2F;strong&gt; The method &lt;code&gt;.to_string()&lt;&#x2F;code&gt; is used to convert a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; (string slice) to an owned &lt;code&gt;String&lt;&#x2F;code&gt;. In Rust, &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; represents a string slice, which is an immutable reference to a string. A &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; is a view into a string, and is usually used in program arguments and for reading strings from files or other I&#x2F;O operations. On the other hand, &lt;code&gt;String&lt;&#x2F;code&gt; is a growable, mutable, owned, heap allocated data structure. When you call &lt;code&gt;.to_string()&lt;&#x2F;code&gt; on a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;, you essentially allocate a chunk of heap memory, copy the contents of the &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; to that newly allocated memory, and return a &lt;code&gt;String&lt;&#x2F;code&gt; that owns that heap memory. This is why &lt;code&gt;&amp;quot;blue&amp;quot;.to_string()&lt;&#x2F;code&gt; gives you an owned &lt;code&gt;String&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This is the output:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
My current favorite color is blue

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;strings2-rs&quot;&gt;strings2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; strings2.rs
&amp;#x2F;&amp;#x2F; Make me compile without changing the function signature!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint strings2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let word = String::from(&amp;quot;green&amp;quot;); &amp;#x2F;&amp;#x2F; Try not changing this line :)
    if is_a_color_word(word) {
        println!(&amp;quot;That is a color word I know!&amp;quot;);
    } else {
        println!(&amp;quot;That is not a color word I know.&amp;quot;);
    }
}

fn is_a_color_word(attempt: &amp;amp;str) -&amp;gt; bool {
    attempt == &amp;quot;green&amp;quot; || attempt == &amp;quot;blue&amp;quot; || attempt == &amp;quot;red&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have another exercise that asks for a similar request: &lt;code&gt;compile without changing the function signature!&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings2-rs-errors&quot;&gt;strings2.rs errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;strings&amp;#x2F;strings2.rs failed! Please try again. Here is the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;strings&amp;#x2F;strings2.rs:9:24
   |
9  |     if is_a_color_word(word) {
   |        --------------- ^^^^
   |        |               |
   |        |               expected `&amp;amp;str`, found struct `String`
   |        |               help: consider borrowing here: `&amp;amp;word`
   |        arguments to this function are incorrect
   |
note: function defined here
  --&amp;gt; exercises&amp;#x2F;strings&amp;#x2F;strings2.rs:16:4
   |
16 | fn is_a_color_word(attempt: &amp;amp;str) -&amp;gt; bool {
   |    ^^^^^^^^^^^^^^^ -------------
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So, we&#x27;re being told a couple of things, that the arguments in our function are incorrect and that the the compiler is expecting a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; but it&#x27;s finding a &lt;code&gt;String&lt;&#x2F;code&gt; instead. So let&#x27;s try making it an &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; by adding a reference to &lt;code&gt;word&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings2-rs-solution&quot;&gt;strings2.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let word = String::from(&amp;quot;green&amp;quot;); &amp;#x2F;&amp;#x2F; Try not changing this line :)
    if is_a_color_word(&amp;amp;word) { &amp;#x2F;&amp;#x2F; added `&amp;amp;` to `word`
        println!(&amp;quot;That is a color word I know!&amp;quot;);
    } else {
        println!(&amp;quot;That is not a color word I know.&amp;quot;);
    }
}

fn is_a_color_word(attempt: &amp;amp;str) -&amp;gt; bool {
    attempt == &amp;quot;green&amp;quot; || attempt == &amp;quot;blue&amp;quot; || attempt == &amp;quot;red&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;The &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; operator to create a reference:&lt;&#x2F;strong&gt; The &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; operator in Rust is used to create a reference to a value. When you write &lt;code&gt;&amp;amp;word&lt;&#x2F;code&gt; in the call to &lt;code&gt;is_a_color_word(&amp;amp;word)&lt;&#x2F;code&gt;, you are passing a reference to &lt;code&gt;word&lt;&#x2F;code&gt; rather than &lt;code&gt;word&lt;&#x2F;code&gt; itself. This is important because the function &lt;code&gt;is_a_color_word&lt;&#x2F;code&gt; is expecting a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; (a string slice), not a &lt;code&gt;String&lt;&#x2F;code&gt;. If you tried to pass &lt;code&gt;word&lt;&#x2F;code&gt; directly, Rust would raise a type mismatch error because &lt;code&gt;word&lt;&#x2F;code&gt; is a &lt;code&gt;String&lt;&#x2F;code&gt; and not a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;. By using &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt;, you&#x27;re allowing &lt;code&gt;is_a_color_word&lt;&#x2F;code&gt; to borrow &lt;code&gt;word&lt;&#x2F;code&gt; as a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; for the duration of the function call.&lt;&#x2F;p&gt;
&lt;p&gt;With that we&#x27;re compiling here too, simple enough, we get the following print out:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
That is a color word I know!

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we change the line &lt;code&gt;let word = String::from(&amp;quot;red&amp;quot;)&lt;&#x2F;code&gt; or &lt;code&gt;&amp;quot;blue&amp;quot;&lt;&#x2F;code&gt; we&#x27;d continue to get the same printout but, if we change it say to &lt;code&gt;purple&lt;&#x2F;code&gt; we get this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
That is not a color word I know.

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;strings3-rs&quot;&gt;strings3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; strings3.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn trim_me(input: &amp;amp;str) -&amp;gt; String {
    &amp;#x2F;&amp;#x2F; TODO: Remove whitespace from both ends of a string!
    input.().to_string()
}

fn compose_me(input: &amp;amp;str) -&amp;gt; String {
    &amp;#x2F;&amp;#x2F; TODO: Add &amp;quot; world!&amp;quot; to the string! There&amp;#x27;s multiple ways to do this!
    let mut result = input.to_owned();
    result.push_str(&amp;quot; world!&amp;quot;);
    result
}

fn replace_me(input: &amp;amp;str) -&amp;gt; String {
    &amp;#x2F;&amp;#x2F; TODO: Replace &amp;quot;cars&amp;quot; in the string with &amp;quot;balloons&amp;quot;!
    input.replace(&amp;quot;cars&amp;quot;, &amp;quot;balloons&amp;quot;)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn trim_a_string() {
        assert_eq!(trim_me(&amp;quot;Hello!     &amp;quot;), &amp;quot;Hello!&amp;quot;);
        assert_eq!(trim_me(&amp;quot;  What&amp;#x27;s up!&amp;quot;), &amp;quot;What&amp;#x27;s up!&amp;quot;);
        assert_eq!(trim_me(&amp;quot;   Hola!  &amp;quot;), &amp;quot;Hola!&amp;quot;);
    }

    #[test]
    fn compose_a_string() {
        assert_eq!(compose_me(&amp;quot;Hello&amp;quot;), &amp;quot;Hello world!&amp;quot;);
        assert_eq!(compose_me(&amp;quot;Goodbye&amp;quot;), &amp;quot;Goodbye world!&amp;quot;);
    }

    #[test]
    fn replace_a_string() {
        assert_eq!(replace_me(&amp;quot;I think cars are cool&amp;quot;), &amp;quot;I think balloons are cool&amp;quot;);
        assert_eq!(replace_me(&amp;quot;I love to look at cars&amp;quot;), &amp;quot;I love to look at balloons&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So here we have to make our code compile and pass the tests, we get a list of &lt;code&gt;TODO&lt;&#x2F;code&gt; items on how to finish our functions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings3-rs-errors&quot;&gt;strings3.rs errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;strings&amp;#x2F;strings3.rs failed! Please try again. Here is the output:
error: expected expression, found `?`
 --&amp;gt; exercises&amp;#x2F;strings&amp;#x2F;strings3.rs:8:5
  |
8 |     ???
  |     ^ expected expression

error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;strings&amp;#x2F;strings3.rs:13:5
   |
13 |     ???
   |     ^ expected expression

error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;strings&amp;#x2F;strings3.rs:18:5
   |
18 |     ???
   |     ^ expected expression

error: aborting due to 3 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our errors are clearly due to the missing function bodies.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings3-rs-solution&quot;&gt;strings3.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn trim_me(input: &amp;amp;str) -&amp;gt; String {
    &amp;#x2F;&amp;#x2F; TODO: Remove whitespace from both ends of a string!
    input.trim().to_string()
}

fn compose_me(input: &amp;amp;str) -&amp;gt; String {
    &amp;#x2F;&amp;#x2F; TODO: Add &amp;quot; world!&amp;quot; to the string! There&amp;#x27;s multiple ways to do this!
    let mut result = input.to_string();
    result.push_str(&amp;quot; world!&amp;quot;);
    result
}

fn replace_me(input: &amp;amp;str) -&amp;gt; String {
    &amp;#x2F;&amp;#x2F; TODO: Replace &amp;quot;cars&amp;quot; in the string with &amp;quot;balloons&amp;quot;!
    input.replace(&amp;quot;cars&amp;quot;, &amp;quot;ballons&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To pass the test and finalize the functions we have to use &lt;code&gt;methods&lt;&#x2F;code&gt; on each of the &lt;code&gt;input&lt;&#x2F;code&gt; parameters that are being passed through.&lt;&#x2F;p&gt;
&lt;p&gt;In our first function &lt;code&gt;trim_me&lt;&#x2F;code&gt; as the comment states we have to remove whitespace from the string. The &lt;code&gt;trim()&lt;&#x2F;code&gt; method does just that and we can use &lt;code&gt;.to_string&lt;&#x2F;code&gt; to convert our parameter &lt;code&gt;input&lt;&#x2F;code&gt; from a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; to a &lt;code&gt;String&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In the &lt;code&gt;compose_me&lt;&#x2F;code&gt; there are a few different ways to solve this, I chose to create a new variable &lt;code&gt;result&lt;&#x2F;code&gt; that contains the &lt;code&gt;input.to_string()&lt;&#x2F;code&gt; and then we use the &lt;code&gt;push_str&lt;&#x2F;code&gt; method on &lt;code&gt;result&lt;&#x2F;code&gt; to add the &amp;quot;&lt;code&gt;world!&lt;&#x2F;code&gt;&amp;quot; to our newly created &lt;code&gt;String&lt;&#x2F;code&gt;. Then finally return the &lt;code&gt;result&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Finally in our &lt;code&gt;replace_me&lt;&#x2F;code&gt; function we use the &lt;code&gt;replace()&lt;&#x2F;code&gt; method to simply replace &lt;code&gt;&amp;quot;cars&amp;quot;&lt;&#x2F;code&gt; to: &lt;code&gt;&amp;quot;balloons&amp;quot;&lt;&#x2F;code&gt; and that should do it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings4-rs&quot;&gt;strings4.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; strings4.rs

&amp;#x2F;&amp;#x2F; Ok, here are a bunch of values-- some are `String`s, some are `&amp;amp;str`s. Your
&amp;#x2F;&amp;#x2F; task is to call one of these two functions on each value depending on what
&amp;#x2F;&amp;#x2F; you think each value is. That is, add either `string_slice` or `string`
&amp;#x2F;&amp;#x2F; before the parentheses on each line. If you&amp;#x27;re right, it will compile!
&amp;#x2F;&amp;#x2F; No hints this time!

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn string_slice(arg: &amp;amp;str) {
    println!(&amp;quot;{}&amp;quot;, arg);
}
fn string(arg: String) {
    println!(&amp;quot;{}&amp;quot;, arg);
}

fn main() {
    &amp;amp;str(&amp;quot;blue&amp;quot;);
    ???(&amp;quot;red&amp;quot;.to_string());
    ???(String::from(&amp;quot;hi&amp;quot;));
    ???(&amp;quot;rust is fun!&amp;quot;.to_owned());
    ???(&amp;quot;nice weather&amp;quot;.into());
    ???(format!(&amp;quot;Interpolation {}&amp;quot;, &amp;quot;Station&amp;quot;));
    ???(&amp;amp;String::from(&amp;quot;abc&amp;quot;)[0..1]);
    ???(&amp;quot;  hello there &amp;quot;.trim());
    ???(&amp;quot;Happy Monday!&amp;quot;.to_string().replace(&amp;quot;Mon&amp;quot;, &amp;quot;Tues&amp;quot;));
    ???(&amp;quot;mY sHiFt KeY iS sTiCkY&amp;quot;.to_lowercase());
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright this seems easy enough we have to understand if the value is a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; or a &lt;code&gt;String&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings4-rs-errors&quot;&gt;strings4.rs errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;strings&amp;#x2F;strings4.rs failed! Please try again. Here is the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;strings&amp;#x2F;strings4.rs:19:5
   |
19 |     ???(&amp;quot;blue&amp;quot;);
   |     ^ expected expression

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have one error, but it is obvious that we&#x27;ll have a few more after where we have the question marks.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings4-rs-solution&quot;&gt;strings4.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn string_slice(arg: &amp;amp;str) {
    println!(&amp;quot;{}&amp;quot;, arg);
}
fn string(arg: String) {
    println!(&amp;quot;{}&amp;quot;, arg);
}

fn main() {
    string_slice(&amp;quot;blue&amp;quot;);
    string(&amp;quot;red&amp;quot;.to_string());
    string(String::from(&amp;quot;hi&amp;quot;));
    string(&amp;quot;rust is fun!&amp;quot;.to_owned());
    string_slice(&amp;quot;nice weather&amp;quot;.into());
    string(format!(&amp;quot;Interpolation {}&amp;quot;, &amp;quot;Station&amp;quot;));
    string_slice(&amp;amp;String::from(&amp;quot;abc&amp;quot;)[0..1]);
    string_slice(&amp;quot;  hello there &amp;quot;.trim());
    string(&amp;quot;Happy Monday!&amp;quot;.to_string().replace(&amp;quot;Mon&amp;quot;, &amp;quot;Tues&amp;quot;));
    string(&amp;quot;mY sHiFt KeY iS sTiCkY&amp;quot;.to_lowercase());
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Choosing between &lt;code&gt;string_slice&lt;&#x2F;code&gt; and &lt;code&gt;string&lt;&#x2F;code&gt; in &lt;code&gt;strings4.rs&lt;&#x2F;code&gt;:&lt;&#x2F;strong&gt; The &lt;code&gt;string_slice&lt;&#x2F;code&gt; function takes a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; (string slice) argument, while &lt;code&gt;string&lt;&#x2F;code&gt; function takes a &lt;code&gt;String&lt;&#x2F;code&gt; argument. When you&#x27;re calling these functions in &lt;code&gt;main()&lt;&#x2F;code&gt;, you need to determine whether each argument is a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; or a &lt;code&gt;String&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;For instance, &lt;code&gt;&amp;quot;blue&amp;quot;&lt;&#x2F;code&gt; is a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;, because it&#x27;s a string literal. In Rust, string literals are string slices.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;red&amp;quot;.to_string()&lt;&#x2F;code&gt;, on the other hand, is a &lt;code&gt;String&lt;&#x2F;code&gt;. As explained earlier, &lt;code&gt;.to_string()&lt;&#x2F;code&gt; is a method that converts a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; to a &lt;code&gt;String&lt;&#x2F;code&gt; by allocating heap memory and copying the string there.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;String::from(&amp;quot;hi&amp;quot;)&lt;&#x2F;code&gt; is also a &lt;code&gt;String&lt;&#x2F;code&gt;. &lt;code&gt;String::from&lt;&#x2F;code&gt; is a function that performs the same task as &lt;code&gt;.to_string()&lt;&#x2F;code&gt;, creating an owned string from a string literal or a string slice.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;nice weather&amp;quot;.into()&lt;&#x2F;code&gt; is an interesting case. The &lt;code&gt;.into()&lt;&#x2F;code&gt; method is a very generic conversion method that converts between various types. In this context, it will automatically be resolved to &lt;code&gt;String&lt;&#x2F;code&gt;, so it should be passed to &lt;code&gt;string&lt;&#x2F;code&gt; function. However, it&#x27;s worth noting that this automatic resolution is based on the current context and it can lead to potential confusion if the type resolution is ambiguous.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Understanding how to work with strings is essential in Rust, as it&#x27;s a common part of most programming tasks. We&#x27;ve learned that Rust has two main string types: &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; and &lt;code&gt;String&lt;&#x2F;code&gt;. The &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; type is a string slice, which is an immutable reference to a string, whereas &lt;code&gt;String&lt;&#x2F;code&gt; is an owned string that can be modified.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ve also practiced converting between these two types using the &lt;code&gt;to_string()&lt;&#x2F;code&gt; method, and we&#x27;ve learned how to create references to strings using the &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; operator. Additionally, we&#x27;ve used various methods to manipulate strings, such as &lt;code&gt;trim()&lt;&#x2F;code&gt;, &lt;code&gt;push_str()&lt;&#x2F;code&gt;, and &lt;code&gt;replace()&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The exercises and solutions provided in this post are a good starting point for understanding and mastering strings in Rust. Continue experimenting and practicing with these concepts to gain a solid understanding of how strings work in Rust.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>09 Rustlings Enums</title>
          <pubDate>Wed, 07 Jun 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/09-rustlings-enums/</link>
          <guid>https://desmodrone.github.io/posts/09-rustlings-enums/</guid>
          <description xml:base="https://desmodrone.github.io/posts/09-rustlings-enums/">&lt;p&gt;Rust allows you to define types called &amp;quot;enums&amp;quot; which enumerate possible values.
Enums are a feature in many languages, but their capabilities differ in each language. Rustâ€™s enums are most similar to algebraic data types in functional languages, such as F#, OCaml, and Haskell.
Useful in combination with enums is Rust&#x27;s &amp;quot;pattern matching&amp;quot; facility, which makes it easy to run different code for different values of an enumeration.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch06-00-enums.html&quot;&gt;Enums&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch18-03-pattern-syntax.html&quot;&gt;Pattern syntax&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;enums1-rs&quot;&gt;&lt;code&gt;enums1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; enums1.rs
&amp;#x2F;&amp;#x2F; No hints this time! ;)

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[derive(Debug)]
enum Message {
    &amp;#x2F;&amp;#x2F; TODO: define a few types of messages as used below
}

fn main() {
    println!(&amp;quot;{:?}&amp;quot;, Message::Quit);
    println!(&amp;quot;{:?}&amp;quot;, Message::Echo);
    println!(&amp;quot;{:?}&amp;quot;, Message::Move);
    println!(&amp;quot;{:?}&amp;quot;, Message::ChangeColor);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we have our code, with not much instruction and no hint this time! But we do have a message in the comments: &lt;code&gt;TODO: define a few types of messages as used below&lt;&#x2F;code&gt;.  Let&#x27;s take a look at the errors as well.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;enums1-rs-errors&quot;&gt;&lt;code&gt;enums1.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;enums&amp;#x2F;enums1.rs failed! Please try again. Here is the output:

error[E0599]: no variant or associated item named `Quit` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums1.rs:12:31
   |
7  | enum Message {
   | ------------ variant or associated item `Quit` not found for this enum
...
12 |     println!(&amp;quot;{:?}&amp;quot;, Message::Quit);
   |                               ^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums1.rs:13:31
   |
7  | enum Message {
   | ------------ variant or associated item `Echo` not found for this enum
...
13 |     println!(&amp;quot;{:?}&amp;quot;, Message::Echo);
   |                               ^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `Move` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums1.rs:14:31
   |
7  | enum Message {
   | ------------ variant or associated item `Move` not found for this enum
...
14 |     println!(&amp;quot;{:?}&amp;quot;, Message::Move);
   |                               ^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums1.rs:15:31
   |
7  | enum Message {
   | ------------ variant or associated item `ChangeColor` not found for this enum
...
15 |     println!(&amp;quot;{:?}&amp;quot;, Message::ChangeColor);
   |                               ^^^^^^^^^^^ variant or associated item not found in `Message`

error: aborting due to 4 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our errors are pretty straight forward here, we essentially have a repeating messages for each of these errors&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;no variant or associated item named `Quit` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums1.rs:12:31
   |
7  | enum Message {
   | ------------ variant or associated item `Quit` not found for this enum
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which is telling us that we&#x27;re missing items in the &lt;code&gt;enum&lt;&#x2F;code&gt; which of course makes sense since we know that we have to fill out the rest of the &lt;code&gt;enum&lt;&#x2F;code&gt;. What&#x27;s nice is that the message is very clear and show&#x27;s us where our item are missing which is clearly the &lt;code&gt;enum Message&lt;&#x2F;code&gt;. So let&#x27;s get to it and fill out that &lt;code&gt;enum&lt;&#x2F;code&gt; and see what happens.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;enums1-rs-solution&quot;&gt;&lt;code&gt;enums1.rs&lt;&#x2F;code&gt;  solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[derive(Debug)]
enum Message {
    Quit,
    Echo,
    Move,
    ChangeColor,
}

fn main() {
    println!(&amp;quot;{:?}&amp;quot;, Message::Quit);
    println!(&amp;quot;{:?}&amp;quot;, Message::Echo);
    println!(&amp;quot;{:?}&amp;quot;, Message::Move);
    println!(&amp;quot;{:?}&amp;quot;, Message::ChangeColor);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;...and this compiles, this is relatively simple as all we had to do is look at the &lt;code&gt;main()&lt;&#x2F;code&gt; confirmed with the &lt;code&gt;errors&lt;&#x2F;code&gt; and we&#x27;ve got our complete &lt;code&gt;enum Message&lt;&#x2F;code&gt;, we didn&#x27;t need any hints now did we? Here&#x27;s our output:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Quit
Echo
Move
ChangeColor

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;enums2-rs&quot;&gt;&lt;code&gt;enums2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; enums2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[derive(Debug)]
enum Message {
    &amp;#x2F;&amp;#x2F; TODO: define the different variants used below
}

impl Message {
    fn call(&amp;amp;self) {
        println!(&amp;quot;{:?}&amp;quot;, self);
    }
}

fn main() {
    let messages = [
        Message::Move { x: 10, y: 30 },
        Message::Echo(String::from(&amp;quot;hello world&amp;quot;)),
        Message::ChangeColor(200, 255, 255),
        Message::Quit,
    ];

    for message in &amp;amp;messages {
        message.call();
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have a similar set-up here with what we saw in the previous exercise in which we have to define the different variants that are used in the rest of the code, in this case in our &lt;code&gt;main()&lt;&#x2F;code&gt; function. Let&#x27;s take a look at the errors like we always do.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;enums2-rs-errors&quot;&gt;&lt;code&gt;enums2.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;enums&amp;#x2F;enums2.rs failed! Please try again. Here is the output:
error[E0599]: no variant named `Move` found for enum `Message`
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums2.rs:19:18
   |
7  | enum Message {
   | ------------ variant `Move` not found here
...
19 |         Message::Move { x: 10, y: 30 },
   |                  ^^^^ variant not found in `Message`

error[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums2.rs:20:18
   |
7  | enum Message {
   | ------------ variant or associated item `Echo` not found for this enum
...
20 |         Message::Echo(String::from(&amp;quot;hello world&amp;quot;)),
   |                  ^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums2.rs:21:18
   |
7  | enum Message {
   | ------------ variant or associated item `ChangeColor` not found for this enum
...
21 |         Message::ChangeColor(200, 255, 255),
   |                  ^^^^^^^^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `Quit` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums2.rs:22:18
   |
7  | enum Message {
   | ------------ variant or associated item `Quit` not found for this enum
...
22 |         Message::Quit,
   |                  ^^^^ variant or associated item not found in `Message`

error: aborting due to 4 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Errors are similar to last time as well, but we can see that there&#x27;s something different so let&#x27;s take a look at how to solve this problem.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;enums2-rs-solution&quot;&gt;&lt;code&gt;enums2.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;p&gt;We can see that in the &lt;code&gt;main()&lt;&#x2F;code&gt; there isn&#x27;t simply a name of a enum variant like &lt;code&gt;Move&lt;&#x2F;code&gt; or &lt;code&gt;Echo&lt;&#x2F;code&gt; but there&#x27;s data attached to it. This is because unlike in other languages, &lt;code&gt;enums&lt;&#x2F;code&gt; in Rust can have data like structs, strings, integers, in fact you can even include another &lt;code&gt;enum&lt;&#x2F;code&gt;. So in this case we solve this problem by adding the variant with the data that is expected. If we look at  &lt;code&gt;Move&lt;&#x2F;code&gt;  we add the &lt;code&gt;{ x: i32, y: i32}&lt;&#x2F;code&gt; struct information. Let&#x27;s do the same for the rest of the variants.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[derive(Debug)]
enum Message {
    Move { x: i32, y: i32 },
    Echo(String),
    ChangeColor(i32, i32, i32),
    Quit,
}
impl Message {
    fn call(&amp;amp;self) {
        println!(&amp;quot;{:?}&amp;quot;, self);
    }
}

fn main() {
    let messages = [
        Message::Move { x: 10, y: 30 },
        Message::Echo(String::from(&amp;quot;hello world&amp;quot;)),
        Message::ChangeColor(200, 255, 255),
        Message::Quit,
    ];

    for message in &amp;amp;messages {
        message.call();
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With that our code compiles, we get our expected output with the different types of data attached. On to our final &lt;code&gt;enum&lt;&#x2F;code&gt; exercise.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Move { x: 10, y: 30 }
Echo(&amp;quot;hello world&amp;quot;)
ChangeColor(200, 255, 255)
Quit

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;enums3-rs&quot;&gt;&lt;code&gt;enums3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; enums3.rs
&amp;#x2F;&amp;#x2F; Address all the TODOs to make the tests pass!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

enum Message {
    &amp;#x2F;&amp;#x2F; TODO: implement the message variant types based on their usage below
}

struct Point {
    x: u8,
    y: u8,
}

struct State {
    color: (u8, u8, u8),
    position: Point,
    quit: bool,
}

impl State {
    fn change_color(&amp;amp;mut self, color: (u8, u8, u8)) {
        self.color = color;
    }

    fn quit(&amp;amp;mut self) {
        self.quit = true;
    }

    fn echo(&amp;amp;self, s: String) {
        println!(&amp;quot;{}&amp;quot;, s);
    }

    fn move_position(&amp;amp;mut self, p: Point) {
        self.position = p;
    }

    fn process(&amp;amp;mut self, message: Message) {
        &amp;#x2F;&amp;#x2F; TODO: create a match expression to process the different message variants
        &amp;#x2F;&amp;#x2F; Remember: When passing a tuple as a function argument, you&amp;#x27;ll need extra parentheses: fn function((t, u, p, l, e))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_match_message_call() {
        let mut state = State {
            quit: false,
            position: Point { x: 0, y: 0 },
            color: (0, 0, 0),
        };
        state.process(Message::ChangeColor(255, 0, 255));
        state.process(Message::Echo(String::from(&amp;quot;hello world&amp;quot;)));
        state.process(Message::Move(Point { x: 10, y: 15 }));
        state.process(Message::Quit);

        assert_eq!(state.color, (255, 0, 255));
        assert_eq!(state.position.x, 10);
        assert_eq!(state.position.y, 15);
        assert_eq!(state.quit, true);
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this exercise we see 2 different locations in which we have to complete the code.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Is the &lt;code&gt;enum Message&lt;&#x2F;code&gt; which is completely empty, we&#x27;ve done this a few times so it shouldn&#x27;t be too difficult.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;enum Message {
    &amp;#x2F;&amp;#x2F; TODO: implement the message variant types based on their usage below
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;The next area is the &lt;code&gt;process()&lt;&#x2F;code&gt; function, inside of our &lt;code&gt;impl State&lt;&#x2F;code&gt; in which we get instructions on how to complete by using a &lt;code&gt;match&lt;&#x2F;code&gt; expression.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    fn process(&amp;amp;mut self, message: Message) {
        &amp;#x2F;&amp;#x2F; TODO: create a match expression to process the different message variants
        &amp;#x2F;&amp;#x2F; Remember: When passing a tuple as a function argument, you&amp;#x27;ll need extra parentheses: fn function((t, u, p, l, e))
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now, we take a look at the errors to see if there are any additional hints for completing our task&lt;&#x2F;p&gt;
&lt;h2 id=&quot;enums3-rs-errors&quot;&gt;&lt;code&gt;enums3.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;enums&amp;#x2F;enums3.rs failed! Please try again. Here is the output:
error[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums3.rs:56:32
   |
7  | enum Message {
   | ------------ variant or associated item `ChangeColor` not found for this enum
...
56 |         state.process(Message::ChangeColor(255, 0, 255));
   |                                ^^^^^^^^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums3.rs:57:32
   |
7  | enum Message {
   | ------------ variant or associated item `Echo` not found for this enum
...
57 |         state.process(Message::Echo(String::from(&amp;quot;hello world&amp;quot;)));
   |                                ^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `Move` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums3.rs:58:32
   |
7  | enum Message {
   | ------------ variant or associated item `Move` not found for this enum
...
58 |         state.process(Message::Move(Point { x: 10, y: 15 }));
   |                                ^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `Quit` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums3.rs:59:32
   |
7  | enum Message {
   | ------------ variant or associated item `Quit` not found for this enum
...
59 |         state.process(Message::Quit);
   |                                ^^^^ variant or associated item not found in `Message`

error: aborting due to 4 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So far, it looks pretty straight forward once again, the compiler is just telling us about the missing variants, so let&#x27;s start filling out some code.&lt;&#x2F;p&gt;
&lt;p&gt;If we fill out our &lt;code&gt;Message enum&lt;&#x2F;code&gt; in a similar way we have been in the previous exercises, but instead of passing in the coordinates directly to &lt;code&gt;Move&lt;&#x2F;code&gt; we pass in &lt;code&gt;Point&lt;&#x2F;code&gt; because we see that&#x27;s what we need to match in tests below.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;enum Message {
    Move (Point),
    Echo(String),
    ChangeColor((u8, u8, u8)),
    Quit,
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s take a look at our next code block that we need to fill in and the instructions.
We&#x27;re told to use a match expression and to remember that when passing a tuple as a function argument we need to add extra parentheses. Alright, noted.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    fn process(&amp;amp;mut self, message: Message) {
        &amp;#x2F;&amp;#x2F; TODO: create a match expression to process the different message variants
        &amp;#x2F;&amp;#x2F; Remember: When passing a tuple as a function argument, you&amp;#x27;ll need extra parentheses: fn function((t, u, p, l, e))
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So here we&#x27;re going to go through the solution step-by-step since it&#x27;s something that&#x27;s a little more than we&#x27;ve had with any of the previous &lt;code&gt;enum&lt;&#x2F;code&gt; exercises.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;process-function&quot;&gt;&lt;code&gt;process ()&lt;&#x2F;code&gt; function&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn process(&amp;amp;mut self, message: Message) {
        match message {
            Message::ChangeColor((r, g, b)) =&amp;gt; self.change_color((r, g, b)),
            Message::Echo(s) =&amp;gt; self.echo(s),
            Message::Move(p) =&amp;gt; self.move_position(p),
            Message::Quit =&amp;gt; self.quit(),
        }
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol&gt;
&lt;li&gt;We see that the &lt;code&gt;process&lt;&#x2F;code&gt; function that takes a mutable reference to &lt;code&gt;self&lt;&#x2F;code&gt; (an instance of the &lt;code&gt;State&lt;&#x2F;code&gt; struct) and a &lt;code&gt;message&lt;&#x2F;code&gt; of type &lt;code&gt;Message&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;We use the &lt;code&gt;match&lt;&#x2F;code&gt; keyword to pattern match the &lt;code&gt;message&lt;&#x2F;code&gt; against different variants of the &lt;code&gt;Message&lt;&#x2F;code&gt; enum.&lt;&#x2F;li&gt;
&lt;li&gt;The first match arm &lt;code&gt;Message::ChangeColor(r, g, b) =&amp;gt; self.change_color((r, g, b))&lt;&#x2F;code&gt; matches the &lt;code&gt;Message::ChangeColor&lt;&#x2F;code&gt; variant. It deconstructs the tuple &lt;code&gt;(r, g, b)&lt;&#x2F;code&gt; by providing individual variables &lt;code&gt;r&lt;&#x2F;code&gt;, &lt;code&gt;g&lt;&#x2F;code&gt;, and &lt;code&gt;b&lt;&#x2F;code&gt; in the pattern. This allows us to directly access the values of &lt;code&gt;r&lt;&#x2F;code&gt;, &lt;code&gt;g&lt;&#x2F;code&gt;, and &lt;code&gt;b&lt;&#x2F;code&gt; in the &lt;code&gt;Message::ChangeColor&lt;&#x2F;code&gt; variant. Then, it calls the &lt;code&gt;change_color&lt;&#x2F;code&gt; method of &lt;code&gt;self&lt;&#x2F;code&gt; (an instance of &lt;code&gt;State&lt;&#x2F;code&gt;) passing the values &lt;code&gt;(r, g, b)&lt;&#x2F;code&gt; as arguments.&lt;&#x2F;li&gt;
&lt;li&gt;The second match arm &lt;code&gt;Message::Echo(s) =&amp;gt; self.echo(s)&lt;&#x2F;code&gt; matches the &lt;code&gt;Message::Echo&lt;&#x2F;code&gt; variant. It deconstructs the &lt;code&gt;String&lt;&#x2F;code&gt; value &lt;code&gt;s&lt;&#x2F;code&gt; from the &lt;code&gt;Message&lt;&#x2F;code&gt; enum variant and calls the &lt;code&gt;echo&lt;&#x2F;code&gt; method of &lt;code&gt;self&lt;&#x2F;code&gt; (an instance of &lt;code&gt;State&lt;&#x2F;code&gt;) passing &lt;code&gt;s&lt;&#x2F;code&gt; as an argument.&lt;&#x2F;li&gt;
&lt;li&gt;The third match arm &lt;code&gt;Message::Move(p) =&amp;gt; self.move_position(p)&lt;&#x2F;code&gt; matches the &lt;code&gt;Message::Move&lt;&#x2F;code&gt; variant. It deconstructs the &lt;code&gt;Point&lt;&#x2F;code&gt; value &lt;code&gt;p&lt;&#x2F;code&gt; from the &lt;code&gt;Message&lt;&#x2F;code&gt; enum variant and calls the &lt;code&gt;move_position&lt;&#x2F;code&gt; method of &lt;code&gt;self&lt;&#x2F;code&gt; (an instance of &lt;code&gt;State&lt;&#x2F;code&gt;) passing &lt;code&gt;p&lt;&#x2F;code&gt; as an argument.&lt;&#x2F;li&gt;
&lt;li&gt;The fourth match arm &lt;code&gt;Message::Quit =&amp;gt; self.quit()&lt;&#x2F;code&gt; matches the &lt;code&gt;Message::Quit&lt;&#x2F;code&gt; variant. It doesn&#x27;t need to deconstruct any values, so we simply call the &lt;code&gt;quit&lt;&#x2F;code&gt; method of &lt;code&gt;self&lt;&#x2F;code&gt; (an instance of &lt;code&gt;State&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;By using the &lt;code&gt;match&lt;&#x2F;code&gt; expression, we are able to handle different variants of the &lt;code&gt;Message&lt;&#x2F;code&gt; enum and perform the appropriate actions based on each variant.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;enums3-rs-solution&quot;&gt;&lt;code&gt;enums3.rs&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;p&gt;Here&#x27;s the full block of code for reference&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; enums3.rs
&amp;#x2F;&amp;#x2F; Address all the TODOs to make the tests pass!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

enum Message {
    Move(Point),
    Echo(String),
    ChangeColor((u8, u8, u8)), &amp;#x2F;&amp;#x2F; remeber the double parentheses
    Quit,
}

struct Point {
    x: u8,
    y: u8,
}

struct State {
    color: (u8, u8, u8),
    position: Point,
    quit: bool,
}

impl State {
    fn change_color(&amp;amp;mut self, color: (u8, u8, u8)) {
        self.color = color;
    }

    fn quit(&amp;amp;mut self) {
        self.quit = true;
    }

    fn echo(&amp;amp;self, s: String) {
        println!(&amp;quot;{}&amp;quot;, s);
    }

    fn move_position(&amp;amp;mut self, p: Point) {
        self.position = p;
    }

    fn process(&amp;amp;mut self, message: Message) {
        match message {&amp;#x2F;&amp;#x2F; remeber the double parentheses in ((r, g, b))
            Message::ChangeColor((r, g, b)) =&amp;gt; self.change_color((r, g, b)),
            Message::Echo(s) =&amp;gt; self.echo(s),
            Message::Move(p) =&amp;gt; self.move_position(p),
            Message::Quit =&amp;gt; self.quit(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_match_message_call() {
        let mut state = State {
            quit: false,
            position: Point { x: 0, y: 0 },
            color: (0, 0, 0),
        };
        state.process(Message::ChangeColor(255, 0, 255));
        state.process(Message::Echo(String::from(&amp;quot;hello world&amp;quot;)));
        state.process(Message::Move(Point { x: 10, y: 15 }));
        state.process(Message::Quit);

        assert_eq!(state.color, (255, 0, 255));
        assert_eq!(state.position.x, 10);
        assert_eq!(state.position.y, 15);
        assert_eq!(state.quit, true);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this post, we gained insights into the usage of enums. We discovered how enums can be used to define different types of messages and handle them effectively. By exploring code examples, we learned how to:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Define enum variants and handle missing variants to ensure successful compilation.&lt;&#x2F;li&gt;
&lt;li&gt;Introduce enum variants with associated data for more complex scenarios.&lt;&#x2F;li&gt;
&lt;li&gt;Extend the concept by implementing methods and matching different message variants.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Overall, we discovered the flexibility and power of enums in Rust, enabling us to handle diverse message types and execute appropriate actions based on the variants.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>08 Rustlings Structs</title>
          <pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/08-rustlings-structs/</link>
          <guid>https://desmodrone.github.io/posts/08-rustlings-structs/</guid>
          <description xml:base="https://desmodrone.github.io/posts/08-rustlings-structs/">&lt;p&gt;From the ReadMe:
Rust has three struct types: a classic C struct, a tuple struct, and a unit struct.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch05-01-defining-structs.html&quot;&gt;Structures&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch05-03-method-syntax.html&quot;&gt;Method Syntax&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;structs-in-rust&quot;&gt;Structs in Rust&lt;&#x2F;h2&gt;
&lt;p&gt;In Rust, structs are versatile containers that bring together multiple values into a cohesive unit. They offer three types: classic C structs, tuple structs, and unit structs.&lt;&#x2F;p&gt;
&lt;p&gt;Classic C structs allow you to define named fields, providing an intuitive way to organize and access related data. Tuple structs, on the other hand, resemble tuples, with fields accessed through indexing rather than names. Lastly, unit structs serve as simple markers or placeholders without any fields.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s take a quick dive into the types of structs:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Classic C Structs:&lt;&#x2F;strong&gt; These are essentially collections with named fields. They are ideal for larger and more complex data structures where each piece of data has a meaningful label.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Tuple Structs:&lt;&#x2F;strong&gt; These are a kind of middle ground between tuples and classic structs. They are useful when you want to give a tuple a name for type checking or to better signify its purpose, but you don&#x27;t necessarily need to name each field.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Unit Structs:&lt;&#x2F;strong&gt; These are used in cases where a struct doesn&#x27;t need to have any data associated with it. For example, they can be used to implement traits on some type, or as markers or flags.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;With structs, you have the power to create custom data structures that suit your needs, enhancing code organization and efficiency. Explore the provided links to delve deeper into the world of structs in Rust and unlock their potential for your projects.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look at our first exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs1-rs&quot;&gt;&lt;code&gt;Structs1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; structs1.rs
    &amp;#x2F;&amp;#x2F; Address all the TODOs to make the tests pass!
    &amp;#x2F;&amp;#x2F; Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.

    &amp;#x2F;&amp;#x2F; I AM NOT DONE

    struct ColorClassicStruct {
        &amp;#x2F;&amp;#x2F; TODO: Something goes here
    }

    struct ColorTupleStruct(&amp;#x2F;* TODO: Something goes here *&amp;#x2F;);

    #[derive(Debug)]
    struct UnitLikeStruct;

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn classic_c_structs() {
            &amp;#x2F;&amp;#x2F; TODO: Instantiate a classic c struct!
            &amp;#x2F;&amp;#x2F; let green =

            assert_eq!(green.red, 0);
            assert_eq!(green.green, 255);
            assert_eq!(green.blue, 0);
        }

        #[test]
        fn tuple_structs() {
            &amp;#x2F;&amp;#x2F; TODO: Instantiate a tuple struct!
            &amp;#x2F;&amp;#x2F; let green =

            assert_eq!(green.0, 0);
            assert_eq!(green.1, 255);
            assert_eq!(green.2, 0);
        }

        #[test]
        fn unit_structs() {
            &amp;#x2F;&amp;#x2F; TODO: Instantiate a unit-like struct!
            &amp;#x2F;&amp;#x2F; let unit_like_struct =
            let message = format!(&amp;quot;{:?}s are fun!&amp;quot;, unit_like_struct);

            assert_eq!(message, &amp;quot;UnitLikeStructs are fun!&amp;quot;);
        }
    }

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So here we&#x27;re getting clear instructions on what to do. We need to implement different types of structs in each &lt;code&gt;&#x2F;&#x2F;TODO&lt;&#x2F;code&gt; section. For completeness here are our errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs1-rs-errors&quot;&gt;&lt;code&gt;Structs1.rs&lt;&#x2F;code&gt;  errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;structs&amp;#x2F;structs1.rs failed! Please try again. Here is the output:
error[E0425]: cannot find value `green` in this scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:25:20
   |
25 |         assert_eq!(green.red, 0);
   |                    ^^^^^ not found in this scope

error[E0425]: cannot find value `green` in this scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:26:20
   |
26 |         assert_eq!(green.green, 255);
   |                    ^^^^^ not found in this scope

error[E0425]: cannot find value `green` in this scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:27:20
   |
27 |         assert_eq!(green.blue, 0);
   |                    ^^^^^ not found in this scope

error[E0425]: cannot find value `green` in this scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:35:20
   |
35 |         assert_eq!(green.0, 0);
   |                    ^^^^^ not found in this scope

error[E0425]: cannot find value `green` in this scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:36:20
   |
36 |         assert_eq!(green.1, 255);
   |                    ^^^^^ not found in this scope

error[E0425]: cannot find value `green` in this scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:37:20
   |
37 |         assert_eq!(green.2, 0);
   |                    ^^^^^ not found in this scope

error[E0425]: cannot find value `unit_like_struct` in this scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:44:49
   |
14 | struct UnitLikeStruct;
   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here
...
44 |         let message = format!(&amp;quot;{:?}s are fun!&amp;quot;, unit_like_struct);
   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`

warning: unused import: `super::*`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:18:9
   |
18 |     use super::*;
   |         ^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

error: aborting due to 7 previous errors; 1 warning emitted
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;re getting 7 different errors and it looks like most of them are related to the fact that we are missing our structs so they &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; calls are failing. So let&#x27;s try and solve this.&lt;&#x2F;p&gt;
&lt;p&gt;Notice that the errors reported here are not solely due to missing structs but also due to missing variable declarations. For example, the variables &lt;code&gt;green&lt;&#x2F;code&gt; and &lt;code&gt;unit_like_struct&lt;&#x2F;code&gt; are used in the test assertions but haven&#x27;t been defined yet in the tests. This will be addressed in the following sections as we instantiate these variables along with defining and instantiating the corresponding structs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;defining-our-structs&quot;&gt;Defining our Structs&lt;&#x2F;h2&gt;
&lt;p&gt;Starting from the top of our code we see our first &lt;code&gt;TODO&#x27;s&lt;&#x2F;code&gt; in comments.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;   struct ColorClassicStruct {
        &amp;#x2F;&amp;#x2F; TODO: Something goes here
    }

    struct ColorTupleStruct(&amp;#x2F;* TODO: Something goes here *&amp;#x2F;);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have 2 different styles of structs that we need to create a &amp;quot;classic&amp;quot; and &amp;quot;tuple&amp;quot; types struct.  We fill out the structs using their usual structure and we get an indication of what is needed by looking at the &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; listed in each section. We can see that in the &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; we have values that could fit and &lt;code&gt;i32&lt;&#x2F;code&gt;&#x27;s since we see the max value is &lt;code&gt;255&lt;&#x2F;code&gt; we&#x27;ll use &lt;code&gt;i32&lt;&#x2F;code&gt;s as it&#x27;s the default value in Rust.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct ColorClassicStruct {
    red: i32,
    green: i32,
    blue: i32,
}
&amp;#x2F;&amp;#x2F; from the `assert_eq!` in `classic_c_structs` function
    &amp;#x2F;&amp;#x2F; assert_eq!(green.red, 0);
    &amp;#x2F;&amp;#x2F; assert_eq!(green.green, 255);
    &amp;#x2F;&amp;#x2F; assert_eq!(green.blue, 0);


struct ColorTupleStruct(i32, i32, i32);

&amp;#x2F;&amp;#x2F; from the `assert_eq!` in the `tuple_structs` function
    &amp;#x2F;&amp;#x2F; assert_eq!(green.0, 0);
    &amp;#x2F;&amp;#x2F; assert_eq!(green.1, 255);
    &amp;#x2F;&amp;#x2F; assert_eq!(green.2, 0);

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;ll do the same for the &lt;code&gt;ColorTupleStruct&lt;&#x2F;code&gt; getting hints as to how we need to define the Tuple struct with &lt;code&gt;(i32, i32, i32)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;instantiating-our-classic-struct&quot;&gt;Instantiating our Classic Struct&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we&#x27;ve defined our structs we need to create an new instance of our structs where we specify concrete values for each of the fields. We create instances of our struct by stating the name of the struct we can see that in our example we have this so far.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;   fn classic_c_structs() {
            &amp;#x2F;&amp;#x2F; TODO: Instantiate a classic c struct!
            &amp;#x2F;&amp;#x2F; let green =

            assert_eq!(green.red, 0);
            assert_eq!(green.green, 255);
            assert_eq!(green.blue, 0);
        }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So we&#x27;ll start by removing the comment slashes on &lt;code&gt;let green = &lt;&#x2F;code&gt; and fill out the rest with our values, again taking hints from the &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; lines we see that we should have values of &lt;code&gt;0, 255, 0&lt;&#x2F;code&gt; so let&#x27;s add that information into our &lt;code&gt;classic_c_structs()&lt;&#x2F;code&gt; function. It should like the code below:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    fn classic_c_structs() {
        &amp;#x2F;&amp;#x2F; TODO: Instantiate a classic c struct!
        let green = ColorClassicStruct {
            red: 0,
            green: 255,
            blue: 0,
        };
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;instantiating-our-tuple-struct&quot;&gt;Instantiating our Tuple Struct&lt;&#x2F;h2&gt;
&lt;p&gt;We see a similar set up for our Tuple struct with the code below. We have our &lt;code&gt;let gree =&lt;&#x2F;code&gt; commented out with a hint as to what the values should be by looking at our &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; macros&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;        fn tuple_structs() {
            &amp;#x2F;&amp;#x2F; TODO: Instantiate a tuple struct!
            &amp;#x2F;&amp;#x2F; let green =

            assert_eq!(green.0, 0);
            assert_eq!(green.1, 255);
            assert_eq!(green.2, 0);
        }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Remembering that Tuple structs have a different type of structure as we created &lt;code&gt;struct ColorTupleStruct(i32, i32, i32)&lt;&#x2F;code&gt;, we can instantiate our tuple struct in the following way:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn tuple_structs() {
        &amp;#x2F;&amp;#x2F; TODO: Instantiate a tuple struct!
        let green = ColorTupleStruct(0, 255, 0);

        assert_eq!(green.0, 0);
        assert_eq!(green.1, 255);
        assert_eq!(green.2, 0);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again taking hints from the values that we see in the &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; macro&#x27;s&lt;&#x2F;p&gt;
&lt;h2 id=&quot;instantiating-our-unit-like-structs&quot;&gt;Instantiating our Unit-Like Structs&lt;&#x2F;h2&gt;
&lt;p&gt;We have our final struct left to instantiate which if we recall from reading the The Rust Programming Language book, they are structs that have any fields. So looking at our unfinished code we see this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;        fn unit_structs() {
            &amp;#x2F;&amp;#x2F; TODO: Instantiate a unit-like struct!
            &amp;#x2F;&amp;#x2F; let unit_like_struct =
            let message = format!(&amp;quot;{:?}s are fun!&amp;quot;, unit_like_struct);

            assert_eq!(message, &amp;quot;UnitLikeStructs are fun!&amp;quot;);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So, as we don&#x27;t have any fields and hence no data stored in them we can simply finish our code like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn unit_structs() {
        &amp;#x2F;&amp;#x2F; TODO: Instantiate a unit-like struct!
        let unit_like_struct = UnitLikeStruct;
        let message = format!(&amp;quot;{:?}s are fun!&amp;quot;, unit_like_struct);

        assert_eq!(message, &amp;quot;UnitLikeStructs are fun!&amp;quot;);
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That should do the trick, let&#x27;s see if our code complies. It does!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs1-rs-solution&quot;&gt;&lt;code&gt;Structs1.rs&lt;&#x2F;code&gt;  Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
struct ColorClassicStruct {
    red: i32,
    green: i32,
    blue: i32,
}

struct ColorTupleStruct(i32, i32, i32);

#[derive(Debug)]
struct UnitLikeStruct;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn classic_c_structs() {
        &amp;#x2F;&amp;#x2F; TODO: Instantiate a classic c struct!
        let green = ColorClassicStruct {
            red: 0,
            green: 255,
            blue: 0,
        };

        assert_eq!(green.red, 0);
        assert_eq!(green.green, 255);
        assert_eq!(green.blue, 0);
    }

    #[test]
    fn tuple_structs() {
        &amp;#x2F;&amp;#x2F; TODO: Instantiate a tuple struct!
        let green = ColorTupleStruct(0, 255, 0);

        assert_eq!(green.0, 0);
        assert_eq!(green.1, 255);
        assert_eq!(green.2, 0);
    }

    #[test]
    fn unit_structs() {
        &amp;#x2F;&amp;#x2F; TODO: Instantiate a unit-like struct!
        let unit_like_struct = UnitLikeStruct;
        let message = format!(&amp;quot;{:?}s are fun!&amp;quot;, unit_like_struct);

        assert_eq!(message, &amp;quot;UnitLikeStructs are fun!&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our code compiles and we&#x27;ve finished and instantiated 3 different types of structs, our printout confirms this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âœ… Successfully tested exercises&amp;#x2F;structs&amp;#x2F;structs1.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;On to the next one!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs2-rs&quot;&gt;&lt;code&gt;structs2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; structs2.rs
&amp;#x2F;&amp;#x2F; Address all the TODOs to make the tests pass!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[derive(Debug)]
struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}

fn create_order_template() -&amp;gt; Order {
    Order {
        name: String::from(&amp;quot;Bob&amp;quot;),
        year: 2019,
        made_by_phone: false,
        made_by_mobile: false,
        made_by_email: true,
        item_number: 123,
        count: 0,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();
        &amp;#x2F;&amp;#x2F; TODO: Create your own order using the update syntax and template above!
        &amp;#x2F;&amp;#x2F; let your_order =
        assert_eq!(your_order.name, &amp;quot;Hacker in Rust&amp;quot;);
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this code example we have instructions to address all the &lt;code&gt;&#x2F;&#x2F;TODO&#x27;s&lt;&#x2F;code&gt; which we can see that we only have one at the bottom of our code in our &lt;code&gt;tests&lt;&#x2F;code&gt;.
As always let&#x27;s look at our errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs2-rs-errors&quot;&gt;&lt;code&gt;structs2.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;structs&amp;#x2F;structs2.rs failed! Please try again. Here is the output:
error[E0609]: no field `name` on type `fn() {tests::your_order}`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs2.rs:39:31
   |
39 |         assert_eq!(your_order.name, &amp;quot;Hacker in Rust&amp;quot;);
   |                               ^^^^

error[E0609]: no field `year` on type `fn() {tests::your_order}`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs2.rs:40:31
   |
40 |         assert_eq!(your_order.year, order_template.year);
   |                               ^^^^

error[E0609]: no field `made_by_phone` on type `fn() {tests::your_order}`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs2.rs:41:31
   |
41 |         assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
   |                               ^^^^^^^^^^^^^

error[E0609]: no field `made_by_mobile` on type `fn() {tests::your_order}`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs2.rs:42:31
   |
42 |         assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
   |                               ^^^^^^^^^^^^^^

error[E0609]: no field `made_by_email` on type `fn() {tests::your_order}`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs2.rs:43:31
   |
43 |         assert_eq!(your_order.made_by_email, order_template.made_by_email);
   |                               ^^^^^^^^^^^^^

error[E0609]: no field `item_number` on type `fn() {tests::your_order}`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs2.rs:44:31
   |
44 |         assert_eq!(your_order.item_number, order_template.item_number);
   |                               ^^^^^^^^^^^

error[E0609]: no field `count` on type `fn() {tests::your_order}`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs2.rs:45:31
   |
45 |         assert_eq!(your_order.count, 1);
   |                               ^^^^^

error: aborting due to 7 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have a total of 7 errors all created by our missing struct instantiation. So, let&#x27;s get it to it, we&#x27;ll start from the top.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;instantiating-your-order&quot;&gt;Instantiating &lt;code&gt;your_order&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;If we look  at our first error we get a major hint as to what the compiler expects to see: &lt;code&gt; assert_eq!(your_order.name, &amp;quot;Hacker in Rust&amp;quot;)&lt;&#x2F;code&gt; so if we take a look at our sample code and build our &lt;code&gt;Order&lt;&#x2F;code&gt; in the same way as in the &lt;code&gt;create_order_template&lt;&#x2F;code&gt; function we should have a great start for what we need to do.&lt;&#x2F;p&gt;
&lt;p&gt;If we use our &lt;code&gt;Order&lt;&#x2F;code&gt; struct as a guide we can start entering the values for each field.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;for example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn your_order() {
        let order_template = create_order_template();
        &amp;#x2F;&amp;#x2F; TODO: Create your own order using the update syntax and template above!
        let your_order = Order {
            name: String::from(&amp;quot;Hacker in Rust&amp;quot;),
            year: u32,
            made_by_phone: bool,
            made_by_mobile: bool,
            made_by_email: bool,
            item_number: u32,
            count: u32,
        };
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again we see what is expected by looking at our &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; macro, so following this format it should be pretty easy to understand what each field should be.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;        assert_eq!(your_order.name, &amp;quot;Hacker in Rust&amp;quot;); &amp;#x2F;&amp;#x2F; String
        assert_eq!(your_order.year, order_template.year); &amp;#x2F;&amp;#x2F; u32 from the `oder_template.year`
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone); &amp;#x2F;&amp;#x2F; bool
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile); &amp;#x2F;&amp;#x2F; bool
        assert_eq!(your_order.made_by_email, order_template.made_by_email); &amp;#x2F;&amp;#x2F; bool
        assert_eq!(your_order.item_number, order_template.item_number); &amp;#x2F;&amp;#x2F; u32 from `item_number`
        assert_eq!(your_order.count, 1); &amp;#x2F;&amp;#x2F; u32 defined here as `1`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So there we go now all we need to is fill out the rest of the values and it should look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let your_order = Order {
            name: String::from(&amp;quot;Hacker in Rust&amp;quot;),
            year: 2019,
            made_by_phone: false,
            made_by_mobile: false,
            made_by_email: true,
            item_number: 123,
            count: 1,
        };
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;structs2-rs-solution&quot;&gt;&lt;code&gt;structs2.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[derive(Debug)]
struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}

fn create_order_template() -&amp;gt; Order {
    Order {
        name: String::from(&amp;quot;Bob&amp;quot;),
        year: 2019,
        made_by_phone: false,
        made_by_mobile: false,
        made_by_email: true,
        item_number: 123,
        count: 0,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();
        &amp;#x2F;&amp;#x2F; TODO: Create your own order using the update syntax and template above!
        let your_order = Order {
            name: String::from(&amp;quot;Hacker in Rust&amp;quot;),
            year: 2019,
            made_by_phone: false,
            made_by_mobile: false,
            made_by_email: true,
            item_number: 123,
            count: 1,
        };
        assert_eq!(your_order.name, &amp;quot;Hacker in Rust&amp;quot;);
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âœ… Successfully tested exercises&amp;#x2F;structs&amp;#x2F;structs2.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;understanding-rust-struct-update-syntax&quot;&gt;Understanding Rust Struct Update Syntax&lt;&#x2F;h2&gt;
&lt;p&gt;Before we move on to the next exercise, it&#x27;s worth mentioning a Rust feature that could be beneficial here - the struct update syntax. It allows you to create a new instance of a struct, and selectively update some or all fields. This is especially useful when you have a template or default struct that you want to use as a base for your new struct.&lt;&#x2F;p&gt;
&lt;p&gt;To do so, you use &lt;code&gt;..&lt;&#x2F;code&gt; followed by the instance name. It should look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let your_order = Order {
    name: String::from(&amp;quot;Hacker in Rust&amp;quot;),
    count: 1,
    ..order_template
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This code creates a new &lt;code&gt;Order&lt;&#x2F;code&gt; that is the same as &lt;code&gt;order_template&lt;&#x2F;code&gt;, except &lt;code&gt;name&lt;&#x2F;code&gt; is &amp;quot;Hacker in Rust&amp;quot; and &lt;code&gt;count&lt;&#x2F;code&gt; is 1.&lt;&#x2F;p&gt;
&lt;p&gt;We can use this syntax to make our code more efficient and maintain the logic of using a template.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs2-rs-solution-with-update-syntax&quot;&gt;&lt;code&gt;structs2.rs&lt;&#x2F;code&gt; Solution with Update Syntax&lt;&#x2F;h2&gt;
&lt;p&gt;So, with struct update syntax, the solution becomes:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();
        let your_order = Order {
            name: String::from(&amp;quot;Hacker in Rust&amp;quot;),
            count: 1,
            ..order_template
        };
        assert_eq!(your_order.name, &amp;quot;Hacker in Rust&amp;quot;);
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The test function &lt;code&gt;your_order()&lt;&#x2F;code&gt; now uses the update syntax to create &lt;code&gt;your_order&lt;&#x2F;code&gt; from &lt;code&gt;order_template&lt;&#x2F;code&gt;, changing only the &lt;code&gt;name&lt;&#x2F;code&gt; and &lt;code&gt;count&lt;&#x2F;code&gt; fields, and leaving the rest as in &lt;code&gt;order_template&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This is just an alternate way of solving the problem and could be particularly useful if &lt;code&gt;Order&lt;&#x2F;code&gt; had many more fields that remained the same between &lt;code&gt;order_template&lt;&#x2F;code&gt; and &lt;code&gt;your_order&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;On to &lt;code&gt;structs3.rs&lt;&#x2F;code&gt;!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs3-rs&quot;&gt;&lt;code&gt;structs3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; structs3.rs
&amp;#x2F;&amp;#x2F; Structs contain data, but can also have logic. In this exercise we have
&amp;#x2F;&amp;#x2F; defined the Package struct and we want to test some logic attached to it.
&amp;#x2F;&amp;#x2F; Make the code compile and the tests pass!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[derive(Debug)]
struct Package {
    sender_country: String,
    recipient_country: String,
    weight_in_grams: i32,
}

impl Package {
    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -&amp;gt; Package {
        if weight_in_grams &amp;lt;= 0 {
            panic!(&amp;quot;Can not ship a weightless package.&amp;quot;)
        } else {
            Package {
                sender_country,
                recipient_country,
                weight_in_grams,
            }
        }
    }

    fn is_international(&amp;amp;self) -&amp;gt; ??? {
        &amp;#x2F;&amp;#x2F; Something goes here...
    }

    fn get_fees(&amp;amp;self, cents_per_gram: i32) -&amp;gt; ??? {
        &amp;#x2F;&amp;#x2F; Something goes here...
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn fail_creating_weightless_package() {
        let sender_country = String::from(&amp;quot;Spain&amp;quot;);
        let recipient_country = String::from(&amp;quot;Austria&amp;quot;);

        Package::new(sender_country, recipient_country, -2210);
    }

    #[test]
    fn create_international_package() {
        let sender_country = String::from(&amp;quot;Spain&amp;quot;);
        let recipient_country = String::from(&amp;quot;Russia&amp;quot;);

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(package.is_international());
    }

    #[test]
    fn create_local_package() {
        let sender_country = String::from(&amp;quot;Canada&amp;quot;);
        let recipient_country = sender_country.clone();

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(!package.is_international());
    }

    #[test]
    fn calculate_transport_fees() {
        let sender_country = String::from(&amp;quot;Spain&amp;quot;);
        let recipient_country = String::from(&amp;quot;Spain&amp;quot;);

        let cents_per_gram = 3;

        let package = Package::new(sender_country, recipient_country, 1500);

        assert_eq!(package.get_fees(cents_per_gram), 4500);
        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright this is a longer piece of code to go through but we see that there is essentially 2 areas that we need to fill out, before we look at that let&#x27;s look at the errors.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;structs&amp;#x2F;structs3.rs failed! Please try again. Here is the output:
error: expected identifier, found `{`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs3.rs:29:39
   |
16 | impl Package {
   |              - while parsing this item list starting here
...
29 |     fn is_international(&amp;amp;self) -&amp;gt; ??? {
   |                                       ^ expected identifier
...
36 | }
   | - the item list ends here

error[E0599]: no method named `is_international` found for struct `Package` in the current scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs3.rs:58:25
   |
10 | struct Package {
   | -------------- method `is_international` not found for this struct
...
58 |         assert!(package.is_international());
   |                         ^^^^^^^^^^^^^^^^ method not found in `Package`

error[E0599]: no method named `is_international` found for struct `Package` in the current scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs3.rs:68:26
   |
10 | struct Package {
   | -------------- method `is_international` not found for this struct
...
68 |         assert!(!package.is_international());
   |                          ^^^^^^^^^^^^^^^^ method not found in `Package`

error[E0599]: no method named `get_fees` found for struct `Package` in the current scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs3.rs:80:28
   |
10 | struct Package {
   | -------------- method `get_fees` not found for this struct
...
80 |         assert_eq!(package.get_fees(cents_per_gram), 4500);
   |                            ^^^^^^^^ method not found in `Package`

error[E0599]: no method named `get_fees` found for struct `Package` in the current scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs3.rs:81:28
   |
10 | struct Package {
   | -------------- method `get_fees` not found for this struct
...
81 |         assert_eq!(package.get_fees(cents_per_gram * 2), 9000);
   |                            ^^^^^^^^ method not found in `Package`

error: aborting due to 5 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright we&#x27;re seeing errors due to the missing code blocks and also the usual &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; macros that are expecting something that is not there. So let&#x27;s get to work!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;defining-return-values&quot;&gt;Defining Return Values&lt;&#x2F;h2&gt;
&lt;p&gt;First we define the return values &lt;code&gt;String&lt;&#x2F;code&gt; and an &lt;code&gt;i32&lt;&#x2F;code&gt;, instead of the &lt;code&gt;???&lt;&#x2F;code&gt; we previously had.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    fn is_international(&amp;amp;self) -&amp;gt; String {
        &amp;#x2F;&amp;#x2F; Something goes here...
    }

    fn get_fees(&amp;amp;self, cents_per_gram: i32) -&amp;gt; i32 {
        &amp;#x2F;&amp;#x2F; Something goes here...
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We still get error&#x27;s here when we save but they&#x27;re different essentially telling us that this function &lt;code&gt;has no tail&lt;&#x2F;code&gt; or essentially isn&#x27;t returning anything as we have defined it in the signature so of course we have to fix that. Here are the new errors:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;structs&amp;#x2F;structs3.rs failed! Please try again. Here is the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs3.rs:29:35
   |
29 |     fn is_international(&amp;amp;self) -&amp;gt; String {
   |        ----------------           ^^^^^^ expected struct `String`, found `()`
   |        |
   |        implicitly returns `()` as its body has no tail or `return` expression

error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs3.rs:33:48
   |
33 |     fn get_fees(&amp;amp;self, cents_per_gram: i32) -&amp;gt; i32 {
   |        --------                                ^^^ expected `i32`, found `()`
   |        |
   |        implicitly returns `()` as its body has no tail or `return` expression
   |
help: consider returning the local binding `cents_per_gram`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;is-international-function&quot;&gt;&lt;code&gt;is_international&lt;&#x2F;code&gt; function&lt;&#x2F;h2&gt;
&lt;p&gt;So let&#x27;s take breakdown the &lt;code&gt;is_interational&lt;&#x2F;code&gt; function and see what it is that we need to do inside of here.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;function-declaration&quot;&gt;Function declaration:&lt;&#x2F;h3&gt;
&lt;p&gt;The line &lt;code&gt;fn is_international(&amp;amp;self) -&amp;gt; bool&lt;&#x2F;code&gt; declares a function named &lt;code&gt;is_international&lt;&#x2F;code&gt;. The &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; argument means that this function is a method, which operates on an instance of the &lt;code&gt;Package&lt;&#x2F;code&gt; struct.&lt;&#x2F;p&gt;
&lt;p&gt;This function will return a &lt;code&gt;bool&lt;&#x2F;code&gt; type, which is a boolean that can be either &lt;code&gt;true&lt;&#x2F;code&gt; or &lt;code&gt;false&lt;&#x2F;code&gt; as we have already defined earlier.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;function-body&quot;&gt;Function body:&lt;&#x2F;h3&gt;
&lt;p&gt;Inside the function, we add &lt;code&gt;self.sender_country != self.recipient_country&lt;&#x2F;code&gt; which is the basic logic that determines whether a package is international.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;self.sender_country&lt;&#x2F;code&gt; accesses the &lt;code&gt;sender_country&lt;&#x2F;code&gt; field  of the current &lt;code&gt;Package&lt;&#x2F;code&gt; instance, and &lt;code&gt;self.recipient_country&lt;&#x2F;code&gt; accesses the &lt;code&gt;recipient_country&lt;&#x2F;code&gt; field.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;!=&lt;&#x2F;code&gt; is the inequality operator in Rust, which checks if the two values on its left and right are not equal. In this case, it&#x27;s comparing the &lt;code&gt;sender_country&lt;&#x2F;code&gt; and &lt;code&gt;recipient_country&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;return-value&quot;&gt;Return value:&lt;&#x2F;h3&gt;
&lt;p&gt;If &lt;code&gt;sender_country&lt;&#x2F;code&gt; and &lt;code&gt;recipient_country&lt;&#x2F;code&gt; are not equal, the expression evaluates to &lt;code&gt;true&lt;&#x2F;code&gt;, meaning that the package is international. If they are equal, the expression evaluates to &lt;code&gt;false&lt;&#x2F;code&gt;, meaning that the package is not international.&lt;&#x2F;p&gt;
&lt;p&gt;This boolean value is what the function returns, because it&#x27;s the last (and in this case, the only) expression in the function. In Rust, the last expression in a function is implicitly returned.&lt;&#x2F;p&gt;
&lt;p&gt;In sum, &lt;code&gt;is_international&lt;&#x2F;code&gt; is a method that checks if the sender and recipient countries of a package are different. If they are, the package is international, and the method returns &lt;code&gt;true&lt;&#x2F;code&gt;. If they&#x27;re the same, the package is not international, and the method returns &lt;code&gt;false&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;get-fees-function&quot;&gt;&lt;code&gt;get_fees&lt;&#x2F;code&gt; function&lt;&#x2F;h3&gt;
&lt;p&gt;Now let&#x27;s break down the &lt;code&gt;get_fees&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;function-declaration-1&quot;&gt;Function declaration&lt;&#x2F;h3&gt;
&lt;p&gt;The line &lt;code&gt;fn get_fees(&amp;amp;self, cents_per_gram: i32) -&amp;gt; i32&lt;&#x2F;code&gt; declares a function named &lt;code&gt;get_fees&lt;&#x2F;code&gt;. The &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; argument means that this function is a method, which operates on an instance of the &lt;code&gt;Package&lt;&#x2F;code&gt; struct.&lt;&#x2F;p&gt;
&lt;p&gt;In addition to &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt;, the function takes another argument, &lt;code&gt;cents_per_gram&lt;&#x2F;code&gt;, which represents the cost per gram to ship a package.
The &lt;code&gt;-&amp;gt; i32&lt;&#x2F;code&gt; means this function will return an integer (&lt;code&gt;i32&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;function-body-1&quot;&gt;Function body:&lt;&#x2F;h3&gt;
&lt;p&gt;Inside the function, &lt;code&gt;cents_per_gram * self.weight_in_grams&lt;&#x2F;code&gt; is the logic used to calculate the shipping fee for a package.
&lt;code&gt;self.weight_in_grams&lt;&#x2F;code&gt; accesses the &lt;code&gt;weight_in_grams&lt;&#x2F;code&gt; field of the current &lt;code&gt;Package&lt;&#x2F;code&gt; instance.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;*&lt;&#x2F;code&gt; is the multiplication operator in Rust, which multiplies &lt;code&gt;cents_per_gram&lt;&#x2F;code&gt; (the cost per gram to ship a package) with &lt;code&gt;self.weight_in_grams&lt;&#x2F;code&gt; (the weight of the package).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;return-value-1&quot;&gt;Return Value&lt;&#x2F;h3&gt;
&lt;p&gt;The multiplication gives the total cost to ship the package. Since &lt;code&gt;cents_per_gram&lt;&#x2F;code&gt; is in cents, and &lt;code&gt;weight_in_grams&lt;&#x2F;code&gt; is in grams, the result is in cents too.
This integer value is what the function returns. As in the &lt;code&gt;is_international&lt;&#x2F;code&gt; function, the last expression in the function is implicitly returned in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;In summary, &lt;code&gt;get_fees&lt;&#x2F;code&gt; is a method that calculates and returns the shipping fee for a package based on the cost per gram and the weight of the package.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary-of-methods&quot;&gt;Summary of methods&lt;&#x2F;h2&gt;
&lt;p&gt;Rust is a language that uses something called &amp;quot;methods&amp;quot; to perform actions on data. In our example, &lt;code&gt;Package&lt;&#x2F;code&gt; is a collection of data (the sender and recipient countries, and the weight), and the functions &lt;code&gt;is_international&lt;&#x2F;code&gt; and &lt;code&gt;get_fees&lt;&#x2F;code&gt; are methods that do something with this data.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; is a reference to the current object - the &amp;quot;package&amp;quot; we&#x27;re working with at the moment. It&#x27;s like saying &amp;quot;this package&amp;quot; or &amp;quot;the package I&#x27;m currently handling&amp;quot;. It&#x27;s used because the method is working on the data inside the current &lt;code&gt;Package&lt;&#x2F;code&gt; object.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;is_international(&amp;amp;self) -&amp;gt; bool&lt;&#x2F;code&gt; is a method that checks if the package is international. It does this by comparing the sender and recipient countries: if they&#x27;re different, it means the package is international, and the method returns &lt;code&gt;true&lt;&#x2F;code&gt;. If they&#x27;re the same, the package is not international, and the method returns &lt;code&gt;false&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;get_fees(&amp;amp;self, cents_per_gram: i32) -&amp;gt; i32&lt;&#x2F;code&gt; is a method that calculates the fees to ship the package. It does this by multiplying the weight of the package (&lt;code&gt;self.weight_in_grams&lt;&#x2F;code&gt;) by the cost per gram (&lt;code&gt;cents_per_gram&lt;&#x2F;code&gt;). The result is the total fee, which is returned by the method.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;So, in short: &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; means &amp;quot;this package&amp;quot;, &lt;code&gt;is_international&lt;&#x2F;code&gt; checks if the sender and recipient countries are different, and &lt;code&gt;get_fees&lt;&#x2F;code&gt; calculates the shipping fees based on the weight of the package and the cost per gram.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Okay, this was a long one, we dove into the basics of Structs in Rust and how they can carry both data and logic.
Through this exploration, we gained a better understanding of Rust&#x27;s data structures, method definitions and syntax. Moreover, we tackled a practical example with tests, giving us a real world scenario to apply our knowledge.&lt;&#x2F;p&gt;
&lt;p&gt;Remember, Rust&#x27;s system of Structs and methods allows you to write code that is not only efficient but also safe and readable. This is particularly important in systems programming and other contexts where performance is crucial. With this knowledge, you&#x27;ll be able to tackle more complex Rust projects and continue to build on your programming skills.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>07 Rustlings Move Semantics Part 2</title>
          <pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/07-rustlings-move-semantics2/</link>
          <guid>https://desmodrone.github.io/posts/07-rustlings-move-semantics2/</guid>
          <description xml:base="https://desmodrone.github.io/posts/07-rustlings-move-semantics2/">&lt;p&gt;From the Rustlings ReadMe:
These exercises are adapted from &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pnkfelix&quot;&gt;pnkfelix&lt;&#x2F;a&gt;&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;pnkfelix.github.io&#x2F;rust-examples-icfp2014&#x2F;&quot;&gt;Rust Tutorial&lt;&#x2F;a&gt; -- Thank you Felix!!!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;p&gt;For this section, the book links are especially important.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-01-what-is-ownership.html&quot;&gt;Ownership&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-02-references-and-borrowing.html&quot;&gt;Reference and borrowing&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;move-semantics-part-2&quot;&gt;Move Semantics Part 2&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;ve already covered the first three exercises of &lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;07-rustlings-move-semantics1&#x2F;&quot;&gt;Move Semantics&lt;&#x2F;a&gt; in part one, in this episode we tackle the next three. Let&#x27;s get started!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics4-rs&quot;&gt;&lt;code&gt;move_semantics4.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; move_semantics4.rs
&amp;#x2F;&amp;#x2F; Refactor this code so that instead of passing `vec0` into the `fill_vec` function,
&amp;#x2F;&amp;#x2F; the Vector gets created in the function itself and passed back to the main
&amp;#x2F;&amp;#x2F; function.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}

&amp;#x2F;&amp;#x2F; `fill_vec()` no longer takes `vec: Vec&amp;lt;i32&amp;gt;` as argument
fn fill_vec() -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions here are to refactor our code so that instead of passing &lt;code&gt;vec0&lt;&#x2F;code&gt; into the &lt;code&gt;fill_vec&lt;&#x2F;code&gt; function, the Vector gets created in the function itself and passed back to the main function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics4-rs-errors&quot;&gt;&lt;code&gt;move_semantics4.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics4.rs failed! Please try again. Here is the output:
error[E0423]: expected value, found macro `vec`
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics4.rs:23:19
   |
23 |     let mut vec = vec;
   |                   ^^^ not a value

error[E0061]: this function takes 0 arguments but 1 argument was supplied
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics4.rs:12:20
   |
12 |     let mut vec1 = fill_vec(vec0);
   |                    ^^^^^^^^ ---- argument of type `Vec&amp;lt;_&amp;gt;` unexpected
   |
note: function defined here
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics4.rs:22:4
   |
22 | fn fill_vec() -&amp;gt; Vec&amp;lt;i32&amp;gt; {
   |    ^^^^^^^^
help: remove the extra argument
   |
12 |     let mut vec1 = fill_vec();
   |                            ~~

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Error&#x27;s  are telling us that on line 23, &lt;code&gt;vec&lt;&#x2F;code&gt; is not a value in addition it tells us that the function &lt;code&gt;fill_vec()&lt;&#x2F;code&gt; takes 0 arguments but one is being supplied.  So let&#x27;s remove the argument on line 12 from the &lt;code&gt;fill_vec(vec0)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;After we do that we still get some errors, but they&#x27;re different now.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics4.rs failed! Please try again. Here is the output:
error[E0423]: expected value, found macro `vec`
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics4.rs:23:19
   |
23 |     let mut vec = vec;
   |                   ^^^ not a value

error[E0282]: type annotations needed for `Vec&amp;lt;T&amp;gt;`
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics4.rs:10:9
   |
10 |     let vec0 = Vec::new();
   |         ^^^^
   |
help: consider giving `vec0` an explicit type, where the type for type parameter `T` is specified
   |
10 |     let vec0: Vec&amp;lt;T&amp;gt; = Vec::new();
   |             ++++++++

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The error&#x27;s start point us to using generics with &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; but our solution should be must simpler than that, since our instructions are to refactor our code to not create &lt;code&gt;vec0&lt;&#x2F;code&gt; but to create a new vector in our &lt;code&gt;fill_vec()&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s see what happens if we simple remove the &lt;code&gt;let vec0 = Vec::new();&lt;&#x2F;code&gt; line from our code but and add the &lt;code&gt;let mut vec = Vec::new();&lt;&#x2F;code&gt; to our &lt;code&gt;fill_vec()&lt;&#x2F;code&gt; function. Hey guess what? It works. Below is the update code solution.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics4-solution&quot;&gt;&lt;code&gt;move_semantics4&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
	&amp;#x2F;&amp;#x2F; removed previous vector creation here
    let mut vec1 = fill_vec();

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}

fn fill_vec() -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut vec = Vec::new(); &amp;#x2F;&amp;#x2F; added vector creation within the function

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is our output:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
vec1 has length 3 content `[22, 44, 66]`
vec1 has length 4 content `[22, 44, 66, 88]`

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;move-semantics5-rs&quot;&gt;&lt;code&gt;move_semantics5.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; move_semantics5.rs
&amp;#x2F;&amp;#x2F; Make me compile only by reordering the lines in `main()`, but without
&amp;#x2F;&amp;#x2F; adding, changing or removing any of them.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let mut x = 100;
    let y = &amp;amp;mut x;
    let z = &amp;amp;mut x;
    *y += 100;
    *z += 1000;
    assert_eq!(x, 1200);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This looks like an easy one, no need to write anything we just need to re-order the sequence of the lines. Let&#x27;s look at the errors and see if we can get any hints on what we need to do.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics5-rs-errors&quot;&gt;&lt;code&gt;move_semantics5.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics5.rs failed! Please try again. Here is the output:
error[E0499]: cannot borrow `x` as mutable more than once at a time
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics5.rs:11:13
   |
10 |     let y = &amp;amp;mut x;
   |             ------ first mutable borrow occurs here
11 |     let z = &amp;amp;mut x;
   |             ^^^^^^ second mutable borrow occurs here
12 |     *y += 100;
   |     --------- first borrow later used here
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The Rust compiler tells us that we are borrowing &lt;code&gt;x&lt;&#x2F;code&gt; mutably too many times, so let&#x27;s go step by step and see what is happening on each line.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;We declare a mutable variable &lt;code&gt;x&lt;&#x2F;code&gt; and assign it the value &lt;code&gt;100&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;We create a mutable reference &lt;code&gt;y&lt;&#x2F;code&gt; that borrows &lt;code&gt;x&lt;&#x2F;code&gt; using &lt;code&gt;&amp;amp;mut x&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Then, we create another mutable reference &lt;code&gt;z&lt;&#x2F;code&gt; that also borrows &lt;code&gt;x&lt;&#x2F;code&gt; using &lt;code&gt;&amp;amp;mut x&lt;&#x2F;code&gt;. This is where the problem arises.
&lt;ul&gt;
&lt;li&gt;The rules of borrowing state that you can have either one mutable reference or any number of immutable references to a value at a given time.&lt;&#x2F;li&gt;
&lt;li&gt;In this case, we already have &lt;code&gt;y&lt;&#x2F;code&gt; as a mutable reference to &lt;code&gt;x&lt;&#x2F;code&gt;, so we can&#x27;t create another mutable reference &lt;code&gt;z&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;The code tries to dereference &lt;code&gt;y&lt;&#x2F;code&gt; using &lt;code&gt;*y&lt;&#x2F;code&gt; and add &lt;code&gt;100&lt;&#x2F;code&gt; to the value of &lt;code&gt;x&lt;&#x2F;code&gt;. This is invalid because &lt;code&gt;y&lt;&#x2F;code&gt; is still in scope and holds a mutable reference to &lt;code&gt;x&lt;&#x2F;code&gt;, and at this point, &lt;code&gt;z&lt;&#x2F;code&gt; also exists.&lt;&#x2F;li&gt;
&lt;li&gt;Similarly, when the code tries to dereference &lt;code&gt;z&lt;&#x2F;code&gt; using &lt;code&gt;*z&lt;&#x2F;code&gt; and add &lt;code&gt;1000&lt;&#x2F;code&gt; to the value of &lt;code&gt;x&lt;&#x2F;code&gt;, it violates the borrowing rules.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;So how do we solve this? Let&#x27;s try by dereferencing &lt;code&gt;y&lt;&#x2F;code&gt; before we try to borrow it again with &lt;code&gt;z&lt;&#x2F;code&gt; by moving the line &lt;code&gt;*y += 100;&lt;&#x2F;code&gt;
above the 2nd attempt mutable borrow which is &lt;code&gt;let z = &amp;amp;mut x;&lt;&#x2F;code&gt;. Doing so should allow us to compile.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics5-rs-solution&quot;&gt;&lt;code&gt;move_semantics5.rs&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let mut x = 100;
    let y = &amp;amp;mut x;
    *y += 100;
    let z = &amp;amp;mut x;
    *z += 1000;
    assert_eq!(x, 1200);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It compiles! We don&#x27;t get an output because there is not &lt;code&gt;println!&lt;&#x2F;code&gt; statement instead we have an &lt;code&gt;assert_eq!&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The code compiles successfully because it follows the borrowing rules in Rust. Here&#x27;s a step-by-step explanation:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;We start by declaring a mutable variable &lt;code&gt;x&lt;&#x2F;code&gt; and assigning it the value &lt;code&gt;100&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;We then create a mutable reference &lt;code&gt;y&lt;&#x2F;code&gt; that borrows &lt;code&gt;x&lt;&#x2F;code&gt; using &lt;code&gt;&amp;amp;mut x&lt;&#x2F;code&gt;. This allows us to modify &lt;code&gt;x&lt;&#x2F;code&gt; through &lt;code&gt;y&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;We dereference &lt;code&gt;y&lt;&#x2F;code&gt; using &lt;code&gt;*y&lt;&#x2F;code&gt; and add &lt;code&gt;100&lt;&#x2F;code&gt; to the value of &lt;code&gt;x&lt;&#x2F;code&gt;. This modifies &lt;code&gt;x&lt;&#x2F;code&gt; to &lt;code&gt;200&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Next, we create another mutable reference &lt;code&gt;z&lt;&#x2F;code&gt; that also borrows &lt;code&gt;x&lt;&#x2F;code&gt; using &lt;code&gt;&amp;amp;mut x&lt;&#x2F;code&gt;. This is allowed because there are no other references to &lt;code&gt;x&lt;&#x2F;code&gt; at this point.&lt;&#x2F;li&gt;
&lt;li&gt;We dereference &lt;code&gt;z&lt;&#x2F;code&gt; using &lt;code&gt;*z&lt;&#x2F;code&gt; and add &lt;code&gt;1000&lt;&#x2F;code&gt; to the value of &lt;code&gt;x&lt;&#x2F;code&gt;. This modifies &lt;code&gt;x&lt;&#x2F;code&gt; to &lt;code&gt;1200&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Finally, we use &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; to check if &lt;code&gt;x&lt;&#x2F;code&gt; is equal to &lt;code&gt;1200&lt;&#x2F;code&gt;. Since the value of &lt;code&gt;x&lt;&#x2F;code&gt; is indeed &lt;code&gt;1200&lt;&#x2F;code&gt;, the assertion passes.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Let&#x27;s move on to our final &lt;code&gt;move_semantics&lt;&#x2F;code&gt; exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics6-rs&quot;&gt;&lt;code&gt;move_semantics6.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; move_semantics6.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.
&amp;#x2F;&amp;#x2F; You can&amp;#x27;t change anything except adding or removing references.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let data = &amp;quot;Rust is great!&amp;quot;.to_string();

    get_char(data);

    string_uppercase(&amp;amp;data);
}

&amp;#x2F;&amp;#x2F; Should not take ownership
fn get_char(data: String) -&amp;gt; char {
    data.chars().last().unwrap()
}

&amp;#x2F;&amp;#x2F; Should take ownership
fn string_uppercase(mut data: &amp;amp;String) {
    data = &amp;amp;data.to_uppercase();

    println!(&amp;quot;{}&amp;quot;, data);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are to not change anything but the references, so we&#x27;ll look at the errors to get a better understanding as to where we are having issues.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics6-rs-errors&quot;&gt;&lt;code&gt;move_semantics6.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs failed! Please try again. Here is the output:
error[E0382]: borrow of moved value: `data`
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:12:22
   |
8  |     let data = &amp;quot;Rust is great!&amp;quot;.to_string();
   |         ---- move occurs because `data` has type `String`, which does not implement the `Copy` trait
9  |
10 |     get_char(data);
   |              ---- value moved here
11 |
12 |     string_uppercase(&amp;amp;data);
   |                      ^^^^^ value borrowed here after move
   |
note: consider changing this parameter type in function `get_char` to borrow instead if owning the value is not necessary
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:16:19
   |
16 | fn get_char(data: String) -&amp;gt; char {
   |    --------       ^^^^^^ this parameter takes ownership of the value
   |    |
   |    in this function
help: consider cloning the value if the performance cost is acceptable
   |
10 |     get_char(data.clone());
   |                  ++++++++

error[E0716]: temporary value dropped while borrowed
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:22:13
   |
21 | fn string_uppercase(mut data: &amp;amp;String) {
   |                               - let us call the lifetime of this reference `&amp;#x27;1`
22 |     data = &amp;amp;data.to_uppercase();
   |     --------^^^^^^^^^^^^^^^^^^^- temporary value is freed at the end of this statement
   |     |       |
   |     |       creates a temporary value which is freed while still in use
   |     assignment requires that borrow lasts for `&amp;#x27;1`

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright let&#x27;s go down the list understanding what there errors are telling us and see how we can fix them.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;8  |     let data = &amp;quot;Rust is great!&amp;quot;.to_string();
   |         ---- move occurs because `data` has type `String`, which does not implement the `Copy` trait
9  |
10 |     get_char(data);
   |              ---- value moved here
11 |
12 |     string_uppercase(&amp;amp;data);
   |                      ^^^^^ value borrowed here after move
   note: consider changing this parameter type in function `get_char` to borrow instead if owning the value is not necessary
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:16:19
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;here the compiler is telling us clearly where to look &lt;code&gt;data&lt;&#x2F;code&gt; does not implement the copy trait so we when we pass it through as a parameter in &lt;code&gt;get_char(data),&lt;&#x2F;code&gt; it becomes owned by &lt;code&gt;get_char()&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the next batch of errors we get a suggestion about cloning, but we know that we can&#x27;t change any of the code other than changing the references, so this is not the path we want to take.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;16 | fn get_char(data: String) -&amp;gt; char {
   |    --------       ^^^^^^ this parameter takes ownership of the value
   |    |
   |    in this function
help: consider cloning the value if the performance cost is acceptable
   |
10 |     get_char(data.clone());
   |                  ++++++++

error[E0716]: temporary value dropped while borrowed
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt; |
21 | fn string_uppercase(mut data: &amp;amp;String) {
   |                               - let us call the lifetime of this reference `&amp;#x27;1&amp;#x27;`
22 |     data = &amp;amp;data.to_uppercase();
   |     --------^^^^^^^^^^^^^^^^^^^- temporary value is freed at the end of this statement
   |     |       |
   |     |       creates a temporary value which is freed while still in use
   |     assignment requires that borrow lasts for `&amp;#x27;1`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We now get a message about the lifetime of a reference which we haven&#x27;t covered yet so let&#x27;s just keep this in mind for now, but again our task is to essentially just change how the functions handle ownership. So let&#x27;s go back and look at the functions in the code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Should not take ownership
fn get_char(data: String) -&amp;gt; char {
    data.chars().last().unwrap()
}

&amp;#x2F;&amp;#x2F; Should take ownership
fn string_uppercase(mut data: &amp;amp;String) {
    data = &amp;amp;data.to_uppercase();

    println!(&amp;quot;{}&amp;quot;, data);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Looking at these two code blocks it looks straightforward, it&#x27;s clear that we must change where the &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; symbol is being used and essentially swap positions in each function to this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Should not take ownership
fn get_char(data: &amp;amp;String) -&amp;gt; char {
    data.chars().last().unwrap()
}

&amp;#x2F;&amp;#x2F; Should take ownership
fn string_uppercase(mut data: String) {
    data = data.to_uppercase();

    println!(&amp;quot;{}&amp;quot;, data);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once we&#x27;ve done this we get new error&#x27;s but it should be pretty clear what we need to do in the &lt;code&gt;fn main()&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs failed! Please try again. Here is the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:10:14
   |
10 |     get_char(data);
   |     -------- ^^^^
   |     |        |
   |     |        expected `&amp;amp;String`, found struct `String`
   |     |        help: consider borrowing here: `&amp;amp;data`
   |     arguments to this function are incorrect
   |
note: function defined here
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:16:4
   |
16 | fn get_char(data: &amp;amp;String) -&amp;gt; char {
   |    ^^^^^^^^ -------------

error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:12:22
   |
12 |     string_uppercase(&amp;amp;data);
   |     ---------------- ^^^^^ expected struct `String`, found `&amp;amp;String`
   |     |
   |     arguments to this function are incorrect
   |
note: function defined here
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:21:4
   |
21 | fn string_uppercase(mut data: String) {
   |    ^^^^^^^^^^^^^^^^ ----------------
help: consider removing the borrow
   |
12 -     string_uppercase(&amp;amp;data);
12 +     string_uppercase(data);
   |

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler gives us great information on what we should do literally showing us what we can do to make the code compile. So let&#x27;s try it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics6-rs-solution&quot;&gt;&lt;code&gt;move_semantics6.rs&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let data = &amp;quot;Rust is great!&amp;quot;.to_string();

    get_char(&amp;amp;data);

    string_uppercase(data);
}

&amp;#x2F;&amp;#x2F; Should not take ownership
fn get_char(data: &amp;amp;String) -&amp;gt; char {
    data.chars().last().unwrap()
}

&amp;#x2F;&amp;#x2F; Should take ownership
fn string_uppercase(mut data: String) {
    data = data.to_uppercase();

    println!(&amp;quot;{}&amp;quot;, data);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There we have it our solution is to again swap the &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; symbol&#x27;s position to match that of the function&#x27;s signature to make sure that we are borrowing and taking ownership as the function expects. With that we get our print out:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
RUST IS GREAT!

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h3&gt;
&lt;p&gt;Rust&#x27;s move semantics are important for understanding memory management and ownership in the language. By leveraging references, borrowing, and ownership, Rust ensures memory safety and eliminates many common programming errors like null pointer dereferences and dangling references.&lt;&#x2F;p&gt;
&lt;p&gt;In this blog post, we explored three exercises related to move semantics. We refactored code, re-ordered lines, and adjusted ownership to solve the problems. Through these exercises, we gained a better understanding of how move semantics work in Rust and how to manipulate ownership and references effectively.&lt;&#x2F;p&gt;
&lt;p&gt;Move semantics play a crucial role in Rust&#x27;s design philosophy, enabling high-performance and safe code without sacrificing expressiveness. By embracing move semantics and mastering the intricacies of ownership, borrowing, and references, Rust developers can write robust and efficient code.&lt;&#x2F;p&gt;
&lt;p&gt;Remember, practice is key to mastering move semantics and other advanced features of Rust. Keep exploring, experimenting, and building projects to deepen your understanding and become a proficient Rust programmer. Happy coding!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>07 Rustlings Move Semantics Part 1</title>
          <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/07-rustlings-move-semantics1/</link>
          <guid>https://desmodrone.github.io/posts/07-rustlings-move-semantics1/</guid>
          <description xml:base="https://desmodrone.github.io/posts/07-rustlings-move-semantics1/">&lt;p&gt;From the Rustlings ReadMe:
These exercises are adapted from &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pnkfelix&quot;&gt;pnkfelix&lt;&#x2F;a&gt;&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;pnkfelix.github.io&#x2F;rust-examples-icfp2014&#x2F;&quot;&gt;Rust Tutorial&lt;&#x2F;a&gt; -- Thank you Felix!!!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;p&gt;For this section, the book links are especially important.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-01-what-is-ownership.html&quot;&gt;Ownership&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-02-references-and-borrowing.html&quot;&gt;Reference and borrowing&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;&#x2F;h2&gt;
&lt;p&gt;Ownership, References, and Borrowing are essential components of Rust&#x27;s unique characteristics. It&#x27;s crucial to have a solid understanding of these concepts to harness the full potential of Rust. In this introduction, we&#x27;ll provide a brief overview of each aspect, but you can find more detailed information in the links provided above.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-is-ownership&quot;&gt;What is Ownership?&lt;&#x2F;h2&gt;
&lt;p&gt;Ownership in Rust is a set of rules that dictate how a program manages memory. All programs require a memory management system during execution. While some languages rely on garbage collection to automatically locate and clean up unused memory, and others require the programmer to allocate and free memory manually, Rust takes a different approach. Rust&#x27;s memory management is handled through ownership rules that are checked at compile time. If any of these rules are violated, the code will not compile. The advantage of this system is that it doesn&#x27;t slow down our program during runtime.&lt;&#x2F;p&gt;
&lt;p&gt;For many programmers, the ownership concept is a novel idea and may require some adjustment. However, once you have a firm grasp of ownership, you&#x27;ll have a strong foundation on what sets Rust apart from other languages and makes it memory safe.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;references-and-borrowing&quot;&gt;References and Borrowing&lt;&#x2F;h2&gt;
&lt;p&gt;Due to Rust&#x27;s strict ownership rules, the language provides tools to reference or borrow different parts of your code as a means of accessing or using data without &amp;quot;consuming&amp;quot; it. These tools introduce another set of rules that must be learned to fully leverage Rust&#x27;s features. With a thorough understanding of References and Borrowing, you can work efficiently within Rust&#x27;s ownership system, allowing for more reliable and performant programs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics1-rs&quot;&gt;&lt;code&gt;move_semantics1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; move_semantics1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let vec1 = fill_vec(vec0);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here&#x27;s our first exercise, which not much in the sense of instructions on how to solve our problem. As always let&#x27;s take a look at what the Rust compiler is telling us.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics1-rs-errors&quot;&gt;&lt;code&gt;move_semantics1.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics1.rs failed! Please try again. Here is the output:
error[E0596]: cannot borrow `vec1` as mutable, as it is not declared as mutable
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics1.rs:13:5
   |
13 |     vec1.push(88);
   |     ^^^^^^^^^^^^^ cannot borrow as mutable
   |
help: consider changing this to be mutable
   |
9  |     let mut vec1 = fill_vec(vec0);
   |         +++

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We get a lot of help here from this output clearly telling us where and what the problem is.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;where &lt;code&gt;line 13&lt;&#x2F;code&gt;: &lt;code&gt;vec1.push(88)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;what &lt;code&gt;cannot borrow as mutable&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We even a very clear suggestion on what we should add on line &lt;code&gt;9&lt;&#x2F;code&gt;, so let&#x27;s do this.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;9  |     let mut vec1 = fill_vec(vec0);
   |         +++
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;move-semantics1-solution&quot;&gt;&lt;code&gt;move_semantics1&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0); &amp;#x2F;&amp;#x2F; adding `mut`

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Doing exactly as the Rust compiler says gets us an easy win.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
vec1 has length 3 content `[22, 44, 66]`
vec1 has length 4 content `[22, 44, 66, 88]`

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since this was such an easy exercise, let&#x27;s play around with the code, if you look at the hint by typing &lt;code&gt;hint&lt;&#x2F;code&gt; in terminal, you&#x27;ll see it gives you another little challenge.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Also: Try accessing `vec0` after having called `fill_vec()`. See what happens!

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;See if you can get this to work, it should be pretty straight forward if you follow the compiler hints, I was able to get this to print.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
vec1 has length 3 content `[22, 44, 66]`
vec1 has length 4 content `[22, 44, 66, 88]`
vec0 has length 1 content `[1]`

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;On to the next one!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics2-rs&quot;&gt;&lt;code&gt;move_semantics2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; move_semantics2.rs
&amp;#x2F;&amp;#x2F; Make me compile without changing line 13 or moving line 10!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    &amp;#x2F;&amp;#x2F; Do not change the following line!
    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec0&amp;quot;, vec0.len(), vec0);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we get one line of instruction, make this code compile without changing line 13 or moving line 10. Now let&#x27;s take a look at what the Rust compiler is telling us.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics2-rs-errors&quot;&gt;&lt;code&gt;move_semantics2.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics2.rs failed! Please try again. Here is the output:
error[E0382]: borrow of moved value: `vec0`
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics2.rs:13:57
   |
8  |     let vec0 = Vec::new();
   |         ---- move occurs because `vec0` has type `Vec&amp;lt;i32&amp;gt;`, which does not implement the `Copy` trait
9  |
10 |     let mut vec1 = fill_vec(vec0);
   |                             ---- value moved here
...
13 |     println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec0&amp;quot;, vec0.len(), vec0);
   |                                                         ^^^^^^^^^^ value borrowed here after move
   |
note: consider changing this parameter type in function `fill_vec` to borrow instead if owning the value is not necessary
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics2.rs:20:18
   |
20 | fn fill_vec(vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
   |    --------      ^^^^^^^^ this parameter takes ownership of the value
   |    |
   |    in this function
help: consider cloning the value if the performance cost is acceptable
   |
10 |     let mut vec1 = fill_vec(vec0.clone());
   |                                 ++++++++

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright, we have a lot to see here, the first error on line 8 tells us that &lt;code&gt;vec0&lt;&#x2F;code&gt; is being moved to line 10 to the line &lt;code&gt;let mut vec1 = fill_vec(0);&lt;&#x2F;code&gt;
The note tells us to consider changing the parameter type, but that shouldn&#x27;t be where we should be looking because in this case we do want to return a &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt;. If we continue reading our errors, we get the answer in the line  &lt;code&gt;help: consider cloning the value if the performanc cost is acceptable&lt;&#x2F;code&gt;. This is very helpful and clear answer.  If you played around with the code on [[#move_semantics1.rs]] you might have already encountered this solution. So let&#x27;s try this &lt;code&gt;clone()&lt;&#x2F;code&gt; solution.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics2-solution&quot;&gt;&lt;code&gt;move_semantics2&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0.clone()); &amp;#x2F;&amp;#x2F; adding clone() here

    &amp;#x2F;&amp;#x2F; Do not change the following line!
    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec0&amp;quot;, vec0.len(), vec0);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It works. Again, you shouldn&#x27;t be too surprised if you played around with the previous code that we had since it&#x27;s pretty much the same code.
Our code compiles and this is our output.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
vec0 has length 0 content `[]`
vec1 has length 4 content `[22, 44, 66, 88]`

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we look at the hint, we actually have a few different options to make this code compile. The compiler told us one solution with cloning along with the warning that we should be aware that there could be a performance cost if our data is big. In our case it works because it&#x27;s not, but using &lt;code&gt;clone()&lt;&#x2F;code&gt; is not always a good solution. So, let&#x27;s look at alternate solutions from the Rustlings hint.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;hint&lt;&#x2F;strong&gt;
So, &lt;code&gt;vec0&lt;&#x2F;code&gt; is passed into the &lt;code&gt;fill_vec&lt;&#x2F;code&gt; function as an argument. In Rust,
when an argument is passed to a function and it&#x27;s not explicitly returned,
you can&#x27;t use the original variable anymore. We call this &amp;quot;moving&amp;quot; a variable.
Variables that are moved into a function (or block scope) and aren&#x27;t explicitly
returned get &amp;quot;dropped&amp;quot; at the end of that function. This is also what happens here.
There&#x27;s a few ways to fix this, try them all if you want:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Make another, separate version of the data that&#x27;s in &lt;code&gt;vec0&lt;&#x2F;code&gt; and pass that to &lt;code&gt;fill_vec&lt;&#x2F;code&gt; instead.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Make &lt;code&gt;fill_vec&lt;&#x2F;code&gt; borrow its argument instead of taking ownership of it, and then copy the data within the function in order to return an owned &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Make &lt;code&gt;fill_vec&lt;&#x2F;code&gt; &lt;em&gt;mutably&lt;&#x2F;em&gt; borrow a reference to its argument (which will need to be mutable), modify it directly, then not return anything. Then you can get rid of &lt;code&gt;vec1&lt;&#x2F;code&gt; entirely -- note that this will change what gets printed by the first &lt;code&gt;println!&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Option 1, is what we already did by cloning the data inside of &lt;code&gt;vec0&lt;&#x2F;code&gt; we created a separate version so let&#x27;s look at the other 2 options.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;solution-2&quot;&gt;Solution 2&lt;&#x2F;h2&gt;
&lt;p&gt;Tells us that we should make &lt;code&gt;fill_vec&lt;&#x2F;code&gt; borrow its arguments instead of owning them, then we copy the data within the function and return and owned &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt;. Let&#x27;s see how we can implement this.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(&amp;amp;vec0); &amp;#x2F;&amp;#x2F; ad the `&amp;amp;` to our `vec0`

    &amp;#x2F;&amp;#x2F; Do not change the following line!
    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec0&amp;quot;, vec0.len(), vec0);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}
&amp;#x2F;&amp;#x2F; change the paramter of our function here to be a reference with &amp;amp;Vec&amp;lt;i32&amp;gt;
fn fill_vec(vec: &amp;amp;Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut vec = vec.clone(); &amp;#x2F;&amp;#x2F; we use clone() here to copy the data

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So here&#x27;s the second solution and although it handles the problem a little differently it still has to copy the data using &lt;code&gt;clone()&lt;&#x2F;code&gt;. So it would still have similar performance hits if we had a huge vector of data. However, it&#x27;s worth noting that the second solution is more idiomatic Rust. In Rust, it&#x27;s common to use the clone method directly on the caller&#x27;s side, making it clear that a clone is being created and ownership is being transferred.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;solution-3&quot;&gt;Solution 3&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let mut vec0 = Vec::new(); &amp;#x2F;&amp;#x2F; Make vec0 mutable

    fill_vec(&amp;amp;mut vec0); &amp;#x2F;&amp;#x2F; Pass a mutable reference to vec0

    &amp;#x2F;&amp;#x2F; Do not change the following line!
    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec0&amp;quot;, vec0.len(), vec0);

    vec0.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec0&amp;quot;, vec0.len(), vec0); &amp;#x2F;&amp;#x2F; Update the label to &amp;quot;vec0&amp;quot;
}

&amp;#x2F;&amp;#x2F; Change the function parameter to accept a mutable reference with &amp;amp;mut Vec&amp;lt;i32&amp;gt;
&amp;#x2F;&amp;#x2F; Remove the return type, as the function doesn&amp;#x27;t need to return anything
fn fill_vec(vec: &amp;amp;mut Vec&amp;lt;i32&amp;gt;) {
    vec.push(22);
    vec.push(44);
    vec.push(66);
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now let&#x27;s took at our final solution that changes a bit more how the code functions. In this modified version, &lt;code&gt;fill_vec&lt;&#x2F;code&gt; now takes a mutable reference to a &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt; (indicated by &lt;code&gt;&amp;amp;mut Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt;), allowing it to modify the input vector directly. Since the input vector is modified in place, the function doesn&#x27;t need to return anything. As a result, there is no need for a separate &lt;code&gt;vec1&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We also see that our output changes&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
vec0 has length 3 content `[22, 44, 66]`
vec0 has length 4 content `[22, 44, 66, 88]`

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;so-which-solution-is-best&quot;&gt;So which Solution is Best?&lt;&#x2F;h2&gt;
&lt;p&gt;The best solution depends on your specific requirements:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;If you need to keep the original vector unchanged and create a modified version, choose either solution 1 or 2. Solution 2 is more idiomatic Rust.&lt;&#x2F;li&gt;
&lt;li&gt;If you don&#x27;t need the original vector in its initial state and want to modify it directly, solution 3 is the best choice, as it avoids creating a new vector and is more efficient.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In general, solution 3 is the most efficient because it directly modifies the original vector without creating a new one. However, this may not be suitable for every use case, as it changes the original vector&#x27;s content. Let&#x27;s move on to the next exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics3&quot;&gt;&lt;code&gt;move_semantics3&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; move_semantics3.rs
&amp;#x2F;&amp;#x2F; Make me compile without adding new lines-- just changing existing lines!
&amp;#x2F;&amp;#x2F; (no lines with multiple semicolons necessary!)
&amp;#x2F;&amp;#x2F; Execute `rustlings hint move_semantics3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This exercise says we can&#x27;t add any additional lines of code, but we can change the lines. Let&#x27;s take a look at what the compiler is saying.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics3-errors&quot;&gt;&lt;code&gt;move_semantics3&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics3.rs failed! Please try again. Here is the output:
error[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics3.rs:20:13
   |
20 | fn fill_vec(vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
   |             ^^^ not mutable
21 |     vec.push(22);
   |     ------------ cannot borrow as mutable
22 |     vec.push(44);
   |     ------------ cannot borrow as mutable
23 |     vec.push(66);
   |     ------------ cannot borrow as mutable
   |
help: consider changing this to be mutable
   |
20 | fn fill_vec(mut vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
   |             +++

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As always we get great help from the compiler. This seems pretty straight forward, let&#x27;s do what the compiler suggests and see what happens.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics3-solution&quot;&gt;&lt;code&gt;move_semantics3&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}
&amp;#x2F;&amp;#x2F; adding `mut` to the `vec` paramater
fn fill_vec(mut vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Success!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
vec1 has length 3 content `[22, 44, 66]`
vec1 has length 4 content `[22, 44, 66, 88]`

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Following the Rust compiler&#x27;s help is very easy  in this case, if we notice the code is very similar to the previous exercise but this code is missing the &lt;code&gt;let mut vec = vec;&lt;&#x2F;code&gt; line from the &lt;code&gt;fn fill_vec&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wrapping-up-the-rustlings-move-semantics-journey-continues&quot;&gt;Wrapping Up: The Rustlings Move Semantics Journey Continues!&lt;&#x2F;h2&gt;
&lt;p&gt;There you have it! We&#x27;ve explored the first three &lt;code&gt;move_semantics&lt;&#x2F;code&gt; exercises from the Rustlings course. To keep these blog posts digestible, we&#x27;ll be diving into the next 3 &lt;code&gt;move_semantics&lt;&#x2F;code&gt; challenges in a separate post, so keep an eye out for that!&lt;&#x2F;p&gt;
&lt;p&gt;Now, let&#x27;s do a quick recap of what we&#x27;ve covered in this post: we guided you through the first 3 &lt;code&gt;move_semantics&lt;&#x2F;code&gt; exercises, shedding light on how to tackle each problem by interpreting the error messages and hints provided. We also compared various solutions for each exercise, highlighting the trade-offs and stressing the importance of choosing the right method based on your code&#x27;s specific needs. Our focus was on understanding the concepts of ownership, borrowing, and mutable borrowing in Rust â€“ essential ingredients for writing efficient and safe code.&lt;&#x2F;p&gt;
&lt;p&gt;By working through these exercises and comprehending the solutions, you&#x27;re now better prepared to handle ownership and borrowing situations in your Rust projects. Stay tuned for more Rustling adventures!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>06 Rustlings Vectors</title>
          <pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/06-rustlings-vecs/</link>
          <guid>https://desmodrone.github.io/posts/06-rustlings-vecs/</guid>
          <description xml:base="https://desmodrone.github.io/posts/06-rustlings-vecs/">&lt;h1 id=&quot;vectors&quot;&gt;Vectors&lt;&#x2F;h1&gt;
&lt;p&gt;Vectors are a widely-used data structure in Rust programming. In many programming languages, they might be referred to as Arrays. However, Rust operates at a lower level, which leads to a distinction between arrays and vectors. In Rust, an array is usually stored on the stack, which means it cannot grow or shrink, and its size must be determined at compile time. On the other hand, a vector is stored in the heap, allowing for greater flexibility as these size restrictions do not apply.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look at these couple of exercises from Rustlings&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch08-01-vectors.html&quot;&gt;Storing Lists of Values with Vectors&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.slice.html#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;iter&#x2F;trait.Iterator.html#method.map&quot;&gt;&lt;code&gt;map&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;vecs1-rs&quot;&gt;&lt;code&gt;vecs1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; vecs1.rs
&amp;#x2F;&amp;#x2F; Your task is to create a `Vec` which holds the exact same elements
&amp;#x2F;&amp;#x2F; as in the array `a`.
&amp;#x2F;&amp;#x2F; Make me compile and pass the test!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn array_and_vec() -&amp;gt; ([i32; 4], Vec&amp;lt;i32&amp;gt;) {
    let a = [10, 20, 30, 40]; &amp;#x2F;&amp;#x2F; a plain array
    let v = &amp;#x2F;&amp;#x2F; TODO: declare your vector here with the macro for vectors

    (a, v)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_array_and_vec_similarity() {
        let (a, v) = array_and_vec();
        assert_eq!(a, v[..]);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are clear here in the comments create a vector that holds the elements&lt;code&gt; [10, 20, 30, 40]&lt;&#x2F;code&gt; just like &lt;code&gt;a&lt;&#x2F;code&gt; does. Simple enough.&lt;&#x2F;p&gt;
&lt;p&gt;For completeness let&#x27;s also log what we are seeing as the errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;vecs1-rs-errors&quot;&gt;&lt;code&gt;vecs1.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;vecs&amp;#x2F;vecs1.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected `;`, found `}`
  --&amp;gt; exercises&amp;#x2F;vecs&amp;#x2F;vecs1.rs:13:11
   |
13 |     (a, v)
   |           ^ help: add `;` here
14 | }
   | - unexpected token

error[E0425]: cannot find value `v` in this scope
  --&amp;gt; exercises&amp;#x2F;vecs&amp;#x2F;vecs1.rs:13:9
   |
13 |     (a, v)
   |         ^ help: a local variable with a similar name exists: `a`

error[E0308]: mismatched types
 --&amp;gt; exercises&amp;#x2F;vecs&amp;#x2F;vecs1.rs:9:23
  |
9 | fn array_and_vec() -&amp;gt; ([i32; 4], Vec&amp;lt;i32&amp;gt;) {
  |    -------------      ^^^^^^^^^^^^^^^^^^^^ expected tuple, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
  |
  = note:  expected tuple `([i32; 4], Vec&amp;lt;i32&amp;gt;)`
          found unit type `()`

error: aborting due to 3 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can see that the Rust compiler is a little confused and is suggesting ways to complete our code that are not what we are trying to do, but it&#x27;s good to get a sense of what the compiler is doing in this situation so we can potentially understand other issues as we encounter them.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;vecs1-rs-solution&quot;&gt;&lt;code&gt;vecs1.rs&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn array_and_vec() -&amp;gt; ([i32; 4], Vec&amp;lt;i32&amp;gt;) {
    let a = [10, 20, 30, 40]; &amp;#x2F;&amp;#x2F; a plain array
    let v = vec![10, 20, 30, 40]; &amp;#x2F;&amp;#x2F; using `vec!` macro to define a vector
    (a, v)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_array_and_vec_similarity() {
        let (a, v) = array_and_vec();
        assert_eq!(a, v[..]);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Completing the &lt;code&gt;let v&lt;&#x2F;code&gt; line with &lt;code&gt;vec![10, 20, 30, 40];&lt;&#x2F;code&gt; easily solves our exercise here.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;additional-notes&quot;&gt;Additional Notes&lt;&#x2F;h2&gt;
&lt;p&gt;Remember that there is more than one way to create a &lt;code&gt;vector&lt;&#x2F;code&gt; in Rust, we used the macro with &lt;code&gt;vec!&lt;&#x2F;code&gt; because it&#x27;s very convenient but we can also create vectors using the &lt;code&gt;Vec::new()&lt;&#x2F;code&gt; function to create a new vector and then fill it with the &lt;code&gt;push()&lt;&#x2F;code&gt; method.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s see what that would look like in this exercise:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn array_and_vec() -&amp;gt; ([i32; 4], Vec&amp;lt;i32&amp;gt;) {
    let a = [10, 20, 30, 40]; &amp;#x2F;&amp;#x2F; a plain array
    let mut v = Vec::new(); &amp;#x2F;&amp;#x2F; using `Vec::new()` function remembering to make it `mut`

    &amp;#x2F;&amp;#x2F; placing elements into the array with `push()` method
    v.push(10);
    v.push(20);
    v.push(30);
    v.push(40);

    (a, v)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This will also get our code to compile, but as you can see it&#x27;s a lot more effort to do, so in this case it&#x27;s much easier to use the &lt;code&gt;Vec!&lt;&#x2F;code&gt; macro.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;vecs2-rs&quot;&gt;&lt;code&gt;vecs2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; vecs2.rs
&amp;#x2F;&amp;#x2F; A Vec of even numbers is given. Your task is to complete the loop
&amp;#x2F;&amp;#x2F; so that each number in the Vec is multiplied by 2.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Make me pass the test!
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn vec_loop(mut v: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    for i in v.iter_mut() {
        &amp;#x2F;&amp;#x2F; TODO: Fill this up so that each element in the Vec `v` is
        &amp;#x2F;&amp;#x2F; multiplied by 2.
        ???
    }

    &amp;#x2F;&amp;#x2F; At this point, `v` should be equal to [4, 8, 12, 16, 20].
    v
}

fn vec_map(v: &amp;amp;Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    v.iter().map(|num| {
        &amp;#x2F;&amp;#x2F; TODO: Do the same thing as above - but instead of mutating the
        &amp;#x2F;&amp;#x2F; Vec, you can just return the new number!
        ???
    }).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_loop() {
        let v: Vec&amp;lt;i32&amp;gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_loop(v.clone());

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;());
    }

    #[test]
    fn test_vec_map() {
        let v: Vec&amp;lt;i32&amp;gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_map(&amp;amp;v);

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;());
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright we have a more involved exercise here with 2 different areas that we need to write out. Our instructors are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Complete the loop so that each number in the Vec is multiplied by 2.&lt;&#x2F;li&gt;
&lt;li&gt;First vector is mutable and the comments tell us that the vector we should have at the end of the calculations should be &lt;code&gt;[4, 8, 12, 16, 20]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Our second vector is not mutable, so our instructions are to not mutate the vector but just return the new number.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;vecs2-rs-1&quot;&gt;&lt;code&gt;vecs2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;vecs&amp;#x2F;vecs2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;vecs&amp;#x2F;vecs2.rs:15:9
   |
15 |         ???
   |         ^ expected expression

error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;vecs&amp;#x2F;vecs2.rs:26:9
   |
26 |         ???
   |         ^ expected expression

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These are the errors, pretty obvious as to why we are getting these.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look the first loop and see how we complete it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn vec_loop(mut v: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    for i in v.iter_mut() {
        *i *= 2; &amp;#x2F;&amp;#x2F; using the *i to access each element as well as `*=` to modify each element
    }

    &amp;#x2F;&amp;#x2F; At this point, `v` should be equal to [4, 8, 12, 16, 20].
    v
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s a pretty simple solution, using &lt;code&gt;*i *= 2&lt;&#x2F;code&gt;  to multiply each element by 2, the main thing to remember is the use of the dereference &lt;code&gt;*&lt;&#x2F;code&gt; operator when accessing each element and then &lt;code&gt;*=&lt;&#x2F;code&gt; to modify or update each element with the new number. If we run the code now, we see that we&#x27;re down to one error. So far so good.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;vecs&amp;#x2F;vecs2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;vecs&amp;#x2F;vecs2.rs:25:13
   |
25 |             ???
   |             ^ expected expression

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now let&#x27;s work on the 2nd for loop.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn vec_map(v: &amp;amp;Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    v.iter().map(|num| {
        &amp;#x2F;&amp;#x2F; TODO: Do the same thing as above - but instead of mutating the
        &amp;#x2F;&amp;#x2F; Vec, you can just return the new number!
        ???
    }).collect()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we see the use of a &lt;code&gt;map&lt;&#x2F;code&gt; and &lt;code&gt;closure&lt;&#x2F;code&gt; which we haven&#x27;t covered yet in our Rustlings journey, so let&#x27;s just ignore those for now, but we have to complete the iterator but as they tell us in the comments, instead of mutating the vector just return a new number, so since we don&#x27;t have to update each element and only multiply each element, we can simply use the multiplication &lt;code&gt;*&lt;&#x2F;code&gt; operator and use the &lt;code&gt;num&lt;&#x2F;code&gt; that&#x27;s being passed in through the closure to do so. It would look something like this: &lt;code&gt;num * 2&lt;&#x2F;code&gt; .&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn vec_map(v: &amp;amp;Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    v.iter().map(|num| {
        num * 2
    }).collect()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For the &lt;code&gt;vec_map&lt;&#x2F;code&gt; function, we use &lt;code&gt;v.iter().map(|num| num * 2).collect()&lt;&#x2F;code&gt;. Here, &lt;code&gt;num&lt;&#x2F;code&gt; represents each element in the vector, and &lt;code&gt;num * 2&lt;&#x2F;code&gt; returns a new number that is twice the original value. We use &lt;code&gt;collect()&lt;&#x2F;code&gt; to gather the resulting items into a collection, in this case, another vector. Notice the function signature &lt;code&gt;vec_map(v: &amp;amp;Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt;, where &lt;code&gt;v&lt;&#x2F;code&gt; is borrowed (&lt;code&gt;&amp;amp;v&lt;&#x2F;code&gt;). This concept, known as borrowing, is fundamental to Rust&#x27;s system of ownership.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;vecs2-rs-solution&quot;&gt;&lt;code&gt;vecs2.rs&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn vec_loop(mut v: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    for i in v.iter_mut() {
        *i *= 2;
    }
    v
}

fn vec_map(v: &amp;amp;Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    v.iter().map(|num| num * 2).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_loop() {
        let v: Vec&amp;lt;i32&amp;gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_loop(v.clone());

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;());
    }

    #[test]
    fn test_vec_map() {
        let v: Vec&amp;lt;i32&amp;gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_map(&amp;amp;v);

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;());
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here&#x27;s the complete block of code, clean-up a bit for clarity without the comments etc. With this code we will pass our test and we can move on to the next set of exercises.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;In this blog post, we explored Rust Vectors, a powerful and flexible data structure for handling dynamic arrays. We learned the difference between arrays and vectors in Rust and looked at some examples to understand how to create and manipulate vectors. We covered two different exercises: creating a vector from an array and performing operations on vector elements.&lt;&#x2F;p&gt;
&lt;p&gt;We learned how to create a vector using the &lt;code&gt;vec!&lt;&#x2F;code&gt; macro and how to create a vector with the &lt;code&gt;Vec::new()&lt;&#x2F;code&gt; function, and we also looked at the difference between mutable and immutable vectors. We discussed how to use loops and the &lt;code&gt;map&lt;&#x2F;code&gt; function for iterating over vectors and performing operations on their elements.&lt;&#x2F;p&gt;
&lt;p&gt;By understanding and utilizing Rust vectors, you can create efficient and flexible programs that can handle a wide range of scenarios involving dynamic arrays.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>05 Rustlings Primitive Types</title>
          <pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/05-rustlings-primitive-types/</link>
          <guid>https://desmodrone.github.io/posts/05-rustlings-primitive-types/</guid>
          <description xml:base="https://desmodrone.github.io/posts/05-rustlings-primitive-types/">&lt;p&gt;Rust has a couple of basic types that are directly implemented into the
compiler. In this section, we&#x27;ll go through the most important ones.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;p&gt;Additional reading resources can be found here:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch03-02-data-types.html&quot;&gt;Data Types&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch04-03-slices.html&quot;&gt;The Slice Type&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;primitive-types1-rs&quot;&gt;&lt;code&gt;primitive_types1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; primitive_types1.rs
&amp;#x2F;&amp;#x2F; Fill in the rest of the line that has code missing!
&amp;#x2F;&amp;#x2F; No hints, there&amp;#x27;s no tricks, just get used to typing these :)

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    &amp;#x2F;&amp;#x2F; Booleans (`bool`)

    let is_morning = true;
    if is_morning {
        println!(&amp;quot;Good morning!&amp;quot;);
    }

    let &amp;#x2F;&amp;#x2F; Finish the rest of this line like the example! Or make it be false!
    if is_evening {
        println!(&amp;quot;Good evening!&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the code comments it&#x27;s clear that we are looking at &lt;strong&gt;Booleans&lt;&#x2F;strong&gt; which are a type that is either &lt;code&gt;true&lt;&#x2F;code&gt; or &lt;code&gt;false&lt;&#x2F;code&gt; . With that in mind, let&#x27;s take a look at what the errors are to make sure we have a complete picture.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;primitive-trype1-rs-errors&quot;&gt;&lt;code&gt;primitive_trype1.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types1.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected identifier, found keyword `if`
  --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types1.rs:16:5
   |
16 |     if is_evening {
   |     ^^ expected identifier, found keyword

error: expected one of `:`, `;`, `=`, `@`, or `|`, found `is_evening`
  --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types1.rs:16:8
   |
16 |     if is_evening {
   |        ^^^^^^^^^^ expected one of `:`, `;`, `=`, `@`, or `|`

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These errors point to the fact that the &lt;code&gt;if_evening&lt;&#x2F;code&gt; portion of the code is incomplete, in fact it&#x27;s almost like the compiler is saying &amp;quot;wait a minute, shouldn&#x27;t you let me know what &lt;code&gt;is_evening&lt;&#x2F;code&gt; is?&amp;quot; instead, it found the keyword &lt;code&gt;if&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;primitive-types1-rs-solution&quot;&gt;&lt;code&gt;primitive_types1.rs&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; primitive_types1.rs
&amp;#x2F;&amp;#x2F; Fill in the rest of the line that has code missing!
&amp;#x2F;&amp;#x2F; No hints, there&amp;#x27;s no tricks, just get used to typing these :)

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    &amp;#x2F;&amp;#x2F; Booleans (`bool`)

    let is_morning = true;
    if is_morning {
        println!(&amp;quot;Good morning!&amp;quot;);
    }

    let is_evening = false; &amp;#x2F;&amp;#x2F; easy enough to complete this as above
    if is_evening {
        println!(&amp;quot;Good evening!&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This works out pretty quickly, by just defining what &lt;code&gt;is_evening&lt;&#x2F;code&gt; is with &lt;code&gt;let is_evening = false;&lt;&#x2F;code&gt; we get the code to compile and it prints:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰

Output:
====================
Good morning!

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Great, but what would happen if we make the both of them &lt;code&gt;true&lt;&#x2F;code&gt;? Let&#x27;s find out.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {
    &amp;#x2F;&amp;#x2F; Booleans (`bool`)

    let is_morning = true;
    if is_morning {
        println!(&amp;quot;Good morning!&amp;quot;);
    }

    let is_evening = true; &amp;#x2F;&amp;#x2F; making both `true`
    if is_evening {
        println!(&amp;quot;Good evening!&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This time we get a slightly different print, but the code still compiles.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;ðŸŽ‰ ðŸŽ‰  The code is compiling! ðŸŽ‰ ðŸŽ‰

Output:
====================
Good morning!
Good evening!

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Simple enough, we&#x27;re on to the next one.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;primitive-types2-rs&quot;&gt;&lt;code&gt;primitive_types2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; primitive_types2.rs
&amp;#x2F;&amp;#x2F; Fill in the rest of the line that has code missing!
&amp;#x2F;&amp;#x2F; No hints, there&amp;#x27;s no tricks, just get used to typing these :)

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    &amp;#x2F;&amp;#x2F; Characters (`char`)

    &amp;#x2F;&amp;#x2F; Note the _single_ quotes, these are different from the double quotes
    &amp;#x2F;&amp;#x2F; you&amp;#x27;ve been seeing around.
    let my_first_initial = &amp;#x27;C&amp;#x27;;
    if my_first_initial.is_alphabetic() {
        println!(&amp;quot;Alphabetical!&amp;quot;);
    } else if my_first_initial.is_numeric() {
        println!(&amp;quot;Numerical!&amp;quot;);
    } else {
        println!(&amp;quot;Neither alphabetic nor numeric!&amp;quot;);
    }

    let &amp;#x2F;&amp;#x2F; Finish this line like the example! What&amp;#x27;s your favorite character?
    &amp;#x2F;&amp;#x2F; Try a letter, try a number, try a special character, try a character
    &amp;#x2F;&amp;#x2F; from a different language than your own, try an emoji!
    if your_character.is_alphabetic() {
        println!(&amp;quot;Alphabetical!&amp;quot;);
    } else if your_character.is_numeric() {
        println!(&amp;quot;Numerical!&amp;quot;);
    } else {
        println!(&amp;quot;Neither alphabetic nor numeric!&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again we have no hints, so we have pay close attention to the code and the errors we get from the Rust compiler.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected identifier, found keyword `if`
  --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types2.rs:24:5
   |
24 |     if your_character.is_alphabetic() {
   |     ^^ expected identifier, found keyword

error: expected one of `:`, `;`, `=`, `@`, or `|`, found `your_character`
  --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types2.rs:24:8
   |
24 |     if your_character.is_alphabetic() {
   |        ^^^^^^^^^^^^^^ expected one of `:`, `;`, `=`, `@`, or `|`

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This looks similar to what we got in our previous exercise, essentially telling us that the &lt;code&gt;your_character&lt;&#x2F;code&gt; part of the code is incomplete.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s go through the comments in the code.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The first comment in &lt;code&gt;fn main()&lt;&#x2F;code&gt;  tells us that we are looking at &lt;strong&gt;Characters&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Second comment makes sure that we notice the use of single quotes on the line &lt;code&gt;let my_first_intial = &#x27;C&#x27; &lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;The third comment tells us to finish the &lt;code&gt;let&lt;&#x2F;code&gt; statement using the example we&#x27;ve seen but use our favorite character.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Looking at how the rest of the code is written, to make it easier on us, we can use the &lt;code&gt;your_character&lt;&#x2F;code&gt; variable that is being used, but of course as the errors tells us, is undefined. Let&#x27;s define it.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {

    let my_first_initial = &amp;#x27;C&amp;#x27;;
    if my_first_initial.is_alphabetic() {
        println!(&amp;quot;Alphabetical!&amp;quot;);
    } else if my_first_initial.is_numeric() {
        println!(&amp;quot;Numerical!&amp;quot;);
    } else {
        println!(&amp;quot;Neither alphabetic nor numeric!&amp;quot;);
    }

    let your_character = &amp;#x27;ðŸ¦€&amp;#x27;; &amp;#x2F;&amp;#x2F; we define it as a crab emoji just for fun.
    if your_character.is_alphabetic() {
        println!(&amp;quot;Alphabetical!&amp;quot;);
    } else if your_character.is_numeric() {
        println!(&amp;quot;Numerical!&amp;quot;);
    } else {
        println!(&amp;quot;Neither alphabetic nor numeric!&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;primitive-types3-rs&quot;&gt;&lt;code&gt;primitive_types3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; primitive_types3.rs
&amp;#x2F;&amp;#x2F; Create an array with at least 100 elements in it where the ??? is.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let a = ???

    if a.len() &amp;gt;= 100 {
        println!(&amp;quot;Wow, that&amp;#x27;s a big array!&amp;quot;);
    } else {
        println!(&amp;quot;Meh, I eat arrays like that for breakfast.&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we have clear instructions on what we need to do, and we even have a hint if we need it.  But let&#x27;s look at the errors first:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types3.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
 --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types3.rs:8:13
  |
8 |     let a = ???
  |             ^ expected expression

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Short and sweet, we see that on line 8, there&#x27;s an expected expression where we need to replace the &lt;code&gt;???&lt;&#x2F;code&gt; question marks. So what kind of expression do we need, well the instructions tell us it should be an array with at least 100 elements in it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;array-review&quot;&gt;Array Review&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s quickly review the ways that we can create an array in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;One of the simplest ways we can create an array in Rust is by using the &lt;code&gt;[]&lt;&#x2F;code&gt; square brackets and listing the elements inside of it, like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let a = [1, 2, 3, 4, 5, 6];
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can also define the array&#x27;s type by using another set of square brackets before the definition of the array, in a similar what that you define types when defining variables.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let a: [i32; 6] = [1, 2, 3, 4, 5, 6];
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These are both valid, but remember in our exercise we have to make an array with at least 100 elements in it -- there must be a better way. Luckily there is, as long as we want the array to contain the same value we can initialize the array like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let a = [3;5];
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This will give us an array called &lt;code&gt;a&lt;&#x2F;code&gt; with that will contain &lt;code&gt;5&lt;&#x2F;code&gt; elements with their value set to &lt;code&gt;3&lt;&#x2F;code&gt; this is the same as writing&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let a = [3, 3, 3, 3, 3];
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;but clearly in a more concise way.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;primitive-types3-rs-solution&quot;&gt;&lt;code&gt;primitive_types3.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have this information fresh in our minds we can clearly see the winning solution for our problem of having 100 elements in an array.
Let&#x27;s do it.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {
    let a = [1; 100];

    if a.len() &amp;gt;= 100 {
        println!(&amp;quot;Wow, that is a big array!&amp;quot;);
    } else {
        println!(&amp;quot;Meh, I eat arrays like that for breakfast.&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We get this back from the compiler:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Wow, that is a big array!

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and just to confirm, what if we make the array less than 100 elements? Let&#x27;s just change the &lt;code&gt;100&lt;&#x2F;code&gt; to &lt;code&gt;99&lt;&#x2F;code&gt; like this: &lt;code&gt;let a = [1; 99];&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Meh, I eat arrays like that for breakfast.

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;primitive-types4-rs&quot;&gt;&lt;code&gt;primitive_types4.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; primitive_types4.rs
&amp;#x2F;&amp;#x2F; Get a slice out of Array a where the ??? is so that the test passes.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[test]
fn slice_out_of_array() {
    let a = [1, 2, 3, 4, 5];

    let nice_slice = ???

    assert_eq!([2, 3, 4], nice_slice)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;primitive-types4-rs-error&quot;&gt;&lt;code&gt;primitive_types4.rs&lt;&#x2F;code&gt; error&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types4.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types4.rs:11:22
   |
11 |     let nice_slice = ???
   |                      ^ expected expression

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this piece of code we see almost the exact same set-up having to define a variable, in this case we need to define it with a slice.  Remembering a slice is essentially how we refer to part of an array, remember when we had the 100 element array in the previous exercise, or even a bigger array that had thousands of elements. Well what if only needed to access part of the array? We would use a slice in this scenario so let&#x27;s do it.&lt;&#x2F;p&gt;
&lt;p&gt;We define a slice by using &lt;code&gt;&amp;amp;[ ]&lt;&#x2F;code&gt; the &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; makes it like a reference, so we don&#x27;t have ownership of the array, but we can go deeper into this another time, let&#x27;s just define this slice.&lt;&#x2F;p&gt;
&lt;p&gt;The error code is also very straightforward, we&#x27;re being told that we&#x27;re missing an expression.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;primitive-types4-rs-solution&quot;&gt;&lt;code&gt;primitive_types4.rs&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;p&gt;we get a hint by the &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; part of the code as to what it&#x27;s looking for, elements &lt;code&gt;2&lt;&#x2F;code&gt;, &lt;code&gt;3&lt;&#x2F;code&gt;, and &lt;code&gt;4&lt;&#x2F;code&gt; so that&#x27;s what we&#x27;ll do.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn slice_out_of_array() {
    let a = [1, 2, 3, 4, 5];

    let nice_slice = &amp;amp;a[1..4]; &amp;#x2F;&amp;#x2F; using `a&amp;amp;[]` to create a slice we use the `..` to define the range

    assert_eq!([2, 3, 4], nice_slice)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So in this case we define the range to to be between &lt;code&gt;1 and 4&lt;&#x2F;code&gt; but remember that the first element in the array is at index &lt;code&gt;0&lt;&#x2F;code&gt; and element &lt;code&gt;4&lt;&#x2F;code&gt; is index &lt;code&gt;5&lt;&#x2F;code&gt;. Rust excludes the final element and therefore we get numbers &lt;code&gt;2, 3, 4&lt;&#x2F;code&gt; which correspond to index &lt;code&gt;1, 2, 3&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;All we get on this one is that the test is passing and code is compiling.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Just to confirm what we&#x27;re talking about above, let&#x27;s use a different slice range that what know is the solution, let&#x27;s use &lt;code&gt;&amp;amp;a[0..5]&lt;&#x2F;code&gt; and see what happens.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let nice_slice = &amp;amp;a[0..5];
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;test-failed&quot;&gt;Test Failed&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;running 1 test
test slice_out_of_array ... FAILED

successes:

successes:

failures:

---- slice_out_of_array stdout ----
thread &amp;#x27;slice_out_of_array&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `[2, 3, 4]`,
 right: `[1, 2, 3, 4, 5]`&amp;#x27;, exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types4.rs:13:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    slice_out_of_array

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As expected the test fails, and we see the elements that we select by using the &lt;code&gt;&amp;amp;a[0..5]&lt;&#x2F;code&gt; makes the test panic because the &lt;code&gt;assertion failed: (left == right)&lt;&#x2F;code&gt; in our code the left doesn&#x27;t equal the right and we can see that we are accessing the elements starting at index &lt;code&gt;0&lt;&#x2F;code&gt; and ending at index &lt;code&gt;5&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;primitive-types5-rs&quot;&gt;&lt;code&gt;primitive_types5.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; primitive_types5.rs
&amp;#x2F;&amp;#x2F; Destructure the `cat` tuple so that the println will work.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let cat = (&amp;quot;Furry McFurson&amp;quot;, 3.5);
    let &amp;#x2F;* your pattern here *&amp;#x2F; = cat;

    println!(&amp;quot;{} is {} years old.&amp;quot;, name, age);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;primitive-types5-rs-error&quot;&gt;&lt;code&gt;primitive_types5.rs&lt;&#x2F;code&gt;  error&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types5.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected pattern, found `=`
 --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types5.rs:9:33
  |
9 |     let &amp;#x2F;* your pattern here *&amp;#x2F; = cat;
  |                                 ^ expected pattern

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are to destructure the &lt;code&gt;cat&lt;&#x2F;code&gt; tuple so that the &lt;code&gt;println&lt;&#x2F;code&gt; will work, seems simple enough we have a clear indication in the code where this should take place, in our &lt;code&gt;let&lt;&#x2F;code&gt; variable assignment on line 8.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-tuple-type&quot;&gt;The Tuple Type&lt;&#x2F;h2&gt;
&lt;p&gt;So let&#x27;s quickly recap a Tuple and how we destructure it. A tuple is a compound type meaning that it can group together elements of different types, for example in our &lt;code&gt;let cat = (&amp;quot;Furry McFurson&amp;quot;, 3.5)&lt;&#x2F;code&gt; we can see that we have a &amp;amp;str and a floating-point type.
Let&#x27;s keep things simple for now and not go too deep into the &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; and what it means, for now we know it represents a string in our code.&lt;&#x2F;p&gt;
&lt;p&gt;So, another way we could have defined this tuple to be more explicit would have been like so (similar to our array in a previous exercise, where we defined the type for an array):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let cat: (&amp;amp;str, f64) = (&amp;quot;Furry McFurson&amp;quot;, 3.5);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we bind tuple to a variable, like in this case &lt;code&gt;cat&lt;&#x2F;code&gt; the variable is bound to the entire tuple as it&#x27;s considered a single compound element. So to get a single element out of the tuple we have to &lt;em&gt;destructure&lt;&#x2F;em&gt; the tuple by sort of inverting the variable like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let (a, b) = variable
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;primitive-types5-rs-solution&quot;&gt;&lt;code&gt;primitive_types5.rs&lt;&#x2F;code&gt;  solution&lt;&#x2F;h2&gt;
&lt;p&gt;In our case we can see that in the &lt;code&gt;println!&lt;&#x2F;code&gt; statement we are looking for a &lt;code&gt;name&lt;&#x2F;code&gt; and &lt;code&gt;age&lt;&#x2F;code&gt; elements, so let&#x27;s plug these into our code.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let cat = (&amp;quot;Furry McFurson&amp;quot;, 3.5);
    let (name, age) = cat;

    println!(&amp;quot;{} is {} years old.&amp;quot;, name, age);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s check our output&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Furry McFurson is 3.5 years old.

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;primitive-types6-rs&quot;&gt;&lt;code&gt;primitive_types6.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; primitive_types6.rs
&amp;#x2F;&amp;#x2F; Use a tuple index to access the second element of `numbers`.
&amp;#x2F;&amp;#x2F; You can put the expression for the second element where ??? is so that the test passes.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[test]
fn indexing_tuple() {
    let numbers = (1, 2, 3);
    &amp;#x2F;&amp;#x2F; Replace below ??? with the tuple indexing syntax.
    let second = ???;

    assert_eq!(2, second,
        &amp;quot;This is not the 2nd number in the tuple!&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;primitive-types6-rs-error&quot;&gt;&lt;code&gt;primitive_types6.rs&lt;&#x2F;code&gt;  error&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types6.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types6.rs:12:18
   |
12 |     let second = ???;
   |                  ^ expected expression

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions say to use a tuple index to access the second element of &lt;code&gt;numbers&lt;&#x2F;code&gt; and we can use place the expression in line 12 where the &lt;code&gt;let second = ???&lt;&#x2F;code&gt;, simple enough.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tuple-indexing&quot;&gt;Tuple Indexing&lt;&#x2F;h2&gt;
&lt;p&gt;But how do we access a tuple directly? By using the variable a period &lt;code&gt;.&lt;&#x2F;code&gt; followed by the index value.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let indexing = variable.0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright then, let&#x27;s apply this to our problem.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;primitive-types6-rs-solution&quot;&gt;&lt;code&gt;primitive_types6.rs&lt;&#x2F;code&gt;  solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[test]
fn indexing_tuple() {
    let numbers = (1, 2, 3);

    let second = numbers.1; &amp;#x2F;&amp;#x2F; using the tuple indexing syntax to get the 2nd element which is at index `1`

    assert_eq!(2, second, &amp;quot;This is not the 2nd number in the tuple!&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The only tricky part is to remember that indexes start at &lt;code&gt;0&lt;&#x2F;code&gt; so the second element is at index &lt;code&gt;1&lt;&#x2F;code&gt;. So if we were for example to change the &lt;code&gt;number.1&lt;&#x2F;code&gt; to &lt;code&gt;number.2&lt;&#x2F;code&gt;, if we mistakenly thought the correct index was &lt;code&gt;2&lt;&#x2F;code&gt; we&#x27;d get this text in our test:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;running 1 test
test indexing_tuple ... FAILED

successes:

successes:

failures:

---- indexing_tuple stdout ----
thread &amp;#x27;indexing_tuple&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `2`,
 right: `3`: This is not the 2nd number in the tuple!&amp;#x27;, exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types6.rs:14:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    indexing_tuple

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With the correct index number we don&#x27;t get anything special but a celebratory &lt;code&gt;code is compiling &lt;&#x2F;code&gt; message. Â &lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this post, we tackled various exercises related to primitive types in Rust. We explored arrays, tuples, slices, and tuple indexing while understanding how to create and manipulate them. We also learned about the error messages provided by the Rust compiler and how to interpret and resolve them to make our code work as expected.&lt;&#x2F;p&gt;
&lt;p&gt;These exercises are essential for building a strong foundation in Rust, as primitive types are the building blocks for more complex data structures and programs. By mastering these concepts, you&#x27;ll be well-prepared to tackle more advanced Rust topics and further enhance your Rust programming skills.&lt;&#x2F;p&gt;
&lt;p&gt;Keep practicing and exploring the Rust language, and don&#x27;t forget to consult the official Rust documentation when in doubt!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>04 Rustlings quiz1</title>
          <pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/04-rustlings-quiz1/</link>
          <guid>https://desmodrone.github.io/posts/04-rustlings-quiz1/</guid>
          <description xml:base="https://desmodrone.github.io/posts/04-rustlings-quiz1/">&lt;p&gt;Now we have our first quiz building on what we&#x27;ve learned so far. Here is the code and instructions written in the comments.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;quiz1-rs&quot;&gt;&lt;code&gt;quiz1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; quiz1.rs
&amp;#x2F;&amp;#x2F; This is a quiz for the following sections:
&amp;#x2F;&amp;#x2F; - Variables
&amp;#x2F;&amp;#x2F; - Functions
&amp;#x2F;&amp;#x2F; - If

&amp;#x2F;&amp;#x2F; Mary is buying apples. The price of an apple is calculated as follows:
&amp;#x2F;&amp;#x2F; - An apple costs 2 rustbucks.
&amp;#x2F;&amp;#x2F; - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!
&amp;#x2F;&amp;#x2F; Write a function that calculates the price of an order of apples given
&amp;#x2F;&amp;#x2F; the quantity bought. No hints this time!

&amp;#x2F;&amp;#x2F; I AM NOT DONE

&amp;#x2F;&amp;#x2F; Put your function here!
&amp;#x2F;&amp;#x2F; fn calculate_price_of_apples {

&amp;#x2F;&amp;#x2F; Don&amp;#x27;t modify this function!
#[test]
fn verify_test() {
    let price1 = calculate_price_of_apples(35);
    let price2 = calculate_price_of_apples(40);
    let price3 = calculate_price_of_apples(41);
    let price4 = calculate_price_of_apples(65);

    assert_eq!(70, price1);
    assert_eq!(80, price2);
    assert_eq!(41, price3);
    assert_eq!(65, price4);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is pretty straight forward, it&#x27;s clear we have to write a little bit of code, let&#x27;s recap what we know.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Mary is buying apples.&lt;&#x2F;li&gt;
&lt;li&gt;each apple is worth 2 rustbucks.&lt;&#x2F;li&gt;
&lt;li&gt;If Mary purchases more than 40 apples, the apple price for each goes down to 1 rust buck for each apple.&lt;&#x2F;li&gt;
&lt;li&gt;We need to create a function that calculates the correct price given the amount of apples purchased&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;quiz1-rs-errors&quot;&gt;&lt;code&gt;quiz1.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;quiz1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0425]: cannot find function `calculate_price_of_apples` in this scope
  --&amp;gt; exercises&amp;#x2F;quiz1.rs:21:18
   |
21 |     let price1 = calculate_price_of_apples(35);
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `calculate_price_of_apples` in this scope
  --&amp;gt; exercises&amp;#x2F;quiz1.rs:22:18
   |
22 |     let price2 = calculate_price_of_apples(40);
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `calculate_price_of_apples` in this scope
  --&amp;gt; exercises&amp;#x2F;quiz1.rs:23:18
   |
23 |     let price3 = calculate_price_of_apples(41);
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `calculate_price_of_apples` in this scope
  --&amp;gt; exercises&amp;#x2F;quiz1.rs:24:18
   |
24 |     let price4 = calculate_price_of_apples(65);
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We are getting are getting 4 errors all related to the &lt;code&gt;calculate_price_of_apples&lt;&#x2F;code&gt; function being out of scope. Well, that should be pretty obvious as to why, it&#x27;s not there...or in this case commented out.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;working-on-a-solution&quot;&gt;Working on a Solution&lt;&#x2F;h2&gt;
&lt;p&gt;As noted in the errors, we need to implement the function &lt;code&gt;fn_calculate_price_of_apples&lt;&#x2F;code&gt; so let&#x27;s start there, by removing the comment forward slashes. We&#x27;ll just add the code here without the additional comments.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Put your function here!
   fn calculate_price_of_apples {

&amp;#x2F;&amp;#x2F; Don&amp;#x27;t modify this function!
#[test]
fn verify_test() {
    let price1 = calculate_price_of_apples(35);
    let price2 = calculate_price_of_apples(40);
    let price3 = calculate_price_of_apples(41);
    let price4 = calculate_price_of_apples(65);

    assert_eq!(70, price1);
    assert_eq!(80, price2);
    assert_eq!(41, price3);
    assert_eq!(65, price4);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we think of what we&#x27;ve learned so far: &lt;code&gt;variables&lt;&#x2F;code&gt;, &lt;code&gt;if&lt;&#x2F;code&gt; statements and &lt;code&gt;functions&lt;&#x2F;code&gt; we should be able to use these and apply them to our quiz here, let&#x27;s start the function signature, we need to be explicit when defining our function signatures in Rust, so our function signature is missing a whole lot of information.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;completing-our-function-signature&quot;&gt;Completing our Function Signature&lt;&#x2F;h2&gt;
&lt;p&gt;If we need any hints we can go back to our &lt;code&gt;function&lt;&#x2F;code&gt; lesson and see how this current function looks incomplete, we should quickly notice that our current function signature looks incomplete compared to our previous exercises, so let&#x27;s fix that, by defining a variable that gets passed through the function as an &lt;code&gt;i32&lt;&#x2F;code&gt;, as well as adding a return value of &lt;code&gt;i32&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; how it&amp;#x27;s currently defined

fn calculate_price_of_apples {

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is how we&#x27;re going to update the function signature:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;add the parameters of &lt;code&gt;apples:i32&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;add a return value of &lt;code&gt;i32&lt;&#x2F;code&gt; so we can get that number from the function.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; passing through an `i32` that we define as `apples`

fn calculate_price_of_apples(apples:i32) -&amp;gt; i32 {

&amp;#x2F;&amp;#x2F; also adding the ` -&amp;gt; i32` to show that we&amp;#x27;ll also return an `i32`

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;adding-variables&quot;&gt;Adding Variables&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at variables we have to create inside of our function to complete the calculation of our price.
I guess the most logical variables would be the price right, we have the regular price and the discount price.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn calculate_price_of_apples(apples: i32) -&amp;gt; i32 {
	let regular_price: i32 = 2; &amp;#x2F;&amp;#x2F; defining a regular price
	let discount_price: i32 = 1; &amp;#x2F;&amp;#x2F; defining a dicount price
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Easy enough right? We have defined a &lt;code&gt;regular_price&lt;&#x2F;code&gt; and a &lt;code&gt;discount_price&lt;&#x2F;code&gt; is based on the information we were given. Now let&#x27;s go to the next step in our function defining our &lt;code&gt;if&lt;&#x2F;code&gt; expression.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;controlling-our-conditions-with-if&quot;&gt;Controlling our Conditions with &lt;code&gt;if&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s quickly recap what we tools we have made so far:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We&#x27;ve defined our function signature so it takes and returns and &lt;code&gt;i32&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;We&#x27;ve created two different variables that define a &lt;code&gt;regular_price&lt;&#x2F;code&gt; or a &lt;code&gt;discounted_price&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Now we need a way to let our function choose a branch of code depending the quantity of apples. The &lt;code&gt;if&lt;&#x2F;code&gt; keyword let&#x27;s us do this as we previously learned in lesson 3 so let&#x27;s implement this within our function.&lt;&#x2F;p&gt;
&lt;p&gt;First let&#x27;s think about this in plain English, remembering that Mary get&#x27;s a price break &lt;em&gt;after&lt;&#x2F;em&gt; apple number 40, we can say that &amp;quot;if Mary buys 40 or less apples&amp;quot; it&#x27;s regular price, &amp;quot;if Mary buys 41 or more apples&amp;quot; it&#x27;s a discount price. Of course in code it&#x27;s a little different and we can always reference the &lt;code&gt;if&lt;&#x2F;code&gt; lesson for the syntax.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn calculate_price_of_apples(apples: i32) -&amp;gt; i32 {
	let regular_price: i32 = 2;
	let discount_price: i32 = 1;
	   &amp;#x2F;&amp;#x2F; defining if the quantity of `apples` purchased are 40 or less
	   if apples &amp;lt;= 40 {
		&amp;#x2F;&amp;#x2F; here&amp;#x27;s the simple math to calculate the result
		apples * regular_price
		&amp;#x2F;&amp;#x2F; `else` let&amp;#x27;s us add the other part of the expression
		} else {
		 &amp;#x2F;&amp;#x2F; this multiples the number of apples which are above 40
		apples * discount_price
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And that&#x27;s it, our code compiles and passes all tests, so we&#x27;ve finished our first quiz. This is what the final full code will look like, without all the comments for visual clarity:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn calculate_price_of_apples(apples: i32) -&amp;gt; i32 {
    let regular_price: i32 = 2;
    let discount_price: i32 = 1;

    if apples &amp;lt;= 40 {

        apples * regular_price
    } else {
        apples * discount_price
    }
}
&amp;#x2F;&amp;#x2F; Don&amp;#x27;t modify this function!
#[test]
fn verify_test() {
    let price1 = calculate_price_of_apples(35);
    let price2 = calculate_price_of_apples(40);
    let price3 = calculate_price_of_apples(41);
    let price4 = calculate_price_of_apples(65);

    assert_eq!(70, price1);
    assert_eq!(80, price2);
    assert_eq!(41, price3);
    assert_eq!(65, price4);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we reviewed a Rust quiz about variables, functions, and if statements. We worked through the errors provided by the compiler and wrote a solution to calculate the price of apples based on the quantity bought. We first defined the function signature, which was incomplete, and added the appropriate information to pass and return an &lt;code&gt;i32&lt;&#x2F;code&gt;. We then created variables for the regular and discounted prices of the apples. Finally, we used an &lt;code&gt;if&lt;&#x2F;code&gt; expression to control the calculation of the price based on the quantity of apples bought, with a break for the discounted price starting at 40 apples.&lt;&#x2F;p&gt;
&lt;p&gt;By working through this quiz, we demonstrated how to apply the concepts of variables, functions, and if statements in Rust to solve a problem. We hope this blog post provides a clear and helpful review of these concepts and helps you better understand how to use them in your own Rust programming.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>03 Rustlings if</title>
          <pubDate>Fri, 21 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/03-rustlings-if/</link>
          <guid>https://desmodrone.github.io/posts/03-rustlings-if/</guid>
          <description xml:base="https://desmodrone.github.io/posts/03-rustlings-if/">&lt;p&gt;&lt;code&gt;if&lt;&#x2F;code&gt;, is the most basic but still very versatile type of control flow, these next couple of exercises will go through this little word.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;additional-reading&quot;&gt;Additional Reading&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch03-05-control-flow.html#if-expressions&quot;&gt;Control Flow - if expressions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;if1-rs&quot;&gt;&lt;code&gt;if1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; if1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub fn bigger(a: i32, b: i32) -&amp;gt; i32 {
    &amp;#x2F;&amp;#x2F; Complete this function to return the bigger number!
    &amp;#x2F;&amp;#x2F; Do not use:
    &amp;#x2F;&amp;#x2F; - another function call
    &amp;#x2F;&amp;#x2F; - additional variables
}

&amp;#x2F;&amp;#x2F; Don&amp;#x27;t mind this for now :)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ten_is_bigger_than_eight() {
        assert_eq!(10, bigger(10, 8));
    }

    #[test]
    fn fortytwo_is_bigger_than_thirtytwo() {
        assert_eq!(42, bigger(32, 42));
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright looks like we have our first real writing of some basic code -- we need to create an &lt;code&gt;if&lt;&#x2F;code&gt; statement that will compare 2 numbers or variables &lt;code&gt;a&lt;&#x2F;code&gt; or &lt;code&gt;b&lt;&#x2F;code&gt; and return which one is bigger.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;if1-rs-errors&quot;&gt;&lt;code&gt;if1.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;if&amp;#x2F;if1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
 --&amp;gt; exercises&amp;#x2F;if&amp;#x2F;if1.rs:6:34
  |
6 | pub fn bigger(a: i32, b: i32) -&amp;gt; i32 {
  |        ------                    ^^^ expected `i32`, found `()`
  |        |
  |        implicitly returns `()` as its body has no tail or `return` expression
  |
note: consider returning one of these bindings
 --&amp;gt; exercises&amp;#x2F;if&amp;#x2F;if1.rs:6:15
  |
6 | pub fn bigger(a: i32, b: i32) -&amp;gt; i32 {
  |               ^       ^

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s look at what the &lt;code&gt;rust_errors&lt;&#x2F;code&gt; are telling us here.&lt;&#x2F;p&gt;
&lt;p&gt;The line &lt;code&gt;^^^ expected&lt;&#x2F;code&gt;i32&lt;code&gt;, found &lt;&#x2F;code&gt;()`` is essentially telling us that there is no return expression because there is nothing in the body of the function &lt;code&gt;bigger&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The solution is pretty simple, it&#x27;s  to add an &lt;code&gt;if&lt;&#x2F;code&gt; &lt;code&gt;a &amp;lt; b&lt;&#x2F;code&gt; expression.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;if1-rs-solution&quot;&gt;&lt;code&gt;if1.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn bigger(a: i32, b: i32) -&amp;gt; i32 {
    if a &amp;lt; b {
        b
    } else {
        a
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This compiles but the hint reminds me that it can also be done in one line, let&#x27;s try that, it works just fine and looks like this&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn bigger(a: i32, b:i32) -&amp;gt; i32 {
	if a &amp;lt; b { b } else { a }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I&#x27;m also reminded that :&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;in Rust the &lt;code&gt;if&lt;&#x2F;code&gt; condition doesn&#x27;t need to be surrounded by parentheses&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;if&#x2F;else&lt;&#x2F;code&gt; conditionals are expressions&lt;&#x2F;li&gt;
&lt;li&gt;Each condition is followed by a &lt;code&gt;{}&lt;&#x2F;code&gt; block&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Okay, let&#x27;s move on to the next exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;if2-rs&quot;&gt;&lt;code&gt;if2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; if2.rs

&amp;#x2F;&amp;#x2F; Step 1: Make me compile!
&amp;#x2F;&amp;#x2F; Step 2: Get the bar_for_fuzz and default_to_baz tests passing!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub fn foo_if_fizz(fizzish: &amp;amp;str) -&amp;gt; &amp;amp;str {
    if fizzish == &amp;quot;fizz&amp;quot; {
        &amp;quot;foo&amp;quot;
    } else {
        1
    }
}

&amp;#x2F;&amp;#x2F; No test changes needed!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn foo_for_fizz() {
        assert_eq!(foo_if_fizz(&amp;quot;fizz&amp;quot;), &amp;quot;foo&amp;quot;)
    }

    #[test]
    fn bar_for_fuzz() {
        assert_eq!(foo_if_fizz(&amp;quot;fuzz&amp;quot;), &amp;quot;bar&amp;quot;)
    }

    #[test]
    fn default_to_baz() {
        assert_eq!(foo_if_fizz(&amp;quot;literally anything&amp;quot;), &amp;quot;baz&amp;quot;)
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;if2-rs-errors&quot;&gt;&lt;code&gt;if2.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;if&amp;#x2F;if2.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;if&amp;#x2F;if2.rs:13:9
   |
9  | pub fn foo_if_fizz(fizzish: &amp;amp;str) -&amp;gt; &amp;amp;str {
   |                                      ---- expected `&amp;amp;str` because of return type
...
13 |         1
   |         ^ expected `&amp;amp;str`, found integer

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first comments state that we first have to make the code compile, so the first thing to do in this case is to add the &lt;code&gt;bar&lt;&#x2F;code&gt; by replacing the &lt;code&gt;1&lt;&#x2F;code&gt; which the Rust compile clearly states that it expected an &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; and this is an integer.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; if2.rs

&amp;#x2F;&amp;#x2F; Step 1: Make me compile!
&amp;#x2F;&amp;#x2F; Step 2: Get the bar_for_fuzz and default_to_baz tests passing!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub fn foo_if_fizz(fizzish: &amp;amp;str) -&amp;gt; &amp;amp;str {
    if fizzish == &amp;quot;fizz&amp;quot; {
        &amp;quot;foo&amp;quot;
    } else {
        &amp;quot;bar&amp;quot; &amp;#x2F;&amp;#x2F; add bar to get it to compile
    }
}

&amp;#x2F;&amp;#x2F; No test changes needed!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn foo_for_fizz() {
        assert_eq!(foo_if_fizz(&amp;quot;fizz&amp;quot;), &amp;quot;foo&amp;quot;)
    }

    #[test]
    fn bar_for_fuzz() {
        assert_eq!(foo_if_fizz(&amp;quot;fuzz&amp;quot;), &amp;quot;bar&amp;quot;)
    }

    #[test]
    fn default_to_baz() {
        assert_eq!(foo_if_fizz(&amp;quot;literally anything&amp;quot;), &amp;quot;baz&amp;quot;)
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once we replace this with &lt;code&gt;bar&lt;&#x2F;code&gt; it compiles, but it still doesn&#x27;t pass the test, which is our step 2. in the comments.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Testing of exercises&amp;#x2F;if&amp;#x2F;if2.rs failed! Please try again. Here&amp;#x27;s the output:

running 3 tests
test tests::bar_for_fuzz ... ok
test tests::foo_for_fizz ... ok
test tests::default_to_baz ... FAILED

successes:

successes:
    tests::bar_for_fuzz
    tests::foo_for_fizz

failures:

---- tests::default_to_baz stdout ----
thread &amp;#x27;tests::default_to_baz&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `&amp;quot;bar&amp;quot;`,
 right: `&amp;quot;baz&amp;quot;`&amp;#x27;, exercises&amp;#x2F;if&amp;#x2F;if2.rs:34:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::default_to_baz

test result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So here we see that the first two test are passing &lt;code&gt;bar_for_fuzz&lt;&#x2F;code&gt; and &lt;code&gt;foo_for_fizz&lt;&#x2F;code&gt; but &lt;code&gt;default_to_baz&lt;&#x2F;code&gt; is not. So let&#x27;s take a closer look at the tests and see why this is happening.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;foo-for-fizz-test&quot;&gt;&lt;code&gt;foo_for_fizz&lt;&#x2F;code&gt; test&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    #[test]
    fn foo_for_fizz() {
        assert_eq!(foo_if_fizz(&amp;quot;fizz&amp;quot;), &amp;quot;foo&amp;quot;) &amp;#x2F;&amp;#x2F; first test clearly defined in our `if` statement
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which is in our code with&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;if fizzish == &amp;quot;fizz&amp;quot; {
	&amp;quot;foo&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;bar-for-fuzz-test&quot;&gt;&lt;code&gt;bar_for_fuzz&lt;&#x2F;code&gt; test&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    #[test]
    fn bar_for_fuzz() {
        assert_eq!(foo_if_fizz(&amp;quot;fuzz&amp;quot;), &amp;quot;bar&amp;quot;) &amp;#x2F;&amp;#x2F; if we have &amp;quot;fuzz&amp;quot; we should get &amp;quot;bar&amp;quot;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This tells us that if have &lt;code&gt;Fuzz&lt;&#x2F;code&gt; then we get bar, but this is working only because we have &lt;code&gt;&amp;quot;bar&amp;quot;&lt;&#x2F;code&gt; as our &lt;code&gt;else&lt;&#x2F;code&gt; not because we have &lt;code&gt;&amp;quot;fuzz&amp;quot;&lt;&#x2F;code&gt; defined.&lt;&#x2F;p&gt;
&lt;p&gt;We do so by adding an &lt;code&gt;else if&lt;&#x2F;code&gt; statement like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;else if fizzish == &amp;quot;fuzz&amp;quot; {
	&amp;quot;bar&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This will meet the conditions of our second test&lt;&#x2F;p&gt;
&lt;h2 id=&quot;default-to-baz-test&quot;&gt;&lt;code&gt;default_to_baz&lt;&#x2F;code&gt; test&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[test]
    fn default_to_baz() {
        assert_eq!(foo_if_fizz(&amp;quot;literally anything&amp;quot;), &amp;quot;baz&amp;quot;)
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In our final test we see that it&#x27;s saying whatever else, doesn&#x27;t matter what it is, just give me &lt;code&gt;&amp;quot;baz&amp;quot;&lt;&#x2F;code&gt; so we can easily do that by adding our final &lt;code&gt;else&lt;&#x2F;code&gt; condition to our &lt;code&gt;foo_if_fizz&lt;&#x2F;code&gt; function, that would look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn foo_if_fizz(fizzish: &amp;amp;str) -&amp;gt; &amp;amp;str {
    if fizzish == &amp;quot;fizz&amp;quot; {
        &amp;quot;foo&amp;quot;
    } else if fizzish == &amp;quot;fuzz&amp;quot; {
        &amp;quot;bar&amp;quot;
    } else { &amp;#x2F;&amp;#x2F; whatever else it is, just make it `&amp;quot;baz&amp;quot;`
        &amp;quot;baz&amp;quot;
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This gets our code to compile and pass it&#x27;s tests successfully.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Progress: [########&amp;gt;---------------------------------------------------] 14&amp;#x2F;94
âœ… Successfully tested exercises&amp;#x2F;if&amp;#x2F;if2.rs!

ðŸŽ‰ ðŸŽ‰  The code is compiling, and the tests pass! ðŸŽ‰ ðŸŽ‰
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright, I guess we get our first quiz after this ðŸ˜§.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we delved into Rust &lt;code&gt;if&lt;&#x2F;code&gt; expressions, which are a fundamental part of the language&#x27;s control flow. We explored how to use &lt;code&gt;if&lt;&#x2F;code&gt;, &lt;code&gt;else if&lt;&#x2F;code&gt;, and &lt;code&gt;else&lt;&#x2F;code&gt; statements to create conditionals and solve problems in Rust. Additionally, we learned about Rust&#x27;s unique features, such as not requiring parentheses around &lt;code&gt;if&lt;&#x2F;code&gt; conditions and the treatment of &lt;code&gt;if&#x2F;else&lt;&#x2F;code&gt; conditionals as expressions. By understanding and mastering Rust &lt;code&gt;if&lt;&#x2F;code&gt; expressions, you&#x27;ll be better equipped to write efficient and clean Rust code for various applications.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>02 Rustlings functions</title>
          <pubDate>Wed, 19 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/02-rustlings-functions/</link>
          <guid>https://desmodrone.github.io/posts/02-rustlings-functions/</guid>
          <description xml:base="https://desmodrone.github.io/posts/02-rustlings-functions/">&lt;p&gt;With function we can learn to write more complex code and lean on the Rust debug errors for help.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch03-03-how-functions-work.html&quot;&gt;How Functions Work&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;functions1-rs&quot;&gt;&lt;code&gt;functions1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    call_me();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;rust-error-for-function1-rs&quot;&gt;Rust Error for &lt;code&gt;function1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s take a look at the compiler output so we can see what it&#x27;s telling us fix.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸ Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0425]: cannot find function `call_me` in this scope
 --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions1.rs:7:5
  |
7 |     call_me();
  |     ^^^^^^^ not found in this scope

error: aborting due to previous error

For more information about this error, try `rustc --explain E0425`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So what is this telling us? It&#x27;s essentially saying that &lt;code&gt;call me&lt;&#x2F;code&gt; is not defined within &lt;code&gt;fn main()&lt;&#x2F;code&gt; because we&#x27;re trying to call it, but it doesn&#x27;t know what to do with it. So let&#x27;s fix it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function1-rs-solution&quot;&gt;&lt;code&gt;function1.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.

fn main() {
    fn call_me() {  &amp;#x2F;&amp;#x2F; we define a basic function called call_me()
    }
    call_me();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s easy enough we create a functioned called &lt;code&gt;call_me()&lt;&#x2F;code&gt; inside of our &lt;code&gt;fn main()&lt;&#x2F;code&gt; so when we call it, the compiler knows where to look. Of course at this point it&#x27;s not doing much of anything.&lt;&#x2F;p&gt;
&lt;p&gt;We can modify this a little and make the function do something, like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    fn call_me() {
        println!(&amp;quot;Call me please&amp;quot;) &amp;#x2F;&amp;#x2F; add a println! with at string inside the call_me() function
    }
    call_me();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Putting a &lt;code&gt;println!&lt;&#x2F;code&gt; with some text will print out the text when &lt;code&gt;call_me()&lt;&#x2F;code&gt; is called. In this case: &lt;code&gt;Call me please&lt;&#x2F;code&gt; or if we wanted to some math, we could do:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.

fn main() {
    fn call_me() {
        println!(&amp;quot;{}&amp;quot;, 4+4) &amp;#x2F;&amp;#x2F; here we change the string into a simple addition
    }
    call_me();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This would print: &lt;code&gt;8&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function2-rs&quot;&gt;&lt;code&gt;function2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    call_me(3);
}

fn call_me(num:) {
    for i in 0..num {
        println!(&amp;quot;Ring! Call number {}&amp;quot;, i + 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;rust-errors-for-function2-rs&quot;&gt;Rust Errors for &lt;code&gt;function2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected type, found `)`
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions2.rs:10:16
   |
10 | fn call_me(num:) {
   |                ^ expected type

error[E0425]: cannot find value `num` in this scope
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions2.rs:11:17
   |
11 |     for i in 0..num {
   |                 ^^^ not found in this scope
   |
help: you might have meant to write `.` instead of `..`
   |
11 -     for i in 0..num {
11 +     for i in 0.num {
   |

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0425`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright so I&#x27;ve got a couple of errors here:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Line 10, there&#x27;s a type expected, so we fix that by adding &lt;code&gt;i32&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Adding the type solved all of our problems, nothing else do here.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function2-rs-solution&quot;&gt;&lt;code&gt;function2.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.

fn main() {
    call_me(3);
}

fn call_me(num: i32) { &amp;#x2F;&amp;#x2F; added the `i32` type here
    for i in 0..num {
        println!(&amp;quot;Ring! Call number {}&amp;quot;, i + 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This reminds us that Rust&#x27;s function signatures require type annotations. Once we fixed the function&#x27;s signature we get the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Ring! Call number 1
Ring! Call number 2
Ring! Call number 3

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;function3-rs&quot;&gt;&lt;code&gt;function3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions3.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    call_me();
}

fn call_me(num: u32) {
    for i in 0..num {
        println!(&amp;quot;Ring! Call number {}&amp;quot;, i + 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;rust-errors-for-function3-rs&quot;&gt;Rust errors for &lt;code&gt;function3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions3.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0061]: this function takes 1 argument but 0 arguments were supplied
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions3.rs:7:5
   |
7  |     call_me();
   |     ^^^^^^^-- an argument of type `u32` is missing
   |
note: function defined here
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions3.rs:10:4
   |
10 | fn call_me(num: u32) {
   |    ^^^^^^^ --------
help: provide the argument
   |
7  |     call_me(&amp;#x2F;* u32 *&amp;#x2F;);
   |            ~~~~~~~~~~~

error: aborting due to previous error

For more information about this error, try `rustc --explain E0061`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once again the Rust compiler comes through with a very clear suggestion pointing out that &lt;code&gt;call_me()&lt;&#x2F;code&gt; is missing an argument of type &lt;code&gt;u32&lt;&#x2F;code&gt; it even provides &lt;code&gt;help&lt;&#x2F;code&gt; in the last segment showing us where to put the &lt;code&gt;u32&lt;&#x2F;code&gt;: &lt;code&gt;call_me(&#x2F;* u32 *&#x2F;);&lt;&#x2F;code&gt; How great is that. So what &lt;code&gt;u32&lt;&#x2F;code&gt; should we put in there? Let&#x27;s try &lt;code&gt;6&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;functions3-rs-solution&quot;&gt;&lt;code&gt;functions3.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions3.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions3` or use the `hint` watch subcommand for a hint.

fn main() {
    call_me(6); &amp;#x2F;&amp;#x2F; we&amp;#x27;ve added 6 here
}

fn call_me(num: u32) {
    for i in 0..num {
        println!(&amp;quot;Ring! Call number {}&amp;quot;, i + 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And just like that we&#x27;re back in business. Our &lt;code&gt;fn main()&lt;&#x2F;code&gt; runs and calls &lt;code&gt;call_me&lt;&#x2F;code&gt; six times because that&#x27;s the number we&#x27;ve passed in to &lt;code&gt;call_me(6)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Ring! Call number 1
Ring! Call number 2
Ring! Call number 3
Ring! Call number 4
Ring! Call number 5
Ring! Call number 6

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Just to be clear in this case we could put any &lt;code&gt;u32&lt;&#x2F;code&gt; we wanted, including &lt;code&gt;0&lt;&#x2F;code&gt;, but that doesn&#x27;t print anything. We can&#x27;t pass in a negative number in this case either because defined a &lt;code&gt;u32&lt;&#x2F;code&gt; and exceeding the limit of a &lt;code&gt;u32&lt;&#x2F;code&gt; would also fail.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function4-rs&quot;&gt;&lt;code&gt;function4.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions4.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions4` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; This store is having a sale where if the price is an even number, you get
&amp;#x2F;&amp;#x2F; 10 Rustbucks off, but if it&amp;#x27;s an odd number, it&amp;#x27;s 3 Rustbucks off.
&amp;#x2F;&amp;#x2F; (Don&amp;#x27;t worry about the function bodies themselves, we&amp;#x27;re only interested
&amp;#x2F;&amp;#x2F; in the signatures for now. If anything, this is a good way to peek ahead
&amp;#x2F;&amp;#x2F; to future exercises!)

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let original_price = 51;
    println!(&amp;quot;Your sale price is {}&amp;quot;, sale_price(original_price));
}

fn sale_price(price: i32) -&amp;gt; {
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
}

fn is_even(num: i32) -&amp;gt; bool {
    num % 2 == 0
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;re getting a little more instruction here, but as always the key lies in looking at the Rust compiler&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions4.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected type, found `{`
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions4.rs:17:30
   |
17 | fn sale_price(price: i32) -&amp;gt; {
   |                              ^ expected type

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Looks pretty straight forward, line 17 is missing a type in the function&#x27;s signature, looks like we should expect to return an &lt;code&gt;i32&lt;&#x2F;code&gt;, so let&#x27;s try that.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let original_price = 51;
    println!(&amp;quot;Your sale price is {}&amp;quot;, sale_price(original_price));
}

fn sale_price(price: i32) -&amp;gt; i32 { &amp;#x2F;&amp;#x2F; added return type here: `i32`
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
}

fn is_even(num: i32) -&amp;gt; bool {
    num % 2 == 0
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And it works. Nothing too difficult, if you look at the &lt;code&gt;is_even&lt;&#x2F;code&gt; function there the function is returning a &lt;code&gt;bool&lt;&#x2F;code&gt; instead of an &lt;code&gt;i32&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Your sale price is 48

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;function5-rs&quot;&gt;&lt;code&gt;function5.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions5.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions5` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let answer = square(3);
    println!(&amp;quot;The square of 3 is {}&amp;quot;, answer);
}

fn square(num: i32) -&amp;gt; i32 {
    num * num;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;function5-rs-errors&quot;&gt;&lt;code&gt;function5.rs&lt;&#x2F;code&gt; Errors&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;âš ï¸  Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions5.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions5.rs:11:24
   |
11 | fn square(num: i32) -&amp;gt; i32 {
   |    ------              ^^^ expected `i32`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
12 |     num * num;
   |              - help: remove this semicolon to return this value

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is once again a very helpful explanation from the compiler, if we look at the &lt;code&gt;help: remove this semicolon to return this value&lt;&#x2F;code&gt; note, it tells why we are getting the error on line 11. Because with a &lt;code&gt;;&lt;&#x2F;code&gt; semicolon this function has no return value and this function expects a return value as we have defined in the function signature. So how do we solve this?&lt;&#x2F;p&gt;
&lt;p&gt;The easiest way is to remove the semicolon as the Rust compiler suggests, but just so we have another solution we can also use the &lt;code&gt;return&lt;&#x2F;code&gt; keyword. From my understanding it&#x27;s more idiomatic to just remove the &lt;code&gt;;&lt;&#x2F;code&gt; but I wanted to also bring up the possibility of using &lt;code&gt;return&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The reason this happens in Rust is because the compiler distinguishes between expressions and statements. Expressions return a value based on their operands(s), and statements simply return a &lt;code&gt;()&lt;&#x2F;code&gt; type.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function5-rs-solution&quot;&gt;&lt;code&gt;function5.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let answer = square(3);
    println!(&amp;quot;The square of 3 is {}&amp;quot;, answer);
}

fn square(num: i32) -&amp;gt; i32 {
    num * num
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
The square of 3 is 9

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we&#x27;ve explored various Rust functions and the importance of function signatures, including specifying the correct types for both input parameters and return values. We have also seen how the Rust compiler provides helpful error messages and suggestions to guide us in fixing issues with our code. Additionally, we&#x27;ve briefly touched upon the differences between expressions and statements in Rust, which determine whether a value is returned or not.&lt;&#x2F;p&gt;
&lt;p&gt;Remember that Rust functions are powerful tools for writing clean, maintainable code. Keep practicing and exploring different function patterns, and you&#x27;ll soon become proficient in writing complex Rust programs.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>01 Rustlings variables</title>
          <pubDate>Mon, 17 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/01-rustlings-variables/</link>
          <guid>https://desmodrone.github.io/posts/01-rustlings-variables/</guid>
          <description xml:base="https://desmodrone.github.io/posts/01-rustlings-variables/">&lt;p&gt;In Rust, variables are immutable by default.
When a variable is immutable, once a value is bound to a name, you canâ€™t change that value.
You can however, make a variable mutable by adding &lt;code&gt;mut&lt;&#x2F;code&gt; in front of the variable name.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-reading&quot;&gt;Further reading:&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch03-01-variables-and-mutability.html&quot;&gt;Variables and Mutability&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;variables1-rs&quot;&gt;&lt;code&gt;variables1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables1.rs
&amp;#x2F;&amp;#x2F; Make me compile!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables1` or use the `hint` watch subcommand for a hint.

fn main() {
    let x = 5; &amp;#x2F;&amp;#x2F; very simple excerize that is missing the `let`
    println!(&amp;quot;x has the value {}&amp;quot;, x);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Adding the &lt;code&gt;let&lt;&#x2F;code&gt; to the statement allows &lt;code&gt;x&lt;&#x2F;code&gt; to bind to &lt;code&gt;5&lt;&#x2F;code&gt;, very straight forward solution&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables2-rs&quot;&gt;&lt;code&gt;variables2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables2` or use the `hint` watch subcommand for a hint.

fn main() {
    let x: u8 = 5; &amp;#x2F;&amp;#x2F; you could also just write `let x = 5`
    if x == 10 {
        println!(&amp;quot;x is ten!&amp;quot;);
    } else {
        println!(&amp;quot;x is not ten!&amp;quot;);
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is basically the opposite of what we saw before with the variable binding in the &lt;code&gt;variables1.rs&lt;&#x2F;code&gt; example, except in this case we&#x27;re missing the number that &lt;code&gt;x&lt;&#x2F;code&gt; should be bound to.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables3-rs&quot;&gt;&lt;code&gt;variables3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables3.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.

fn main() {
    let x: i32 = -123; &amp;#x2F;&amp;#x2F; adding `= -123` for the code to compile.
    println!(&amp;quot;Number {}&amp;quot;, x);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since we have &lt;code&gt;x&lt;&#x2F;code&gt; as an &lt;code&gt;i32&lt;&#x2F;code&gt; let&#x27;s have some fun and add a negative number. Again this was missing the second half of the statement.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables4-rs&quot;&gt;&lt;code&gt;variables4.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables4.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables4` or use the `hint` watch subcommand for a hint.

fn main() {
    let mut x = 3; &amp;#x2F;&amp;#x2F; mut is the key here
    println!(&amp;quot;Number {}&amp;quot;, x);
    x = 5; &amp;#x2F;&amp;#x2F; don&amp;#x27;t change this line
    println!(&amp;quot;Number {}&amp;quot;, x);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As the opening text declares variables are immutable by default so this code doesn&#x27;t compile because &lt;code&gt;x&lt;&#x2F;code&gt; is being  bound twice to different numbers without declaring it &lt;code&gt;mut&lt;&#x2F;code&gt;, this code will not compile.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables5-rs&quot;&gt;&lt;code&gt;variables5.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables5.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables5` or use the `hint` watch subcommand for a hint.

fn main() {
    let number = &amp;quot;T-H-R-E-E&amp;quot;; &amp;#x2F;&amp;#x2F; don&amp;#x27;t change this line
    println!(&amp;quot;Spell a Number : {}&amp;quot;, number);
    let number = 3; &amp;#x2F;&amp;#x2F; don&amp;#x27;t rename this variable
    println!(&amp;quot;Number plus two is : {}&amp;quot;, number + 2);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this exercise we don&#x27;t rename the variable &lt;code&gt;number&lt;&#x2F;code&gt; but we shadow it by declaring it again with &lt;code&gt;let&lt;&#x2F;code&gt; this allows us to change the type from a &lt;code&gt;&amp;amp;Str&lt;&#x2F;code&gt; to a integer.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables6-rs&quot;&gt;&lt;code&gt;variables6.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables6.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables6` or use the `hint` watch subcommand for a hint.


const NUMBER: i32 = 3; &amp;#x2F;&amp;#x2F; added `:i32`
fn main() {
    println!(&amp;quot;Number {}&amp;quot;, NUMBER);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Constants are another type of variable that is available, but these are &lt;em&gt;always&lt;&#x2F;em&gt; immutable they&#x27;re declared with &lt;code&gt;const&lt;&#x2F;code&gt; instead of let and types must always be annotated. So we have to add &lt;code&gt;: i32&lt;&#x2F;code&gt; to make the code compile.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Understanding variables and their mutability is an essential aspect of learning Rust. This blog post covered the Rustlings exercises that demonstrated the usage of variables in different scenarios, including how to declare and shadow variables, work with constants, and use the &lt;code&gt;mut&lt;&#x2F;code&gt; keyword to make variables mutable. These fundamental concepts lay the groundwork for grasping more advanced topics in Rust programming.&lt;&#x2F;p&gt;
&lt;p&gt;As you continue your Rust journey, always remember that variables in Rust are immutable by default, providing safety and predictability in your code. When needed, you can use the &lt;code&gt;mut&lt;&#x2F;code&gt; keyword to allow a variable to be mutable. Constants are also available, providing values that cannot be changed and must have their types annotated.&lt;&#x2F;p&gt;
&lt;p&gt;I encourage you to explore the Rust documentation and practice further exercises to strengthen your understanding of these concepts. Happy coding!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Hello (again) Rustlings: Index</title>
          <pubDate>Tue, 11 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/hello-rustlings/</link>
          <guid>https://desmodrone.github.io/posts/hello-rustlings/</guid>
          <description xml:base="https://desmodrone.github.io/posts/hello-rustlings/">&lt;h2 id=&quot;rustling-s-index&quot;&gt;Rustling&#x27;s Index&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;01-rustlings-variables&#x2F;&quot;&gt;01_rustlings_variables&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;02-rustlings-functions&#x2F;&quot;&gt;02_rustlings_functions&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;03-rustlings-if&#x2F;&quot;&gt;03_rustlings_functions&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;04-rustlings-quiz1&#x2F;&quot;&gt;04_rustlings_quiz1&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;05-rustlings-primitive-types&#x2F;&quot;&gt;05_rustlings_primitive_types&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;06-rustlings-vecs&#x2F;&quot;&gt;06_rustlings_vecs&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;07-rustlings-move-semantics1&#x2F;&quot;&gt;07_rustlings_move_semantics_part_1&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;07-rustlings-move-semantics2&#x2F;&quot;&gt;07_rustlings_move_semantics_part_2&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;08-rustlings-structs&#x2F;&quot;&gt;08_rustlings_structs&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;09-rustlings-enums&#x2F;&quot;&gt;09_rustlings_enums&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;10-rustlings-strings&quot;&gt;10_rustlings_strings&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;11-rustlings-modules&quot;&gt;11_rustlings_modules&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;12-rustlings-hashmaps&quot;&gt;12_rustlings_hashmaps&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;13-rustlings-quiz2&quot;&gt;13_rustlings_quiz2&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;14-rustlings-options&quot;&gt;14_rustlings_options&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;15-rustlings-errors1&#x2F;&quot;&gt;15_rustlings_errors_part_1&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;15-rustlings-errors2&#x2F;&quot;&gt;15_rustlings_errors_part_2&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;16-rustlings-generics&#x2F;&quot;&gt;16_rustlings_generics&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;17-rustlings-traits&quot;&gt;17_rustlings_traits&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;18-rustlings-quiz3&quot;&gt;18_rustlings_quiz3&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;19-rustlings-tests&quot;&gt;19_rustlings_tests&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;20-rustlings-lifetimes&quot;&gt;20_rustlings_lifetimes&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;21-rustlings-iterators&quot;&gt;21_rustlings_iterators&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;22-rustlings-threads&quot;&gt;22_rustlings_threads&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;23-rustlings-smart-pointers&quot;&gt;23_rustlings_smart_pointers&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;24-rustlings-macros&quot;&gt;24_rustlings_macros&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;25-rustlings-clippy&quot;&gt;25_rustlings_clippy&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Inspired by Tris Oaten&#x27;s recent video &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;2hXNd6x9sZs&quot;&gt;How to Learn Rust&lt;&#x2F;a&gt; on his excellent YouTube channel &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;@NoBoilerplate&quot;&gt;No Boilerplate&lt;&#x2F;a&gt;, I&#x27;ve decided to refocus my journey with the Rust programming language. In hopes of effectively learning Rust, I&#x27;ll be following the holy trinity of Rust learning resources as recommended by Tris:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;&quot;&gt;The Rust Programming Language&lt;&#x2F;a&gt; aka &amp;quot;The Book&amp;quot; (read it twice, first quickly)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rustlings&quot;&gt;Rustlings&lt;&#x2F;a&gt; (do it and then continue to practice your favorites)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;&quot;&gt;Rust by Example&lt;&#x2F;a&gt; (supplement where needed)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;While I&#x27;ve been studying Rust for a few months now, I&#x27;ve been mostly focused on &amp;quot;The Book&amp;quot; and doing random tutorials on YouTube, and small personal projects, etc.&lt;&#x2F;p&gt;
&lt;p&gt;Tris&#x27;s video was a timely reminder that Rustlings is a fantastic resource. Although it starts off easy, it gradually becomes more challenging. For some reason, I stopped doing these exercises in the past, but now that I started a blog, I thought it would be a good idea to share my learnings and document my progress as I go.&lt;&#x2F;p&gt;
&lt;p&gt;As I embark on this journey, I&#x27;ll start with the basics, following the structure of The Rust Book and practicing Rustlings exercises as Tris suggests.&lt;&#x2F;p&gt;
&lt;p&gt;By sharing my experiences, I hope to inspire others to explore Rust and motivate myself to stay committed to mastering this powerful language. Stay tuned for updates on my progress and insights into the world of Rust!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Notes on Traits and You: A Deep Dive Part 3</title>
          <pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/traits-301/</link>
          <guid>https://desmodrone.github.io/posts/traits-301/</guid>
          <description xml:base="https://desmodrone.github.io/posts/traits-301/">&lt;h4 id=&quot;original-content-by-nell-shamrell-harrington&quot;&gt;Original content by Nell Shamrell-Harrington&lt;&#x2F;h4&gt;
&lt;p&gt;When looking for resources to help me better understand Rust Traits, I found &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;grU-4u0Okto&quot;&gt;this video&lt;&#x2F;a&gt;from &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;nellshamrell?s=21&amp;amp;t=EhxGdIZ2VJ9HIqIS1LXcpw&quot;&gt;Nell Shamrell-Harrington&lt;&#x2F;a&gt;. It&#x27;s a great intro and overview into using Traits, which can be a little confusing when you first start learning Rust.&lt;&#x2F;p&gt;
&lt;p&gt;So these are my notes on this talk, if you haven&#x27;t watched it and are struggling with learning Traits, I strongly suggest that you watch the video above before you do anything else. But if you&#x27;re short on time and just want to reference my notes -- here they are. Disclaimer: these notes are my own interpretation of the talk and may not necessarily reflect the views of the original speaker. These note are primarily for me to learn these concepts, and I publish them for others to see and maybe benefit from. Feel free to let me know if I have errors or have misrepresentations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;The talk covers 3 different ways that we can use Traits, I have already published the first two parts of these notes, you can see those linked below. So today we&#x27;ll cover the final note with Trait Objects.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-101&#x2F;&quot;&gt;Traits 101 Introduction&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-201&#x2F;&quot;&gt;Traits 201 Trait Bounds&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Traits 301 Trait Objects&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Nell brilliantly uses D&amp;amp;D as a metaphor to help explain Traits. It should be clear that the use of D&amp;amp;D is just to help grasp some concepts, and the D&amp;amp;D rules do not strictly apply in these concepts, so now that we have that out of the way let&#x27;s begin.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits-301-trait-objects&quot;&gt;Traits 301: Trait Objects&lt;&#x2F;h2&gt;
&lt;p&gt;This is where the magic really starts to happen and it might take a little to wrap your head around this concept but let&#x27;s take a look at how traditional object oriented programming languages hand this.&lt;&#x2F;p&gt;
&lt;p&gt;In traditional Object Oriented Programming we have Data &amp;amp; Behavior in one &amp;quot;place&amp;quot;. With Rust we can say that we use &lt;code&gt;enums&lt;&#x2F;code&gt; and &lt;code&gt;structs&lt;&#x2F;code&gt; for data, and &lt;code&gt;traits&lt;&#x2F;code&gt; for behavior, this actually gives us more flexibility and control&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Object Oriented Programming = (data and behaviour together)&lt;&#x2F;li&gt;
&lt;li&gt;Rust = enums&#x2F;structs (data), traits (behavior)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This is actually one of the powers that Rust has as we can mix and match behaviours as we need it in our code.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note:
Trait Objects allow us to work with types that implement a specific trait without knowing their exact type. They enable a more dynamic approach similar to traditional object-oriented programming languages but maintain Rust&#x27;s separation of data and behavior.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;So how does a Trait Object store it&#x27;s data? Well, a Trait Object contains the data in a trait pointer to a value on the heap.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Trait Object: Pointer(Data) -&amp;gt; Value(Heap)&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;
The advantage of doing this is that even if the size of the value on the heap varies, the size of the pointer will always be the same and it&#x27;s more predictable as well.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Trait Object: Trait(Behavior)&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;
Although the Data is located on the heap, one thing to note is you cannot add data to a trait object, this is key to understanding trait objects and how to use them. We point to the data at one specific point in time.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;back-to-d-d&quot;&gt;Back to D&amp;amp;D&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s go back our D&amp;amp;D analogy and this time we&#x27;ll look at different spells that can be cast in the game. Let&#x27;s say we have a wizard that needs to cast a bunch of different spells.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Cantrip&lt;&#x2F;li&gt;
&lt;li&gt;Transmutation&lt;&#x2F;li&gt;
&lt;li&gt;Enchantment&lt;&#x2F;li&gt;
&lt;li&gt;Necromancy&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Let&#x27;s start by creating these spells as structs&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; let&amp;#x27;s create these structs
struct Cantrip {

}

struct Enchantment {

}

struct Transmutation {

}

struct Necromancy {

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Although these are 4 different kinds of spells, the thing that they all have in common is that they all need to be cast, even if they specific way that they are cast is different from spell to spell.&lt;&#x2F;p&gt;
&lt;p&gt;So with this information let&#x27;s make a &lt;code&gt;Cast&lt;&#x2F;code&gt; trait&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; let&amp;#x27;s make a trait, for now we won&amp;#x27;t define a default behaviour
pub trait Cast {
	fn cast(&amp;amp;self);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now let&#x27;s implement the &lt;code&gt;Cast&lt;&#x2F;code&gt; trait on one our spells, let&#x27;s use &lt;code&gt;Cantrip&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; now we implement this trait for the Cantrip struct
impl Cast for Cantrip{
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Cantrip spell here
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s do the same for the &lt;code&gt;Transmutation&lt;&#x2F;code&gt; spell&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; we do the same for the transmutation struct
impl Cast for Transmutation
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Transmutation spell here
	}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can do the same for our &lt;code&gt;Enchament&lt;&#x2F;code&gt; and &lt;code&gt;Necromancy&lt;&#x2F;code&gt; spells, so each of the spells can now be cast, although each spell is defined differently, below is the full list of spells with &lt;code&gt;Cast&lt;&#x2F;code&gt; implemented on them.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; now we implement this trait for the Cantrip struct
impl Cast for Cantrip{
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Cantrip spell here
	}
}

&amp;#x2F;&amp;#x2F; we do the same for the transmutation struct
impl Cast for Transmutation
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Transmutation spell here
	}


&amp;#x2F;&amp;#x2F; we do the same for the Enchantment struct
impl Cast for Enchantment
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Enchantment spell here
	}

&amp;#x2F;&amp;#x2F; we do the same for the Necromancy struct
impl Cast for Necromancy
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Necromancy spell here
	}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Cool, we&#x27;re building up a little library of spells, so how do we organize these spells, where do we keep them? In a spell book of course! We&#x27;ll represent our spell book as a struct&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct Spellbook {
	pub spells: Vec&amp;lt;Box&amp;gt;&amp;lt;Cast&amp;gt;&amp;gt;, &amp;#x2F;&amp;#x2F; here is where we define the spell field
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s break this line of code a little bit. As you can see we define &lt;code&gt;spells&lt;&#x2F;code&gt; as a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;, (we don&#x27;t go into generics in this blog but that&#x27;s what the T represent, a generic type), a Vector that contains an object of a type, the Type that we are grouping in our vector for spells is a &lt;code&gt;&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt;. A &lt;code&gt;Box&lt;&#x2F;code&gt; in Rust is a pointer to a value on the heap (remember we talked about that earlier?).
The reason we choose to use &lt;code&gt;Box&lt;&#x2F;code&gt; in &lt;code&gt;Vec&amp;lt;Box&amp;gt;&amp;lt;&amp;lt;Cast&amp;gt;&amp;gt;&lt;&#x2F;code&gt; is because it allows us to store the trait object in a dynamically sized container, such as a vector, since trait objects have an unknown size at compile time.&lt;&#x2F;p&gt;
&lt;p&gt;With a &lt;code&gt;Vec&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; we can only point to a value of a certain type (T) as we see here, in our case we say that we can contain any type that implements the &lt;code&gt;Cast&lt;&#x2F;code&gt; trait: &lt;code&gt;Vec&amp;lt;Box&amp;lt;Cast&amp;gt;&amp;gt;&lt;&#x2F;code&gt; so &lt;code&gt;Box&lt;&#x2F;code&gt; must point to a value that implements the &lt;code&gt;Cast&lt;&#x2F;code&gt; trait. It doesn&#x27;t matter what type as long as it implements that particular trait.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s review: The &lt;code&gt;pub spells&lt;&#x2F;code&gt; field is a vector &lt;code&gt;Vec&lt;&#x2F;code&gt;, that vector contains &lt;code&gt;Boxes&lt;&#x2F;code&gt; and those boxes point to values that implement the &lt;code&gt;Cast&lt;&#x2F;code&gt; trait represented as: &lt;code&gt;pub spells: Vec&amp;lt;Box&amp;gt;&amp;lt;Cast&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;What this means is that our Wizard can now cast ALL of these spells, one right after the other and we can do this in Rust by defining the behavior in our &lt;code&gt;Spellbook&lt;&#x2F;code&gt; struct.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl Spellbook {
	pub fn run(&amp;amp;self) { &amp;#x2F;&amp;#x2F; implementing a function called run
		for spell in self.spells.iter(){ &amp;#x2F;&amp;#x2F; this will iterate through the spells
			spell.cast(); &amp;#x2F;&amp;#x2F; and casting spells one after the other
		}
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a function that &amp;quot;runs&amp;quot; the spells essentially iterating through them and casting them one after the other.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s see a visual representation of our Wizard in action.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;wizard.png&quot; alt=&quot;wizard&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Now let&#x27;s look at how this code would look like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let spell_book = Spellbook {
	spells: vec![
	&amp;#x2F;&amp;#x2F; different types of spells, each implement the `cast`trait
		Box::new(Cantrip{}),
		Box::new(Transmutation{}),
		Box::new(Enchantment{}),
		Box::new(Necromancy{}),
	],
};
spell_book.run(); &amp;#x2F;&amp;#x2F; this casts each spell, in which ever way they need to be cast
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What this highlights is that Trait Object are great for heterogeneous collections or diverse and mixed collections. Where we can have objects of different types stored in the same place &lt;em&gt;It doesn&#x27;t matter what type something is&lt;&#x2F;em&gt; as long as it &lt;em&gt;implements a certain trait&lt;&#x2F;em&gt;, this gives us a ton of flexibility when using Rust.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;recap&quot;&gt;Recap&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we explored Rust Traits, focusing on Trait Objects. By diving into a D&amp;amp;D-themed example, we demonstrated the power and flexibility of Traits in Rust. Here are the key takeaways:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Rust separates data (enums&#x2F;structs) and behavior (traits), which allows for greater flexibility and control compared to traditional object-oriented programming languages.&lt;&#x2F;li&gt;
&lt;li&gt;Trait Objects enable us to work with types that implement a specific trait without knowing their exact type. This approach is similar to traditional object-oriented programming languages but maintains Rust&#x27;s separation of data and behavior.&lt;&#x2F;li&gt;
&lt;li&gt;Trait Objects are particularly useful for heterogeneous collections or diverse and mixed collections. They allow us to store objects of different types in the same place as long as they implement a certain trait.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;Box&lt;&#x2F;code&gt; pointer is utilized for storing trait objects in dynamically sized containers, such as vectors, since trait objects have an unknown size at compile time.&lt;&#x2F;li&gt;
&lt;li&gt;The D&amp;amp;D example illustrated how to create structs, implement traits, and use Trait Objects to organize and execute a collection of diverse spells.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;By understanding and leveraging Rust Traits and Trait Objects, you can harness the flexibility and power of the Rust programming language to build efficient and maintainable code. With practice and review of &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;grU-4u0Okto&quot;&gt;Nell&#x27;s excellent video&lt;&#x2F;a&gt;, you&#x27;ll be mastering Traits in no time.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Notes on Traits and You: A Deep Dive Part 2</title>
          <pubDate>Thu, 23 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/traits-201/</link>
          <guid>https://desmodrone.github.io/posts/traits-201/</guid>
          <description xml:base="https://desmodrone.github.io/posts/traits-201/">&lt;h4 id=&quot;original-content-by-nell-shamrell-harrington&quot;&gt;Original content by Nell Shamrell-Harrington&lt;&#x2F;h4&gt;
&lt;p&gt;When looking for resources to help me better understand Rust Traits, I found &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;grU-4u0Okto&quot;&gt;this video&lt;&#x2F;a&gt;from &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;nellshamrell?s=21&amp;amp;t=EhxGdIZ2VJ9HIqIS1LXcpw&quot;&gt;Nell Shamrell-Harrington&lt;&#x2F;a&gt;. It&#x27;s a great intro and overview into using Traits, which can be a little confusing when you first start learning Rust.&lt;&#x2F;p&gt;
&lt;p&gt;So these are my notes on this talk, if you haven&#x27;t watched it and are struggling with learning Traits, I strongly suggest that you watch the video above before you do anything else. But if you&#x27;re short on time and just want to reference my notes -- here they are. Disclaimer: these notes are my own interpretation of the talk and may not necessarily reflect the views of the original speaker. These note are primarily for me to learn these concepts, and I publish them for others to see and maybe benefit from. Feel free to let me know if I have errors or have misrepresentations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;The talk covers 3 different ways that we can use Traits, I have already written my first part of these notes, you can see those linked below.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-101&#x2F;&quot;&gt;Traits 101 Introduction&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Traits 201 Trait Bounds&lt;&#x2F;li&gt;
&lt;li&gt;Traits 301 Trait Objects&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Nell brilliantly uses D&amp;amp;D as a metaphor to help explain Traits. It should be clear that the use of D&amp;amp;D is just to help grasp some concepts, and the D&amp;amp;D rules do not strictly apply in these concepts, so now that we have that out of the way let&#x27;s begin.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits-201-trait-bounds&quot;&gt;Traits 201: Trait Bounds&lt;&#x2F;h2&gt;
&lt;p&gt;Today we cover Traits Bounds. In my previous notes we used 4 different races to explain how traits can be used with those races.
Now, we&#x27;re going to add a 5th race: the &lt;em&gt;Half-Elf&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s our full list:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Dwarves&lt;&#x2F;li&gt;
&lt;li&gt;Elf&lt;&#x2F;li&gt;
&lt;li&gt;HalfOrc&lt;&#x2F;li&gt;
&lt;li&gt;Human&lt;&#x2F;li&gt;
&lt;li&gt;Half-Elf&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;traits-101&quot;&gt;Traits 101&lt;&#x2F;h2&gt;
&lt;p&gt;In our &lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-101&#x2F;&quot;&gt;previous note&lt;&#x2F;a&gt; we went through the process of how to define a Trait, we used &lt;code&gt;Constitution&lt;&#x2F;code&gt; as the trait we wanted to apply to the 4 different races in a couple of different ways. If you haven&#x27;t read that note, it might help to do so first to help better understand the basics of creating our characters, creating a Trait, defining race specific values as well as default values.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;trait-bounds&quot;&gt;Trait Bounds&lt;&#x2F;h2&gt;
&lt;p&gt;To help us understand Trait bounds, let&#x27;s look at how these races communicate. Each race has core languages that they speak, for example.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Dwarves: Common, Dwarvish&lt;&#x2F;li&gt;
&lt;li&gt;Elf: Common, Elvish&lt;&#x2F;li&gt;
&lt;li&gt;Half-Elf: Common, Elvish&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;defining-the-elvish-language-trait&quot;&gt;Defining the  &lt;code&gt;Elvish&lt;&#x2F;code&gt; language Trait&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s focus on the Elvish language first and define a trait for the language and define a &lt;code&gt;impl&lt;&#x2F;code&gt; for the &lt;code&gt;Elf&lt;&#x2F;code&gt; and &lt;code&gt;HalfElf&lt;&#x2F;code&gt; races.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Define the Elvish trait
pub trait Elvish {

}

&amp;#x2F;&amp;#x2F; Implement the Elvish trait for the Elf struct
impl Elvish for Elf {

}

&amp;#x2F;&amp;#x2F; Implement the Elvish trait for the HalfElf struct
impl Elvish for HalfElf {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This should be pretty straight-forward so far as it&#x27;s just like we started Traits 101.&lt;&#x2F;p&gt;
&lt;p&gt;Now let&#x27;s make a function to allow our characters to actually speak &lt;code&gt;Elvish&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn speak_elvish(character: T) -&amp;gt; String{
	String::from(&amp;quot;yes&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Right now this function can be called on anything with no arguments, so we add an argument called character, but this character doesn&#x27;t need to be a specific type it can be any of the structs we&#x27;ve already created.&lt;&#x2F;p&gt;
&lt;p&gt;But if we add the &lt;code&gt;&amp;lt;T: Elvish&amp;gt;&lt;&#x2F;code&gt; this means we will only accept the &lt;code&gt;Elvish&lt;&#x2F;code&gt; trait.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn speak_elvish&amp;lt;T: Elvish&amp;gt;(character: T) -&amp;gt; String {
	String::from(&amp;quot;yes&amp;quot;)
}

let my_elf = Elf { name: String::from(&amp;quot;ElleElf&amp;quot;)};

&amp;#x2F;&amp;#x2F; we use our previously defined variable with the `speak_elvish` function
speak_elvish(my_elf)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So now if we call our &lt;code&gt;Elf&lt;&#x2F;code&gt; (&lt;code&gt;my_elf&lt;&#x2F;code&gt;) with &lt;code&gt;speak_elvish(my_elf)&lt;&#x2F;code&gt; it would return a &lt;code&gt;yes&lt;&#x2F;code&gt; because we have implemented &lt;code&gt;Elvish&lt;&#x2F;code&gt; for &lt;code&gt;Elf&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look at our &lt;code&gt;HalfElf&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; This is the same function that we defined before
pub fn speak_elvish&amp;lt;T: Elvish&amp;gt;(character: T) -&amp;gt; String {
	String::from(&amp;quot;yes&amp;quot;)
}
&amp;#x2F;&amp;#x2F; here we bind our HalfElf to `my_half_elf`
let my_half_elf = HalfElf { name: String::from(&amp;quot;HarryHalfElf&amp;quot;)};

speak_elvish(my_half_elf) &amp;#x2F;&amp;#x2F; again this returns &amp;#x27;yes&amp;#x27; since we&amp;#x27;ve implemented `Elvish` for `HalfElf`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So far so good right, I hope it&#x27;s pretty easy to see why both the &lt;code&gt;my_elf&lt;&#x2F;code&gt; and &lt;code&gt;my_half_elf&lt;&#x2F;code&gt; both return &lt;code&gt;yes&lt;&#x2F;code&gt; when we call them using the &lt;code&gt;speak_elvish&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;halforcs-incoming&quot;&gt;HalfOrcs Incoming&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;ve successfully implemented our &lt;code&gt;speak_elvish&lt;&#x2F;code&gt; trait on both our &lt;code&gt;Elf&lt;&#x2F;code&gt; type races, but let&#x27;s see what happens when we try to call our HalfOrc.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn speak_elvish&amp;lt;T: Elvish&amp;gt;(character: T) -&amp;gt; String {
	String::from(&amp;quot;yes&amp;quot;)
}

let my_half_orc = HalfOrc { name: String::from(&amp;quot;OscarOrc&amp;quot;)};

speak_elvish(my_half_orc)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So what happens if wet try to call &lt;code&gt;my_half_orc&lt;&#x2F;code&gt; with &lt;code&gt;speaks_elvish&lt;&#x2F;code&gt;? Well in this case our code would not compile because we have not implemented &lt;code&gt;Evlish&lt;&#x2F;code&gt; for &lt;code&gt;HalfOrc&lt;&#x2F;code&gt;. Of course, Orcs tend to break everything ðŸ˜‰.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;recap&quot;&gt;Recap&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Trait bounds&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt; allow a function to &lt;em&gt;&lt;strong&gt;only&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt; accept types that implement a certain trait or combination of traits. This provides a powerful way to enforce specific behaviors and characteristics for the types used in your functions. Furthermore, you can combine multiple traits as criteria for a function, allowing for even greater flexibility and control.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s walk through each step like we did in Traits 101 on how we define Trait bounds:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Define our Trait in our case it was the language trait &lt;code&gt;Elvish&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Implement &lt;code&gt;Elvish&lt;&#x2F;code&gt; for the races that speak it, in our case &lt;code&gt;Elf&lt;&#x2F;code&gt; and &lt;code&gt;HelfElf&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Define a function &lt;code&gt;speak_elvish&lt;&#x2F;code&gt; that only accepts the race we define within  the function. In our case we did it for both &lt;code&gt;Elf&lt;&#x2F;code&gt; and &lt;code&gt;HalfElf&lt;&#x2F;code&gt;. This function returns a &lt;code&gt;yes&lt;&#x2F;code&gt; if we call a race that has &lt;code&gt;Elvish&lt;&#x2F;code&gt; implemented, for example: &lt;code&gt;speak_elvish(my_half_elf) &lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;If we try to do the same with our &lt;code&gt;HalfOrc&lt;&#x2F;code&gt;: &lt;code&gt;speak_elvish(my_half_orc)&lt;&#x2F;code&gt;, our code won&#x27;t compile.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This was a short and straightforward introduction to Trait Bounds, and we&#x27;ll dive deeper into Rust Traits in the upcoming post on Traits 301: Trait Objects, where the real magic happens&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Notes on Traits and You: A Deep Dive Part 1</title>
          <pubDate>Tue, 14 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/traits-101/</link>
          <guid>https://desmodrone.github.io/posts/traits-101/</guid>
          <description xml:base="https://desmodrone.github.io/posts/traits-101/">&lt;h4 id=&quot;original-content-by-nell-shamrell-harrington&quot;&gt;Original content by Nell Shamrell-Harrington&lt;&#x2F;h4&gt;
&lt;p&gt;When looking for resources to help me better understand Rust Traits, I found &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;grU-4u0Okto&quot;&gt;this video&lt;&#x2F;a&gt;from &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;nellshamrell?s=21&amp;amp;t=EhxGdIZ2VJ9HIqIS1LXcpw&quot;&gt;Nell Shamrell-Harrington&lt;&#x2F;a&gt;. It&#x27;s a great intro and overview into using Traits, which can be a little confusing when you first start learning Rust.&lt;&#x2F;p&gt;
&lt;p&gt;So these are my notes on this talk, if you haven&#x27;t watched it and are struggling with learning Traits, I strongly suggest that you watch the video above before you do anything else. But if you&#x27;re short on time and just want to reference my notes -- here they are. Disclaimer: these notes are my own interpretation of the talk and may not necessarily reflect the views of the original speaker. These note are primarily for me to learn these concepts, and I publish them for others to see and maybe benefit from. Feel free to let me know if I have errors or have misrepresentations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;The talk covers 3 different ways that we can use Traits&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Traits 101 Introduction&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-201&#x2F;&quot;&gt;Traits 201 Trait Bounds&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Traits 301 Trait Objects&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Nell brilliantly uses D&amp;amp;D as a metaphor to help explain Traits. It should be clear that the use of D&amp;amp;D is just to help grasp some concepts, and the D&amp;amp;D rules do not strictly apply in these concepts, so now that we have that out of the way let&#x27;s begin.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits-101&quot;&gt;Traits: 101&lt;&#x2F;h2&gt;
&lt;p&gt;On this post we will cover Traits 101, this will keep each post shorter and easier to digest.&lt;&#x2F;p&gt;
&lt;p&gt;In D&amp;amp;D there are many different races, but we&#x27;ll start by using these 4 different races:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Dwarves&lt;&#x2F;li&gt;
&lt;li&gt;Elf&lt;&#x2F;li&gt;
&lt;li&gt;HalfOrc&lt;&#x2F;li&gt;
&lt;li&gt;Human&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;creating-our-structs&quot;&gt;Creating our Structs&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s create these races as structs in Rust&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct Dwarf {
	name:String
}

struct Elf {
	name:String
}

struct HalfOrc {
	name:String
}

struct Human {
	name:String
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see this is pretty straight forward code where we define the struct name (&lt;code&gt;Dwarf&lt;&#x2F;code&gt;, &lt;code&gt;Elf&lt;&#x2F;code&gt; etc.) and then add the &lt;code&gt;name:String&lt;&#x2F;code&gt; to allow our characters to be named.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-our-dwarf&quot;&gt;Creating our Dwarf&lt;&#x2F;h2&gt;
&lt;p&gt;First, let&#x27;s create a Dwarf character.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_dwarf = Dwarf {
	name: String::from(&amp;quot;DanDwarf&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A variable &lt;code&gt;my_dwarf&lt;&#x2F;code&gt; that stores our &lt;code&gt;Dwarf&lt;&#x2F;code&gt; type and we name him &lt;code&gt;DanDwarf&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;d-d-core-traits&quot;&gt;D&amp;amp;D Core Traits&lt;&#x2F;h2&gt;
&lt;p&gt;In D&amp;amp;D each character has core traits:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Strength&lt;&#x2F;li&gt;
&lt;li&gt;Dexterity&lt;&#x2F;li&gt;
&lt;li&gt;Constitution&lt;&#x2F;li&gt;
&lt;li&gt;Intelligence&lt;&#x2F;li&gt;
&lt;li&gt;Wisdom&lt;&#x2F;li&gt;
&lt;li&gt;Charisma&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;If you are not familiar in D&amp;amp;D, character&#x27;s core traits are defined in numbers, so an example would be that a character could have a Strength of: 8, a Dexterity of: 4, and a Constitution of 2, etc. as a base and depending on equipment or spells cast these traits could be boosted (or lowered).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;defining-a-trait&quot;&gt;Defining a Trait&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s first define a &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait that we can use on our soon to be defined Characters&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Let&amp;#x27;s make a constitution trait
&amp;#x2F;&amp;#x2F; where we define one function `constitution_bonus`
pub triat Constitution {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;implementing-constitution-for-dwarf&quot;&gt;Implementing &lt;code&gt;Constitution&lt;&#x2F;code&gt; for &lt;code&gt;Dwarf&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;So let&#x27;s take one of these traits, in our case Constitution and define it in Rust for our Dwarf.  We&#x27;ll say that Dwarves have a Constitution bonus of 2.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F;implemeting the trait
impl Constitution for Dwarf {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	2 &amp;#x2F;&amp;#x2F; this returns 2, anytime the instance of a dwarf is called.
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now that we&#x27;ve defined our trait we go back to our Dwarf, using our just defined  &lt;code&gt;constitution_bounus&lt;&#x2F;code&gt; that we can call on &lt;code&gt;my_dwarf&lt;&#x2F;code&gt; as shown below.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; back to making the character
let my_dwarf = Dwarf {
	name: String::from(&amp;quot;DanDwarf&amp;quot;)
};

my_dwarf.constitution_bonus(); &amp;#x2F;&amp;#x2F; Returns 2
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this way no matter how many Dwarves we create, every single one of them will have the &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; of &lt;code&gt;2&lt;&#x2F;code&gt; attached.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-a-halforc&quot;&gt;Creating a HalfOrc&lt;&#x2F;h2&gt;
&lt;p&gt;Now, let&#x27;s create a &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; and we&#x27;ll start by implementing the &lt;code&gt;constituion_bonus&lt;&#x2F;code&gt;, the Constitution bonus for a HalfOrc is &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl Constitution for HalfOrc {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	1
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the same as our Dwarf &lt;code&gt;impl&lt;&#x2F;code&gt; but instead returning a 2, it returns 1&lt;&#x2F;p&gt;
&lt;p&gt;Now we create the HalfOrc with:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_half_orc = HalfOrc {
	name: String::from(&amp;quot;OscarOrc&amp;quot;)
}

my_half_orc.constitution_bonus();&amp;#x2F;&amp;#x2F; Returns 1
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Pretty straightforward right? We bind &lt;code&gt;my_half_orc&lt;&#x2F;code&gt; to our &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; and name him &lt;code&gt;OscarOrc&lt;&#x2F;code&gt; and when we call the &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; and we know that it will return &lt;code&gt;1&lt;&#x2F;code&gt;, as we have defined in the &lt;code&gt;impl&lt;&#x2F;code&gt; block above.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;humans-and-elves&quot;&gt;Humans and Elves&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s define our last 2 races of Humans and Elves, but let&#x27;s say that both of these races have a constitution bonus of &lt;code&gt;0&lt;&#x2F;code&gt;.
Our first instinct might be to do the same as we did above and do this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; we can implement like this but this is repetitive
impl Constitution for Elf {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	0
	}
}

impl Constitution for Human {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	0
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is clearly repetitive and not ideal. Another thing to note is that most races actually have a constitution bonus of &lt;code&gt;0&lt;&#x2F;code&gt;
So how do we deal with this?&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s add a default value the &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait we first created.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; making `0` the default
pub triat Constitution {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	0
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this way unless we have a struct that implements this trait and overrides this default value it will always return &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We still have to implement the traits on the struct, but we don&#x27;t have to define how the constitution bonus works since it&#x27;s default value is &lt;code&gt;0&lt;&#x2F;code&gt; and Humans and Elves&#x27; &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; matches the default value.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
impl Constitution for Elf{
}

impl Constitution for Human{
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;creating-our-elf-and-human&quot;&gt;Creating our Elf and Human&lt;&#x2F;h2&gt;
&lt;p&gt;We know the drill here, we define both of these in the same way that we did for our &lt;code&gt;my_dwarf&lt;&#x2F;code&gt; and &lt;code&gt;my_half_orc&lt;&#x2F;code&gt;, the only difference is that since we have defined a default value on the &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait we have access to it automatically unless we further define the &lt;code&gt;consitution_bonus&lt;&#x2F;code&gt; like we did previously.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_elf = Elf{
	name:String::from(&amp;quot;ElleElf&amp;quot;)
};

my_elf.constituion_bonus(); &amp;#x2F;&amp;#x2F; Retuns 0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_human = Human {
	name:String::from(&amp;quot;HarryHuman&amp;quot;)
};

my_human.constitution_bonus(); &amp;#x2F;&amp;#x2F; Returns 0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There it is, we have created 4 D&amp;amp;D characters and defined their &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; in a couple of different ways using Triats.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s summarize what we did here, in a quick step-by-step so we can see how easy it actually is to use traits in this way.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Create a &lt;code&gt;struct&lt;&#x2F;code&gt; for each of the races.&lt;&#x2F;li&gt;
&lt;li&gt;Create a character with a variable &lt;code&gt;my_&amp;lt;race&amp;gt;&lt;&#x2F;code&gt;  and defined it&#x27;s type and name.&lt;&#x2F;li&gt;
&lt;li&gt;Create a &lt;code&gt;trait&lt;&#x2F;code&gt;, in our case &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Implement the &lt;code&gt;triat&lt;&#x2F;code&gt; on the &lt;code&gt;Dwarf&lt;&#x2F;code&gt; struct
&lt;ul&gt;
&lt;li&gt;define constitution bonus as &lt;code&gt;2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;calling &lt;code&gt;constitution_bonus()&lt;&#x2F;code&gt; on our character it returns &lt;code&gt;2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;if we create more &lt;code&gt;Dwarf&lt;&#x2F;code&gt; characters they&#x27;d all have a constitution bonus of &lt;code&gt;2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Implement the &lt;code&gt;trait&lt;&#x2F;code&gt; on the &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; struct
&lt;ul&gt;
&lt;li&gt;define constitution bonus as &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;calling &lt;code&gt;constitution_bonus()&lt;&#x2F;code&gt; on our character returns &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;if we create more &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; characters they&#x27;d all have a constitution bonus of &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Add a default value to our &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait&lt;&#x2F;li&gt;
&lt;li&gt;Implement the &lt;code&gt;trait&lt;&#x2F;code&gt; on &lt;code&gt;Elves&lt;&#x2F;code&gt; and &lt;code&gt;Humans&lt;&#x2F;code&gt;(with no additional definition)&lt;&#x2F;li&gt;
&lt;li&gt;Created our &lt;code&gt;Elves&lt;&#x2F;code&gt; and &lt;code&gt;Humans&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;calling &lt;code&gt;constitution_bonus()&lt;&#x2F;code&gt; on our elf and human characters returns &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;creating other races with no function definition in their implementation will always return &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Alright, as you can see there&#x27;s not a lot of tricky parts here, it&#x27;s all pretty straight forward, especially when laid out in this way where we can see how easy it is, in a few easy steps start using Traits in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Next we&#x27;ll dive into Traits 201, it will build on what we&#x27;ve learned here with Trait bounds. See you next time.&lt;&#x2F;p&gt;
&lt;p&gt;Update 2023-03-14:If you&#x27;re ready for &lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-201&#x2F;&quot;&gt;Part 2&lt;&#x2F;a&gt;, it&#x27;s ready for you.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Rust Closures</title>
          <pubDate>Wed, 08 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/rust-closures/</link>
          <guid>https://desmodrone.github.io/posts/rust-closures/</guid>
          <description xml:base="https://desmodrone.github.io/posts/rust-closures/">&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;&#x2F;h2&gt;
&lt;p&gt;I&#x27;m new to Rust and programming in general, and while I&#x27;ve dabbled in different languages and technologies, I&#x27;ve never gone headfirst into any language to become proficient. I&#x27;m trying to change that now with Rust. Please forgive my inaccuracies or lack of understanding of more complex topics, but I&#x27;ll get there eventually. For now, I thought closures were an interesting topic, so I decided to write about this this topic first.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-are-closures&quot;&gt;What are closures?&lt;&#x2F;h2&gt;
&lt;p&gt;A closure can be thought of as a quick function that doesn&#x27;t need a name, or an anonymous function that can be saved in a variable or passed into other functions as arguments. A unique thing about closures is that they can capture their environment and this makes them a versatile tool that can be fun and efficient to use.&lt;&#x2F;p&gt;
&lt;p&gt;Closures are easy to identify because they use pipes &lt;code&gt;||&lt;&#x2F;code&gt; instead of the typical parentheses &lt;code&gt;()&lt;&#x2F;code&gt; that functions use. There are a few different ways you can use closures in Rust, but first, let&#x27;s look at how a closure is created.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;how-are-closures-created-in-rust&quot;&gt;How are closures created in Rust?&lt;&#x2F;h2&gt;
&lt;p&gt;Before we look at closures let us take a quick look at the syntax of how a function is defined in Rust. Below is a simple function definition that adds 1 to its parameter.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; function definition syntax
fn plus_one_v1 (x: u32) -&amp;gt; u32 { x + 1 }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you&#x27;re familiar with Rust&#x27;s functions this should be pretty easy to understand, so we won&#x27;t go through the details, if you&#x27;re not familiar with creating a function in Rust here&#x27;s a &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;2V0JaMVjzws?t=465&quot;&gt;Let&#x27;s Get Rusty&lt;&#x2F;a&gt; tutorial on functions that will bring you up to speed.  Now let&#x27;s look at how we&#x27;d create a closure using similar syntax to a function. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F;closure definition syntax
let plus_one_v2 = | x: u32| -&amp;gt; u32 { x + 1 };
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see the syntax is very similar to a function other than we use the &lt;code&gt;let&lt;&#x2F;code&gt;  keyword to bind the closure to &lt;code&gt;plus_one_v2&lt;&#x2F;code&gt; , and use the equal sign before the pipes &lt;code&gt;||&lt;&#x2F;code&gt;.  One thing to note is that a lot of this syntax is optional for closure definitions, the Rust compiler is usually able to infer the types in closures. Keep in mind that when the Rust compiler infers the type, it will take the first type we pass through as the type it uses. So you can&#x27;t change the type later in your code and expect it to work. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;simplifying-syntax&quot;&gt;Simplifying Syntax&lt;&#x2F;h2&gt;
&lt;p&gt;Since the Rust compiler can infer the types, to declare this closure in the most succinct manner you could do so like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; closure definition stripped down
let plus_one_v2 = |x| x + 1;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s go step by step and see what we removed.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; closure syntax defined
let plus_one_v2 = | x: u32| -&amp;gt; u32 { x + 1 };

&amp;#x2F;&amp;#x2F; removing the return type and curly braces
let plus_one_v2 = | x: u32| -&amp;gt; x + 1;

&amp;#x2F;&amp;#x2F; removing the u32 type in closure
let plus_one_v2 = |x| x + 1;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again because the rust compiler can infer the type we can make this line of code much cleaner.&lt;&#x2F;p&gt;
&lt;p&gt;Just like in functions where the parentheses &lt;code&gt;()&lt;&#x2F;code&gt;  can be empty, we can leave the &lt;code&gt;||&lt;&#x2F;code&gt; empty or add variables and types.  Let&#x27;s look at another example.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; empty `||`
fn main() {
	let simple_closure = || println!(&amp;quot;A simple closure&amp;quot;);
	simple_closure();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we define a closure to the variable &lt;code&gt;simple_closure&lt;&#x2F;code&gt; and this has nothing in between &lt;code&gt;||&lt;&#x2F;code&gt;.  If we run this code it prints: &lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;A simple closure.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;passing-in-parameters&quot;&gt;Passing in Parameters&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at what happens when we add something in between the pipes &lt;code&gt;||&lt;&#x2F;code&gt; similar to how we would to the parenthesis &lt;code&gt;()&lt;&#x2F;code&gt; of a function. We define &lt;code&gt;x&lt;&#x2F;code&gt; as and &lt;code&gt;i32&lt;&#x2F;code&gt; which means that when we call &lt;code&gt;simple_closure&lt;&#x2F;code&gt; we can pass in an &lt;code&gt;i32&lt;&#x2F;code&gt; into it.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; pipes with an i32
fn main() {
	let simple_closure = |x: i32| println!(&amp;quot;{}&amp;quot;, x);

	simple_closure(3);
	simple_closure(3+16);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;3
19
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So far so good, I hope. This behavior here is just like a function, we&#x27;re not doing anything too different. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;capturing-the-environment&quot;&gt;Capturing the Environment&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at what makes closures special, &amp;quot;capture their environment&amp;quot;, meaning they can take variables that are outside of the closure.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Capturing the environment
fn main() {
	let first = 12
	let second = 3

	let capture_closure = || println!(&amp;quot;{}&amp;quot;, first + second);
	capture_closure();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;15
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So what is going on here? We didn&#x27;t put anything in between the &lt;code&gt;||&lt;&#x2F;code&gt; but closures can just &#x27;take&#x27; the variables &lt;code&gt;first&lt;&#x2F;code&gt; and &lt;code&gt;second&lt;&#x2F;code&gt; and add them because closures can capture their environment -- pretty cool huh?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-3-closure-traits-fn-fnmut-and-fnonce&quot;&gt;The 3 closure traits (Fn, FnMut,  and FnOnce)&lt;&#x2F;h2&gt;
&lt;p&gt;Now, let&#x27;s dive a little deeper and take a look at the &lt;code&gt;Fn&lt;&#x2F;code&gt;, &lt;code&gt;FnMut&lt;&#x2F;code&gt;, and &lt;code&gt;FnOnce&lt;&#x2F;code&gt; traits and how they work with closures. This happens behind the scenes when using closures with variables but in order to understand closures and be able to use them to their full potential we must understand what is happening with these 3 traits.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fn&lt;&#x2F;code&gt;: using this with an upper case &lt;code&gt;F&lt;&#x2F;code&gt; means we are not mutating the captured variables and they are read-only.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;FnMut&lt;&#x2F;code&gt;: allows us to change captured variables, creating a mutable borrow of these captured variables.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;FnOnce&lt;&#x2F;code&gt;: this lets us move ownership into the closure. In essence, consuming the variable. &lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Again, Rust infers these traits when using closures with variables, different than when they&#x27;re being used with functions where they have to be explicitly defined, but we&#x27;ll look at that later. &lt;&#x2F;p&gt;
&lt;h3 id=&quot;fn-trait&quot;&gt;&lt;code&gt;Fn&lt;&#x2F;code&gt; Trait&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s take a quick look at what each of these looks like in code.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; using `Fn` trait
fn main() {
	let str1 = &amp;quot;Hello&amp;quot;.to_string();
	let closure = |x| println!(&amp;quot;{} {}&amp;quot;, str1, x);
	closure(&amp;quot;rustaceans!&amp;quot;)

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we capturing the variable and printing it with the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait because we are immutably borrowing that variable and printing it to screen. which prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Hello rustaceans!
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can tell we didn&#x27;t actually have to define the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait it was implied by how it the code is constructed. &lt;&#x2F;p&gt;
&lt;h3 id=&quot;fnmut-trait&quot;&gt;&lt;code&gt;FnMut&lt;&#x2F;code&gt; Trait&lt;&#x2F;h3&gt;
&lt;p&gt;Here in the 2nd block of code with &lt;code&gt;clsr2&lt;&#x2F;code&gt; we are declaring a closure that actually mutates the &lt;code&gt;str1&lt;&#x2F;code&gt; variable, so here we are using the &lt;code&gt;FnMut&lt;&#x2F;code&gt; trait because we are mutating our variable. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {
	&amp;#x2F;&amp;#x2F; using Fn trait
	let mut str1 = &amp;quot;Hello&amp;quot;.to_string();
	let closure = |x| println!(&amp;quot;{} {}&amp;quot;, str1, x);
	closure(&amp;quot;rustaceans!&amp;quot;);

	&amp;#x2F;&amp;#x2F; using FnMut trait
	let mut closure2 = |x| str1.push_str(x);
	closure2(&amp;quot; welcome back, rustaceans!&amp;quot;); 
	println!(&amp;quot;{}&amp;quot;, str1);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This now prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Hello rustaceans!
Hello welcome back, rustaceans!
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;fnonce-trait&quot;&gt;&lt;code&gt;FnOnce&lt;&#x2F;code&gt; Trait&lt;&#x2F;h3&gt;
&lt;p&gt;In this last example, we take a look at the &lt;code&gt;FnOnce&lt;&#x2F;code&gt; trait&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {
	&amp;#x2F;&amp;#x2F; using Fn trait
	let mut str1 = &amp;quot;Hello&amp;quot;.to_string();
	let closure = |x| println!(&amp;quot;{} {}&amp;quot;, str1, x);
	closure(&amp;quot;rustaceans!&amp;quot;);

	&amp;#x2F;&amp;#x2F; using FnMut trait
	let mut closure2 = |x| str1.push_str(x);
	closure2(&amp;quot; welcome back, rustaceans!&amp;quot;);
	println!(&amp;quot;{}&amp;quot;, str1);

	&amp;#x2F;&amp;#x2F; using FnOnce trait
	let closure3 = || drop(str1);
    println!(&amp;quot;before dropping str1&amp;quot;);
    closure3();
    println!(&amp;quot;str1 has been dropped&amp;quot;);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see the &lt;code&gt;FnOnce&lt;&#x2F;code&gt; trait in action here when using  &lt;code&gt;drop(str1)&lt;&#x2F;code&gt;.  However, if we try to call &lt;code&gt;str1&lt;&#x2F;code&gt; again, our code would not compile and give us an error message, so we don&#x27;t call it in this instance.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-move-keyword&quot;&gt;&lt;strong&gt;The &lt;code&gt;move&lt;&#x2F;code&gt; keyword&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;move&lt;&#x2F;code&gt; keyword comes in handy when you want to force a closure to take ownership of the values it captures, even though the closure doesn&#x27;t need it. &lt;code&gt;move&lt;&#x2F;code&gt; can specifically come into action when passing a closure into a new thread and thus moving the data so it&#x27;s owned by this new thread. Threads are something we can cover at a different time, but let&#x27;s look at this example on how to use the &lt;code&gt;move&lt;&#x2F;code&gt; keyword with closures:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!(&amp;quot;Before defining closure: {:?}&amp;quot;, list);

    thread::spawn(move || println!(&amp;quot;From thread: {:?}&amp;quot;, list))
        .join()
        .unwrap();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A new thread is spawned and we force the closure to take ownership of the &lt;code&gt;list&lt;&#x2F;code&gt; by using the &lt;code&gt;move&lt;&#x2F;code&gt;  keyword.  In this way even if we implement the &lt;code&gt;Fn&lt;&#x2F;code&gt; or &lt;code&gt;FnMut&lt;&#x2F;code&gt; traits, ownership is moved to the closure allowing more flexibility in the closure. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;passing-closures-or-other-functions-as-inputs-to-functions&quot;&gt;&lt;strong&gt;Passing closures(or other functions) as inputs to functions&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at a couple of different ways we can use closures as inputs to functions, building on what we saw above with the &lt;code&gt;Fn&lt;&#x2F;code&gt;, &lt;code&gt;FnMut&lt;&#x2F;code&gt;. &lt;&#x2F;p&gt;
&lt;p&gt;As mentioned outside of a function, a closure can decide by itself which trait to use, but inside of a function, you have to be explicit and define one of these traits. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; using `Fn`
fn add_num&amp;lt;F&amp;gt;(func: F)
	where F: Fn(i32){
		func(7)
	}

fn main(){
	let num = 6;
	add_num(|x|println!(&amp;quot;{}&amp;quot;, num + x));
	
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;13
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we are defining the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait to add two numbers and since we are not changing the number in the &lt;code&gt;add_num&lt;&#x2F;code&gt;  function and simply passing it through we can define the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait without major fuss. &lt;&#x2F;p&gt;
&lt;p&gt;However, if we try to make our &lt;code&gt;num&lt;&#x2F;code&gt; mutable by incrementing it, we might run into some problems. Let&#x27;s see what happens.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn add_num&amp;lt;F&amp;gt;(func: F)
	where F: Fn(i32){
		func(7)
	}

fn main(){
	let mut num = 6; &amp;#x2F;&amp;#x2F; mutable to allow incrementation
	add_num(|x|{num +=x; println!(&amp;quot;{}&amp;quot;, num + x)}); 
	
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As expected we get an error message:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;error[E0594]: cannot assign to `num`, as it is a captured variable in a `Fn` closure
 --&amp;gt; src&amp;#x2F;main.rs:8:14
  |
1 | fn add_num&amp;lt;F&amp;gt;(func: F)
  |                     - change this to accept `FnMut` instead of `Fn`
...
8 |     add_num(|x|{num +=x; println!(&amp;quot;{}&amp;quot;, num + x)});
  |     ------- --- ^^^^^^^ cannot assign
  |     |       |
  |     |       in this closure
  |     expects `Fn` instead of `FnMut`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler actually tells us what we should be doing here (very nice), changing the &lt;code&gt;Fn&lt;&#x2F;code&gt; to &lt;code&gt;FnMut&lt;&#x2F;code&gt; .&lt;&#x2F;p&gt;
&lt;p&gt;If we update our code to in the &lt;code&gt;add_num&lt;&#x2F;code&gt; function to what is shown below, our problems will be solved:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn add_num&amp;lt;F&amp;gt;(mut func: F) &amp;#x2F;&amp;#x2F; add mut here
	where F: FnMut(i32){ &amp;#x2F;&amp;#x2F; change Fn to FnMut here
		func(7) 
	}

fn main(){
	let mut num = 6;
	add_num(|x|{num +=x; println!(&amp;quot;{}&amp;quot;, num + x)}); 	
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This now compiles and prints:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;20
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Phew, we covered a lot but there&#x27;s still more we can do with closures, like storing them in structs and using them in conjunction with iterators, but we&#x27;ll leave that for another time. For now, I hope I have been able to explain what a closure is, how to create a closure, and how to use its traits. This should help you get started with getting familiar with closures and understanding how to use them in your own code. &lt;&#x2F;p&gt;
&lt;p&gt;Please let me know if I got something wrong or was unclear on anything, I&#x27;m doing this to help me better learn these concepts, so any feedback is appreciated. &lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Hello World</title>
          <pubDate>Tue, 07 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/hello-world/</link>
          <guid>https://desmodrone.github.io/posts/hello-world/</guid>
          <description xml:base="https://desmodrone.github.io/posts/hello-world/">&lt;p&gt;Yes, the obligatory Hello World post...and code.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main(){
    println!(&amp;quot;hello world!&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
      </item>
    </channel>
</rss>
