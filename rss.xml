<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>desmo</title>
      <link>https://desmodrone.github.io</link>
      <description>Random Ideas</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://desmodrone.github.io/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Fri, 28 Jul 2023 00:00:00 +0000</lastBuildDate>
      <item>
          <title>13 Rustlings quiz2</title>
          <pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/13-rustlings-quiz2/</link>
          <guid>https://desmodrone.github.io/posts/13-rustlings-quiz2/</guid>
          <description>&lt;h2 id=&quot;quiz-2&quot;&gt;Quiz 2&lt;&#x2F;h2&gt;
&lt;p&gt;It&#x27;s quiz time again! We&#x27;ve been through a bunch of different exercises and now we&#x27;ll be putting in action what we&#x27;ve learned.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;quiz2-rs&quot;&gt;quiz2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; quiz2.rs
&amp;#x2F;&amp;#x2F; This is a quiz for the following sections:
&amp;#x2F;&amp;#x2F; - Strings
&amp;#x2F;&amp;#x2F; - Vecs
&amp;#x2F;&amp;#x2F; - Move semantics
&amp;#x2F;&amp;#x2F; - Modules
&amp;#x2F;&amp;#x2F; - Enums

&amp;#x2F;&amp;#x2F; Let&amp;#x27;s build a little machine in the form of a function.
&amp;#x2F;&amp;#x2F; As input, we&amp;#x27;re going to give a list of strings and commands. These commands
&amp;#x2F;&amp;#x2F; determine what action is going to be applied to the string. It can either be:
&amp;#x2F;&amp;#x2F; - Uppercase the string
&amp;#x2F;&amp;#x2F; - Trim the string
&amp;#x2F;&amp;#x2F; - Append &amp;quot;bar&amp;quot; to the string a specified amount of times
&amp;#x2F;&amp;#x2F; The exact form of this will be:
&amp;#x2F;&amp;#x2F; - The input is going to be a Vector of a 2-length tuple,
&amp;#x2F;&amp;#x2F;   the first element is the string, the second one is the command.
&amp;#x2F;&amp;#x2F; - The output element is going to be a Vector of strings.
&amp;#x2F;&amp;#x2F; No hints this time!

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub enum Command {
    Uppercase,
    Trim,
    Append(usize),
}

mod my_module {
    use super::Command;

    &amp;#x2F;&amp;#x2F; TODO: Complete the function signature!
    pub fn transformer(input: ???) -&amp;gt; ??? {
        &amp;#x2F;&amp;#x2F; TODO: Complete the output declaration!
        let mut output: ??? = vec![];
        for (string, command) in input.iter() {
            &amp;#x2F;&amp;#x2F; TODO: Complete the function body. You can do it!
        }
        output
    }
}

#[cfg(test)]
mod tests {
    &amp;#x2F;&amp;#x2F; TODO: What do we need to import to have `transformer` in scope?
    use ???;
    use super::Command;

    #[test]
    fn it_works() {
        let output = transformer(vec![
            (&amp;quot;hello&amp;quot;.into(), Command::Uppercase),
            (&amp;quot; all roads lead to rome! &amp;quot;.into(), Command::Trim),
            (&amp;quot;foo&amp;quot;.into(), Command::Append(1)),
            (&amp;quot;bar&amp;quot;.into(), Command::Append(5)),
        ]);
        assert_eq!(output[0], &amp;quot;HELLO&amp;quot;);
        assert_eq!(output[1], &amp;quot;all roads lead to rome!&amp;quot;);
        assert_eq!(output[2], &amp;quot;foobar&amp;quot;);
        assert_eq!(output[3], &amp;quot;barbarbarbarbarbar&amp;quot;);
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have instructions in the comments and four &lt;code&gt;TODOs&lt;&#x2F;code&gt; annotated in the code. Let&#x27;s first take a look at the instructions and make sure we understand what is being asked of us.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;general-instructions&quot;&gt;General Instructions&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;We&#x27;re building a function&lt;&#x2F;li&gt;
&lt;li&gt;We&#x27;re inputing a list of strings and commands into our function&lt;&#x2F;li&gt;
&lt;li&gt;The commands can be
&lt;ol&gt;
&lt;li&gt;Uppercase the string&lt;&#x2F;li&gt;
&lt;li&gt;Trim the string&lt;&#x2F;li&gt;
&lt;li&gt;Append &amp;quot;bar&amp;quot; to the string a specified amount of times&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;details&quot;&gt;Details&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;Input will be a Vector of a 2-length tuple&lt;&#x2F;li&gt;
&lt;li&gt;First element is a string, second one is a command&lt;&#x2F;li&gt;
&lt;li&gt;Output is going to be a Vector of strings.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;quiz2-rs-errors&quot;&gt;quiz2.rs errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;quiz2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected identifier, found `)`
  --&amp;gt; exercises&amp;#x2F;quiz2.rs:33:34
   |
33 |     pub fn transformer(input: ???) -&amp;gt; ??? {
   |                                  ^ expected identifier

error: expected identifier, found `{`
  --&amp;gt; exercises&amp;#x2F;quiz2.rs:33:43
   |
33 |     pub fn transformer(input: ???) -&amp;gt; ??? {
   |                                           ^ expected identifier

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our errors are pretty self explanatory we&#x27;re missing code, so no surprises there.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s take a look at the specific areas that need to be completed.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;todo-in-transformer-function&quot;&gt;Todo in &lt;code&gt;transformer&lt;&#x2F;code&gt; function&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;mod my_module {
    use super::Command;

    &amp;#x2F;&amp;#x2F; TODO: Complete the function signature!
    pub fn transformer(input: ???) -&amp;gt; ??? {
        &amp;#x2F;&amp;#x2F; TODO: Complete the output declaration!
        let mut output: ??? = vec![];
        for (string, command) in input.iter() {
            &amp;#x2F;&amp;#x2F; TODO: Complete the function body. You can do it!
        }
        output
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A quick look at our todo&#x27;s here show us that we have to:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Complete the signature&lt;&#x2F;li&gt;
&lt;li&gt;Complete the &lt;code&gt;output&lt;&#x2F;code&gt; variable declaration&lt;&#x2F;li&gt;
&lt;li&gt;Complete the function body.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;test-todo&quot;&gt;Test Todo&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[cfg(test)]
mod tests {
    &amp;#x2F;&amp;#x2F; TODO: What do we need to import to have `transformer` in scope?
    use ???;
    use super::Command;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Our fourth todo is to make sure we have &lt;code&gt;transformer&lt;&#x2F;code&gt; in scope.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;quiz2-rs-solution&quot;&gt;quiz2.rs solution&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;completing-the-function-signature&quot;&gt;Completing the Function Signature&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s go through these in order, let&#x27;s look at the function signature, and our instructions which tell us that:  &lt;em&gt;input will be a Vector of a 2-length tuple&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    pub fn transformer(input: ???) -&amp;gt; ??? {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So a vector is declared as &lt;code&gt;Vec&amp;lt;&amp;gt;&lt;&#x2F;code&gt; but in this particular case we need a tuple stored inside of the vector which would make it look something like this &lt;code&gt;Vec&amp;lt;(,)&amp;gt;&lt;&#x2F;code&gt; when empty, but we know that we need to pass in 2 items as we&#x27;re told in our instructions: &lt;em&gt;first element is a string, second one is a command&lt;&#x2F;em&gt;
so to complete it, it should look something like this: &lt;code&gt;Vec&amp;lt;(String, command)&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now, let&#x27;s look at the return value which we were told is: &lt;em&gt;output is going to be a Vector of strings&lt;&#x2F;em&gt;  with that we can complete our function signature to look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    pub fn transformer(input: Vec&amp;lt;(String, Command)&amp;gt;) -&amp;gt; Vec&amp;lt;String&amp;gt; {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This should complete our function signature for &lt;code&gt;transformer&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;completing-the-output-declaration&quot;&gt;Completing the &lt;code&gt;output&lt;&#x2F;code&gt; declaration&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;        let mut output: ??? = vec![]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we have an incomplete variable declaration, we need to provide the type to complete it. If we reference our notes, we&#x27;ve been told that we should be expecting a &lt;em&gt;Vector of strings&lt;&#x2F;em&gt;, so we should be able to add that to our declaration to complete the line.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;        let mut output: Vec&amp;lt;String&amp;gt; = vec![]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;completing-the-function-body&quot;&gt;Completing the Function Body&lt;&#x2F;h3&gt;
&lt;p&gt;Now, let&#x27;s consider what needs to be completed in the function body and the actions that need to be performed on the strings based on the commands. Remember, the available commands are &lt;code&gt;Uppercase&lt;&#x2F;code&gt;, &lt;code&gt;Trim&lt;&#x2F;code&gt;, and &lt;code&gt;Append&lt;&#x2F;code&gt;, that are defined in our &lt;code&gt;Command&lt;&#x2F;code&gt; enum.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn transformer(input: Vec&amp;lt;(String, Command)&amp;gt;) -&amp;gt; Vec&amp;lt;String&amp;gt; {
    let mut output: Vec&amp;lt;String&amp;gt; = vec![];
    for (string, command) in input.iter() {
    &amp;#x2F;&amp;#x2F; we use a match statement to match to the correct command
        let modified_string = match command {
        &amp;#x2F;&amp;#x2F; taking each case and using the appropriate method
            Command::Uppercase =&amp;gt; string.to_uppercase(), &amp;#x2F;&amp;#x2F; uppercase the string
            Command::Trim =&amp;gt; string.trim().to_string(), &amp;#x2F;&amp;#x2F; trim the string
            Command::Append(count) =&amp;gt; { &amp;#x2F;&amp;#x2F; appending
                let appended_string = format!(&amp;quot;{}{}&amp;quot;, string, &amp;quot;bar&amp;quot;.repeat(*count));
                appended_string
            }
        };
        output.push(modified_string); &amp;#x2F;&amp;#x2F; Add the modified string to the output vector
    }
    output &amp;#x2F;&amp;#x2F; Return the output vector
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So one of the ways that we know we can use enums is with match statements, we know that if something matches a certain criteria we can perform certain actions and return a value. So matching each &lt;code&gt;Command&lt;&#x2F;code&gt; in the &lt;code&gt;enum&lt;&#x2F;code&gt; using the &lt;code&gt;Command::Uppercase =&amp;gt;&lt;&#x2F;code&gt; style  matching we can perform an action for each match.
In the first two cases, it&#x27;s pretty simple all we have to do is call the appropriate method like &lt;code&gt;.to_upercase()&lt;&#x2F;code&gt; in the first match and &lt;code&gt;.trim()&lt;&#x2F;code&gt; (along with the &lt;code&gt;.to_string()&lt;&#x2F;code&gt; method on in &lt;code&gt;Trim&lt;&#x2F;code&gt;) but when we get to &lt;code&gt;Append&lt;&#x2F;code&gt; we have to perform an additional manipulation.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;appending&quot;&gt;Appending&lt;&#x2F;h3&gt;
&lt;p&gt;If we look back to our instructions we have to &lt;em&gt;Append &amp;quot;bar&amp;quot; to a string a specified amount of times&lt;&#x2F;em&gt;. So we can simply call a method or two and be done with our string. We have to add the logic to be able to do this. First let&#x27;s create a new variable called &lt;code&gt;appended_string&lt;&#x2F;code&gt; and let&#x27;s use the &lt;code&gt;format!&lt;&#x2F;code&gt; macro to put it into the format we want to use. In this case we use:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;format!(&amp;quot;{}{}&amp;quot;, string, &amp;quot;bar&amp;quot;.repeat(*count));
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This takes the original string, and concatenates &amp;quot;bar&amp;quot; to it by using &lt;code&gt;.repeat&lt;&#x2F;code&gt; we repeat it by the &lt;code&gt;count&lt;&#x2F;code&gt; we define in the &lt;code&gt;Command::Append(count)&lt;&#x2F;code&gt; branch. Finally, we return the  &lt;code&gt;appended_string&lt;&#x2F;code&gt;, reminder this only happens if the &lt;code&gt;Append&lt;&#x2F;code&gt; arm matches.&lt;&#x2F;p&gt;
&lt;p&gt;So at this point we have one of the three arms of the match inside of &lt;code&gt;modified_string&lt;&#x2F;code&gt; at this point we need to push this modified string to our &lt;code&gt;mut output&lt;&#x2F;code&gt;
Vec. Once that is completed we can then return our &lt;code&gt;output&lt;&#x2F;code&gt; variable with the correctly modified string.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;importing-transformer&quot;&gt;Importing &lt;code&gt;transformer&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Our last &lt;code&gt;TODO&lt;&#x2F;code&gt; is in our tests and it should be fairly simple to fix. We just have to use the full path of our function and remember to use the &lt;code&gt;crate&lt;&#x2F;code&gt; keyword that looks at the crate root, which is where our file is. After crate we must use the &lt;code&gt;::&lt;&#x2F;code&gt; double colon symbols which are equivalent to using &lt;code&gt;&#x2F;&lt;&#x2F;code&gt; in traditional file path systems. So for our purposes we need: &lt;code&gt;use crate::my_module::transformer;&lt;&#x2F;code&gt; to be able to use the function in our tests.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s the full updated code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub enum Command {
    Uppercase,
    Trim,
    Append(usize),
}

mod my_module {
    use super::Command;

    pub fn transformer(input: Vec&amp;lt;(String, Command)&amp;gt;) -&amp;gt; Vec&amp;lt;String&amp;gt; {
        let mut output: Vec&amp;lt;String&amp;gt; = vec![];
        for (string, command) in input.iter() {
            let modified_string = match command {
                Command::Uppercase =&amp;gt; string.to_uppercase(),
                Command::Trim =&amp;gt; string.trim().to_string(),
                Command::Append(count) =&amp;gt; {
                    let appended_string = format!(&amp;quot;{}{}&amp;quot;, string, &amp;quot;bar&amp;quot;.repeat(*count));
                    appended_string
                }
            };
            output.push(modified_string);
        }
        output
    }
}
#[cfg(test)]
mod tests {
    use super::Command;
    use crate::my_module::transformer;

    #[test]
    fn it_works() {
        let output = transformer(vec![
            (&amp;quot;hello&amp;quot;.into(), Command::Uppercase),
            (&amp;quot; all roads lead to rome! &amp;quot;.into(), Command::Trim),
            (&amp;quot;foo&amp;quot;.into(), Command::Append(1)),
            (&amp;quot;bar&amp;quot;.into(), Command::Append(5)),
        ]);
        assert_eq!(output[0], &amp;quot;HELLO&amp;quot;);
        assert_eq!(output[1], &amp;quot;all roads lead to rome!&amp;quot;);
        assert_eq!(output[2], &amp;quot;foobar&amp;quot;);
        assert_eq!(output[3], &amp;quot;barbarbarbarbarbar&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this post, we tackled Quiz 2, which required us to build a function that performs different actions on a list of strings based on given commands. We were instructed to uppercase a string, trim it, or append &amp;quot;bar&amp;quot; to it a specified number of times.&lt;&#x2F;p&gt;
&lt;p&gt;We began by analyzing the provided instructions and understanding the requirements. The input was expected to be a vector of tuples, where each tuple consisted of a string and a command. The output was to be a vector of strings.&lt;&#x2F;p&gt;
&lt;p&gt;Next, we addressed the incomplete parts of the code. We completed the function signature by specifying the input and output types as &lt;code&gt;Vec&amp;lt;(String, Command)&amp;gt;&lt;&#x2F;code&gt; and &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;&#x2F;code&gt; respectively.&lt;&#x2F;p&gt;
&lt;p&gt;In the function body, we utilized a &lt;code&gt;match&lt;&#x2F;code&gt; statement to match the command type and performed the corresponding action on the string. For the &lt;code&gt;Append&lt;&#x2F;code&gt; command, we used the &lt;code&gt;format!&lt;&#x2F;code&gt; macro to concatenate &amp;quot;bar&amp;quot; to the string a specified number of times.&lt;&#x2F;p&gt;
&lt;p&gt;We then added the modified strings to the &lt;code&gt;output&lt;&#x2F;code&gt; vector and returned it at the end of the function.&lt;&#x2F;p&gt;
&lt;p&gt;Lastly, we resolved the test-related task by importing the &lt;code&gt;transformer&lt;&#x2F;code&gt; function into the test module using the full path: &lt;code&gt;use crate::my_module::transformer;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;With these modifications, the code was successfully compiled and passed the provided tests.&lt;&#x2F;p&gt;
&lt;p&gt;Overall, this quiz allowed us to apply our knowledge of strings, vectors, move semantics, modules, and enums in Rust to build a functional machine. It reinforced our understanding of Rust concepts and helped us gain more confidence in utilizing them.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>12 Rustlings HashMaps</title>
          <pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/12-rustlings-hashmaps/</link>
          <guid>https://desmodrone.github.io/posts/12-rustlings-hashmaps/</guid>
          <description>&lt;h1 id=&quot;hashmaps&quot;&gt;Hashmaps&lt;&#x2F;h1&gt;
&lt;h5 id=&quot;from-the-rustlings-readme&quot;&gt;From the Rustlings README&lt;&#x2F;h5&gt;
&lt;p&gt;A &lt;em&gt;hash map&lt;&#x2F;em&gt; allows you to associate a value with a particular key.
You may also know this by the names &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;container&#x2F;unordered_map&quot;&gt;&lt;em&gt;unordered map&lt;&#x2F;em&gt; in C++&lt;&#x2F;a&gt;,
&lt;a href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;tutorial&#x2F;datastructures.html#dictionaries&quot;&gt;&lt;em&gt;dictionary&lt;&#x2F;em&gt; in Python&lt;&#x2F;a&gt; or an &lt;em&gt;associative array&lt;&#x2F;em&gt; in other languages.&lt;&#x2F;p&gt;
&lt;p&gt;This is the other data structure that we&#x27;ve been talking about before, when
talking about Vecs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch08-03-hash-maps.html&quot;&gt;Storing Keys with Associated Values in Hash Maps&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;hashmaps1-rs&quot;&gt;hashmaps1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; hashmaps1.rs
&amp;#x2F;&amp;#x2F; A basket of fruits in the form of a hash map needs to be defined.
&amp;#x2F;&amp;#x2F; The key represents the name of the fruit and the value represents
&amp;#x2F;&amp;#x2F; how many of that particular fruit is in the basket. You have to put
&amp;#x2F;&amp;#x2F; at least three different types of fruits (e.g apple, banana, mango)
&amp;#x2F;&amp;#x2F; in the basket and the total count of all the fruits should be at
&amp;#x2F;&amp;#x2F; least five.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Make me compile and pass the tests!
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Execute `rustlings hint hashmaps1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::collections::HashMap;

fn fruit_basket() -&amp;gt; HashMap&amp;lt;String, u32&amp;gt; {
    let mut basket = &amp;#x2F;&amp;#x2F; TODO: declare your hash map here.

    &amp;#x2F;&amp;#x2F; Two bananas are already given for you :)
    basket.insert(String::from(&amp;quot;banana&amp;quot;), 2);

    &amp;#x2F;&amp;#x2F; TODO: Put more fruits in your basket here.

    basket
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn at_least_three_types_of_fruits() {
        let basket = fruit_basket();
        assert!(basket.len() &amp;gt;= 3);
    }

    #[test]
    fn at_least_five_fruits() {
        let basket = fruit_basket();
        assert!(basket.values().sum::&amp;lt;u32&amp;gt;() &amp;gt;= 5);
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are to put more fruit into our &lt;code&gt;HashMap&lt;&#x2F;code&gt; basket, we need at least 3 different kinds of fruits and the total count of all fruits should be at least five. In the comments we see more instructions via &lt;code&gt;TODO&#x27;s&lt;&#x2F;code&gt; which are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;to declare a hash map&lt;&#x2F;li&gt;
&lt;li&gt;put more fruits in our basket.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;hashmaps1-rs-errors&quot;&gt;hashmaps1.rs errors&lt;&#x2F;h2&gt;
&lt;p&gt;A quick glance of our errors shows nothing unexpected:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;⚠️  Compiling of exercises&amp;#x2F;hashmaps&amp;#x2F;hashmaps1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0425]: cannot find value `basket` in this scope
  --&amp;gt; exercises&amp;#x2F;hashmaps&amp;#x2F;hashmaps1.rs:21:5
   |
21 |     basket.insert(String::from(&amp;quot;banana&amp;quot;), 2);
   |     ^^^^^^ not found in this scope

error: aborting due to previous error

For more information about this error, try `rustc --explain E0425`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;hashmaps1-solution&quot;&gt;hashmaps1 solution&lt;&#x2F;h2&gt;
&lt;p&gt;So now let&#x27;s move on to the solution. We first declare our &lt;code&gt;HashMap&lt;&#x2F;code&gt; by completing line 5 with &lt;code&gt;let mut basket = HashMap::new();&lt;&#x2F;code&gt;
That let&#x27;s us create our hashmap so it&#x27;s usable  in the next lines, meaning we can add some more fruit to it.
We already have our first line defined as &lt;code&gt;basket.insert(String::from(&amp;quot;banana&amp;quot;), 2);&lt;&#x2F;code&gt; so if we use this same pattern but add different fruits, keeping in mind our quantity requirements, we should be good.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::collections::HashMap;

fn fruit_basket() -&amp;gt; HashMap&amp;lt;String, u32&amp;gt; {
    &amp;#x2F;&amp;#x2F; TODO: declare your hash map here.
    let mut basket = HashMap::new();

    &amp;#x2F;&amp;#x2F; Two bananas are already given for you :)
    basket.insert(String::from(&amp;quot;banana&amp;quot;), 2);
    basket.insert(String::from(&amp;quot;apple&amp;quot;), 2);
    basket.insert(String::from(&amp;quot;mango&amp;quot;), 1);
    &amp;#x2F;&amp;#x2F; TODO: Put more fruits in your basket here.

    basket
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Easy enough, we declare a new HashMap and add some fruit.
Let&#x27;s move on to the next one!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hashmap2-rs&quot;&gt;hashmap2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; hashmaps2.rs

&amp;#x2F;&amp;#x2F; A basket of fruits in the form of a hash map is given. The key
&amp;#x2F;&amp;#x2F; represents the name of the fruit and the value represents how many
&amp;#x2F;&amp;#x2F; of that particular fruit is in the basket. You have to put *MORE
&amp;#x2F;&amp;#x2F; THAN 11* fruits in the basket. Three types of fruits - Apple (4),
&amp;#x2F;&amp;#x2F; Mango (2) and Lychee (5) are already given in the basket. You are
&amp;#x2F;&amp;#x2F; not allowed to insert any more of these fruits!
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Make me pass the tests!
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::collections::HashMap;

#[derive(Hash, PartialEq, Eq)]
enum Fruit {
    Apple,
    Banana,
    Mango,
    Lychee,
    Pineapple,
}

fn fruit_basket(basket: &amp;amp;mut HashMap&amp;lt;Fruit, u32&amp;gt;) {
    let fruit_kinds = vec![
        Fruit::Apple,
        Fruit::Banana,
        Fruit::Mango,
        Fruit::Lychee,
        Fruit::Pineapple,
    ];

    for fruit in fruit_kinds {
        &amp;#x2F;&amp;#x2F; TODO: Put new fruits if not already present. Note that you
        &amp;#x2F;&amp;#x2F; are not allowed to put any type of fruit that&amp;#x27;s already
        &amp;#x2F;&amp;#x2F; present!
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_fruit_basket() -&amp;gt; HashMap&amp;lt;Fruit, u32&amp;gt; {
        let mut basket = HashMap::&amp;lt;Fruit, u32&amp;gt;::new();
        basket.insert(Fruit::Apple, 4);
        basket.insert(Fruit::Mango, 2);
        basket.insert(Fruit::Lychee, 5);

        basket
    }

    #[test]
    fn test_given_fruits_are_not_modified() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;amp;mut basket);
        assert_eq!(*basket.get(&amp;amp;Fruit::Apple).unwrap(), 4);
        assert_eq!(*basket.get(&amp;amp;Fruit::Mango).unwrap(), 2);
        assert_eq!(*basket.get(&amp;amp;Fruit::Lychee).unwrap(), 5);
    }

    #[test]
    fn at_least_five_types_of_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;amp;mut basket);
        let count_fruit_kinds = basket.len();
        assert!(count_fruit_kinds &amp;gt;= 5);
    }

    #[test]
    fn greater_than_eleven_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;amp;mut basket);
        let count = basket.values().sum::&amp;lt;u32&amp;gt;();
        assert!(count &amp;gt; 11);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the given code, the goal is to modify the &lt;code&gt;fruit_basket&lt;&#x2F;code&gt; function to add more than 11 fruits of various kinds to a hash map (&lt;code&gt;HashMap&lt;&#x2F;code&gt;) called &lt;code&gt;basket&lt;&#x2F;code&gt;. The hash map represents a basket of fruits, where the keys are different types of fruits (represented by the &lt;code&gt;Fruit&lt;&#x2F;code&gt; enum) and the values are the number of each fruit in the basket (&lt;code&gt;u32&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;fruit_basket&lt;&#x2F;code&gt; function should insert additional fruit types into the &lt;code&gt;basket&lt;&#x2F;code&gt; hash map without modifying the quantities of the fruits that are already present (Apple, Mango, and Lychee) since they are already given in the initial basket.&lt;&#x2F;p&gt;
&lt;p&gt;The provided test cases ensure that the given fruits are not modified, that there are at least five types of fruits in the basket after the function execution, and that there are more than eleven fruits in total in the basket.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hashmap2-rs-solution&quot;&gt;hashmap2.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::collections::HashMap;

#[derive(Hash, PartialEq, Eq)]
enum Fruit {
    Apple,
    Banana,
    Mango,
    Lychee,
    Pineapple,
    Pear,
    Kiwi,
    Strawberries,
    Blueberries,
    Cherries,
    Lemons,
    Grapefruit,
}

fn fruit_basket(basket: &amp;amp;mut HashMap&amp;lt;Fruit, u32&amp;gt;) {
    let fruit_kinds = vec![
        Fruit::Apple,
        Fruit::Banana,
        Fruit::Mango,
        Fruit::Lychee,
        Fruit::Pineapple,
        Fruit::Pear,
        Fruit::Kiwi,
        Fruit::Strawberries,
        Fruit::Blueberries,
        Fruit::Cherries,
        Fruit::Lemons,
        Fruit::Grapefruit,
    ];

    for fruit in fruit_kinds {
        basket.insert(Fruit::Pear, 2);
        basket.insert(Fruit::Kiwi, 10);
        basket.insert(Fruit::Strawberries, 5);
        basket.insert(Fruit::Lemons, 6);
        basket.insert(Fruit::Strawberries, 6);
        basket.insert(Fruit::Blueberries, 6);
        basket.insert(Fruit::Grapefruit, 6);
        basket.insert(Fruit::Cherries, 6);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The solution involves adding more fruit types to the &lt;code&gt;fruit_kinds&lt;&#x2F;code&gt; vector, and then iterating through this vector to insert the new fruits into the &lt;code&gt;basket&lt;&#x2F;code&gt; hash map using the &lt;code&gt;insert&lt;&#x2F;code&gt; method. The solution includes adding multiple instances of new fruit types to meet the requirement of having more than eleven fruits in the basket.&lt;&#x2F;p&gt;
&lt;p&gt;In the solution code, several new fruit types (e.g., Pear, Kiwi, Strawberries, Blueberries, Cherries, Lemons, and Grapefruit) are added, and multiple instances of each fruit are inserted into the &lt;code&gt;basket&lt;&#x2F;code&gt; hash map.&lt;&#x2F;p&gt;
&lt;p&gt;This solution satisfies the requirements, passing all the given test cases, and ensuring that the function can add additional fruit types to the basket while preserving the initial quantities of the given fruits.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hashmaps3-rs&quot;&gt;hashmaps3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; hashmaps3.rs

&amp;#x2F;&amp;#x2F; A list of scores (one per line) of a soccer match is given. Each line
&amp;#x2F;&amp;#x2F; is of the form :
&amp;#x2F;&amp;#x2F; &amp;lt;team_1_name&amp;gt;,&amp;lt;team_2_name&amp;gt;,&amp;lt;team_1_goals&amp;gt;,&amp;lt;team_2_goals&amp;gt;
&amp;#x2F;&amp;#x2F; Example: England,France,4,2 (England scored 4 goals, France 2).

&amp;#x2F;&amp;#x2F; You have to build a scores table containing the name of the team, goals
&amp;#x2F;&amp;#x2F; the team scored, and goals the team conceded. One approach to build
&amp;#x2F;&amp;#x2F; the scores table is to use a Hashmap. The solution is partially
&amp;#x2F;&amp;#x2F; written to use a Hashmap, complete it to pass the test.

&amp;#x2F;&amp;#x2F; Make me pass the tests!

&amp;#x2F;&amp;#x2F; Execute `rustlings hint hashmaps3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

use std::collections::HashMap;

&amp;#x2F;&amp;#x2F; A structure to store team name and its goal details.
struct Team {
    name: String,
    goals_scored: u8,
    goals_conceded: u8,
}

fn build_scores_table(results: String) -&amp;gt; HashMap&amp;lt;String, Team&amp;gt; {
    &amp;#x2F;&amp;#x2F; The name of the team is the key and its associated struct is the value.
    let mut scores: HashMap&amp;lt;String, Team&amp;gt; = HashMap::new();

    for r in results.lines() {
        let v: Vec&amp;lt;&amp;amp;str&amp;gt; = r.split(&amp;#x27;,&amp;#x27;).collect();
        let team_1_name = v[0].to_string();
        let team_1_score: u8 = v[2].parse().unwrap();
        let team_2_name = v[1].to_string();
        let team_2_score: u8 = v[3].parse().unwrap();
        &amp;#x2F;&amp;#x2F; TODO: Populate the scores table with details extracted from the
        &amp;#x2F;&amp;#x2F; current line. Keep in mind that goals scored by team_1
        &amp;#x2F;&amp;#x2F; will be the number of goals conceded from team_2, and similarly
        &amp;#x2F;&amp;#x2F; goals scored by team_2 will be the number of goals conceded by
        &amp;#x2F;&amp;#x2F; team_1.
    }
    scores
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_results() -&amp;gt; String {
        let results = &amp;quot;&amp;quot;.to_string()
            + &amp;quot;England,France,4,2\n&amp;quot;
            + &amp;quot;France,Italy,3,1\n&amp;quot;
            + &amp;quot;Poland,Spain,2,0\n&amp;quot;
            + &amp;quot;Germany,England,2,1\n&amp;quot;;
        results
    }

    #[test]
    fn build_scores() {
        let scores = build_scores_table(get_results());

        let mut keys: Vec&amp;lt;&amp;amp;String&amp;gt; = scores.keys().collect();
        keys.sort();
        assert_eq!(
            keys,
            vec![&amp;quot;England&amp;quot;, &amp;quot;France&amp;quot;, &amp;quot;Germany&amp;quot;, &amp;quot;Italy&amp;quot;, &amp;quot;Poland&amp;quot;, &amp;quot;Spain&amp;quot;]
        );
    }

    #[test]
    fn validate_team_score_1() {
        let scores = build_scores_table(get_results());
        let team = scores.get(&amp;quot;England&amp;quot;).unwrap();
        assert_eq!(team.goals_scored, 5);
        assert_eq!(team.goals_conceded, 4);
    }

    #[test]
    fn validate_team_score_2() {
        let scores = build_scores_table(get_results());
        let team = scores.get(&amp;quot;Spain&amp;quot;).unwrap();
        assert_eq!(team.goals_scored, 0);
        assert_eq!(team.goals_conceded, 2);
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our task in this exercise is to build a scores table for soccer matches using a HashMap. We are given a list of match scores in the form of &lt;code&gt;&amp;lt;team_1_name&amp;gt;,&amp;lt;team_2_name&amp;gt;,&amp;lt;team_1_goals&amp;gt;,&amp;lt;team_2_goals&amp;gt;&lt;&#x2F;code&gt;. For example, &amp;quot;England,France,4,2&amp;quot; means England scored 4 goals, and France scored 2 goals in a match.&lt;&#x2F;p&gt;
&lt;p&gt;To build the scores table, we need to use a HashMap to store each team&#x27;s name, the goals they scored, and the goals they conceded in the matches.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hashmaps3-rs-errors&quot;&gt;hashmaps3.rs errors&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;⚠️  Testing of exercises&amp;#x2F;hashmaps&amp;#x2F;hashmaps3.rs failed! Please try again. Here&amp;#x27;s the output:

running 3 tests
test tests::build_scores ... FAILED
test tests::validate_team_score_1 ... FAILED
test tests::validate_team_score_2 ... FAILED

successes:

successes:

failures:

---- tests::build_scores stdout ----
thread &amp;#x27;tests::build_scores&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `[]`,
 right: `[&amp;quot;England&amp;quot;, &amp;quot;France&amp;quot;, &amp;quot;Germany&amp;quot;, &amp;quot;Italy&amp;quot;, &amp;quot;Poland&amp;quot;, &amp;quot;Spain&amp;quot;]`&amp;#x27;, exercises&amp;#x2F;hashmaps&amp;#x2F;hashmaps3.rs:66:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

---- tests::validate_team_score_1 stdout ----
thread &amp;#x27;tests::validate_team_score_1&amp;#x27; panicked at &amp;#x27;called `Option::unwrap()` on a `None` value&amp;#x27;, exercises&amp;#x2F;hashmaps&amp;#x2F;hashmaps3.rs:75:42

---- tests::validate_team_score_2 stdout ----
thread &amp;#x27;tests::validate_team_score_2&amp;#x27; panicked at &amp;#x27;called `Option::unwrap()` on a `None` value&amp;#x27;, exercises&amp;#x2F;hashmaps&amp;#x2F;hashmaps3.rs:83:40


failures:
    tests::build_scores
    tests::validate_team_score_1
    tests::validate_team_score_2

test result: FAILED. 0 passed; 3 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;hasmap3-rs-solution&quot;&gt;hasmap3.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
use std::collections::HashMap;

&amp;#x2F;&amp;#x2F; A structure to store team name and its goal details.
struct Team {
    name: String,
    goals_scored: u8,
    goals_conceded: u8,
}

fn build_scores_table(results: String) -&amp;gt; HashMap&amp;lt;String, Team&amp;gt; {
    &amp;#x2F;&amp;#x2F; The name of the team is the key and its associated struct is the value.
    let mut scores: HashMap&amp;lt;String, Team&amp;gt; = HashMap::new();

    for r in results.lines() {
        let v: Vec&amp;lt;&amp;amp;str&amp;gt; = r.split(&amp;#x27;,&amp;#x27;).collect();
        let team_1_name = v[0].to_string();
        let team_1_score: u8 = v[2].parse().unwrap();
        let team_2_name = v[1].to_string();
        let team_2_score: u8 = v[3].parse().unwrap();

        &amp;#x2F;&amp;#x2F; Try to get a mutable reference to the first team&amp;#x27;s Team struct in the scores HashMap
        scores
            .entry(team_1_name.clone())
            &amp;#x2F;&amp;#x2F; If the Team struct exists, modify it by incrementing the goals_scored and goals_conceded fields
            .and_modify(|team| {
                team.goals_scored += team_1_score;
                team.goals_conceded += team_2_score;
            })
            &amp;#x2F;&amp;#x2F; If the Team struct does not exist, insert a new one with the initial scores
            .or_insert(Team {
                name: team_1_name,
                goals_scored: team_1_score,
                goals_conceded: team_2_score,
            });

        &amp;#x2F;&amp;#x2F; Repeat the same process for the second team
        scores
            .entry(team_2_name.clone())
            .and_modify(|team| {
                team.goals_scored += team_2_score;
                team.goals_conceded += team_1_score;
            })
            .or_insert(Team {
                name: team_2_name,
                goals_scored: team_2_score,
                goals_conceded: team_1_score,
            });
    }
    scores
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The code already provides a &lt;code&gt;Team&lt;&#x2F;code&gt; struct with fields for the team&#x27;s name, goals scored, and goals conceded. Our task is to complete the &lt;code&gt;build_scores_table&lt;&#x2F;code&gt; function to create and populate the HashMap with the match results.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s our plan to complete the function:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We&#x27;ll start by creating an empty HashMap called &lt;code&gt;scores&lt;&#x2F;code&gt; to store the team details.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Next, we&#x27;ll iterate through each line of the &lt;code&gt;results&lt;&#x2F;code&gt; string using &lt;code&gt;results.lines()&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;For each line, we&#x27;ll split it into components using &lt;code&gt;.split(&#x27;,&#x27;)&lt;&#x2F;code&gt; to extract the team names and goals.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;We&#x27;ll convert the necessary fields to their correct types (e.g., team names as strings, goals as u8).&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Then, we&#x27;ll populate the &lt;code&gt;scores&lt;&#x2F;code&gt; HashMap with the team details. We need to be careful because goals scored by one team are the goals conceded by the other team.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Finally, we&#x27;ll return the &lt;code&gt;scores&lt;&#x2F;code&gt; HashMap from the function.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Once we complete the function, the provided test cases will validate that the scores table is correctly built, and each team&#x27;s goals scored and conceded are accurate.&lt;&#x2F;p&gt;
&lt;p&gt;This would print &lt;code&gt;&amp;quot;England,France,4,2\nFrance,Italy,3,1\n&amp;quot;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Each line of the results string represents one match, with the teams and their respective scores separated by commas. This loop goes through each line one at a time, parsing the teams and scores and updating the &lt;code&gt;scores&lt;&#x2F;code&gt; HashMap accordingly.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;entry()&lt;&#x2F;code&gt; method tries to get a mutable reference to the &lt;code&gt;Team&lt;&#x2F;code&gt; struct associated with a team&#x27;s name. If the &lt;code&gt;Team&lt;&#x2F;code&gt; struct exists, the &lt;code&gt;and_modify()&lt;&#x2F;code&gt; method modifies it by adding the new scores to the &lt;code&gt;goals_scored&lt;&#x2F;code&gt; and &lt;code&gt;goals_conceded&lt;&#x2F;code&gt; fields. If the &lt;code&gt;Team&lt;&#x2F;code&gt; struct doesn&#x27;t exist, the &lt;code&gt;or_insert()&lt;&#x2F;code&gt; method inserts a new &lt;code&gt;Team&lt;&#x2F;code&gt; struct with the initial scores.
This is done for both teams in each match. After all the matches have been processed, the &lt;code&gt;scores&lt;&#x2F;code&gt; HashMap is returned, with each team&#x27;s total goals scored and conceded updated to reflect all the matches.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;alternate-solution-using-if-let&quot;&gt;Alternate Solution using If &#x2F; Let&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn build_scores_table(results: String) -&amp;gt; HashMap&amp;lt;String, Team&amp;gt; {
    &amp;#x2F;&amp;#x2F; The name of the team is the key and its associated struct is the value.
    let mut scores: HashMap&amp;lt;String, Team&amp;gt; = HashMap::new();

    for r in results.lines() {
        let v: Vec&amp;lt;&amp;amp;str&amp;gt; = r.split(&amp;#x27;,&amp;#x27;).collect();
        let team_1_name = v[0].to_string();
        let team_1_score: u8 = v[2].parse().unwrap();
        let team_2_name = v[1].to_string();
        let team_2_score: u8 = v[3].parse().unwrap();

        &amp;#x2F;&amp;#x2F; Check if the first team exists in the scores HashMap
        if let Some(team) = scores.get_mut(&amp;amp;team_1_name) {
            &amp;#x2F;&amp;#x2F; If the team exists, increment the goals_scored and goals_conceded fields
            team.goals_scored += team_1_score;
            team.goals_conceded += team_2_score;
        } else {
            &amp;#x2F;&amp;#x2F; If the team does not exist, insert a new one with the initial scores
            scores.insert(
                team_1_name.clone(),
                Team {
                    name: team_1_name.clone(),
                    goals_scored: team_1_score,
                    goals_conceded: team_2_score,
                },
            );
        }

        &amp;#x2F;&amp;#x2F; Repeat the same process for the second team
        if let Some(team) = scores.get_mut(&amp;amp;team_2_name) {
            team.goals_scored += team_2_score;
            team.goals_conceded += team_1_score;
        } else {
            scores.insert(
                team_2_name.clone(),
                Team {
                    name: team_2_name.clone(),
                    goals_scored: team_2_score,
                    goals_conceded: team_1_score,
                },
            );
        }
    }
    scores
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this version, &lt;code&gt;if let Some(team) = scores.get_mut(&amp;amp;team_1_name)&lt;&#x2F;code&gt; tries to get a mutable reference to the team in the &lt;code&gt;scores&lt;&#x2F;code&gt; HashMap. If the team exists, &lt;code&gt;Some(team)&lt;&#x2F;code&gt; is returned and the team&#x27;s scores are updated. If the team does not exist, &lt;code&gt;None&lt;&#x2F;code&gt; is returned and a new &lt;code&gt;Team&lt;&#x2F;code&gt; struct is inserted into the &lt;code&gt;scores&lt;&#x2F;code&gt; HashMap with the &lt;code&gt;scores.insert()&lt;&#x2F;code&gt; method. This is repeated for both teams.&lt;&#x2F;p&gt;
&lt;p&gt;The logic is the same as in the previous version that uses closures, but the control flow is more explicit here. However, this version is slightly more verbose and arguably less idiomatic in Rust. Closures and method chaining using &lt;code&gt;and_modify&lt;&#x2F;code&gt; and &lt;code&gt;or_insert&lt;&#x2F;code&gt; on &lt;code&gt;HashMap::entry&lt;&#x2F;code&gt; are common patterns in Rust code.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;3rd-possible-solution&quot;&gt;3rd Possible Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn build_scores_table(results: String) -&amp;gt; HashMap&amp;lt;String, Team&amp;gt; {
    let mut scores: HashMap&amp;lt;String, Team&amp;gt; = HashMap::new();

    for r in results.lines() {
        let v: Vec&amp;lt;&amp;amp;str&amp;gt; = r.split(&amp;#x27;,&amp;#x27;).collect();
        let team_1_name = v[0].to_string();
        let team_1_score: u8 = v[2].parse().unwrap();
        let team_2_name = v[1].to_string();
        let team_2_score: u8 = v[3].parse().unwrap();

        &amp;#x2F;&amp;#x2F; Handle team 1
        let team_1 = scores.remove(&amp;amp;team_1_name);
        if let Some(mut t) = team_1 {
            t.goals_scored += team_1_score;
            t.goals_conceded += team_2_score;
            scores.insert(team_1_name, t);
        } else {
            scores.insert(team_1_name, Team { name: team_1_name.clone(), goals_scored: team_1_score, goals_conceded: team_2_score });
        }

        &amp;#x2F;&amp;#x2F; Handle team 2
        let team_2 = scores.remove(&amp;amp;team_2_name);
        if let Some(mut t) = team_2 {
            t.goals_scored += team_2_score;
            t.goals_conceded += team_1_score;
            scores.insert(team_2_name, t);
        } else {
            scores.insert(team_2_name, Team { name: team_2_name.clone(), goals_scored: team_2_score, goals_conceded: team_1_score });
        }
    }
    scores
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this version, &lt;code&gt;scores.remove(&amp;amp;team_1_name)&lt;&#x2F;code&gt; attempts to remove the &lt;code&gt;Team&lt;&#x2F;code&gt; struct associated with &lt;code&gt;team_1_name&lt;&#x2F;code&gt; from the HashMap. If the team exists, the &lt;code&gt;Team&lt;&#x2F;code&gt; struct is returned and removed from the HashMap, the team&#x27;s scores are updated, and the updated &lt;code&gt;Team&lt;&#x2F;code&gt; struct is re-inserted into the HashMap. If the team does not exist, a new &lt;code&gt;Team&lt;&#x2F;code&gt; struct is inserted into the HashMap. This process is repeated for both teams.&lt;&#x2F;p&gt;
&lt;p&gt;Although this version is simpler and doesn&#x27;t use closures, it&#x27;s also less efficient because it requires additional lookups and insertions into the HashMap. The previous two versions that use &lt;code&gt;HashMap::entry&lt;&#x2F;code&gt; are generally more efficient and idiomatic in Rust.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this post, we explored the concept of hash maps in Rust and how they allow us to associate values with specific keys. Hash maps are similar to unordered maps in C++, dictionaries in Python, or associative arrays in other languages. We learned how to use the HashMap data structure to build collections with key-value pairs.&lt;&#x2F;p&gt;
&lt;p&gt;We worked through three exercises that involved using hash maps to store and manipulate data:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;In &lt;code&gt;hashmaps1.rs&lt;&#x2F;code&gt;, we had to create a basket of fruits using a HashMap. We needed to ensure that the basket contained at least three different types of fruits and a total of at least five fruits. By declaring a new HashMap and adding the required fruits with their quantities, we successfully completed this task.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;In &lt;code&gt;hashmaps2.rs&lt;&#x2F;code&gt;, we were given a pre-defined basket of fruits and had to add more than eleven fruits of various kinds to it. However, we were not allowed to modify the quantities of the given fruits (Apple, Mango, and Lychee). By iterating through a list of new fruit types and inserting them into the HashMap, we successfully met the requirements of this exercise.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;In the exercise &lt;code&gt;hashmaps3.rs&lt;&#x2F;code&gt;, we were tasked with building a scores table for soccer matches using a &lt;code&gt;HashMap&lt;&#x2F;code&gt;. Three possible solutions were provided to achieve this goal:&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;Solution 1:&lt;&#x2F;strong&gt; &lt;em&gt;Using Closures and &lt;code&gt;entry()&lt;&#x2F;code&gt; Method Chaining&lt;&#x2F;em&gt;
This solution utilized closures and method chaining with &lt;code&gt;entry()&lt;&#x2F;code&gt; to efficiently handle the teams&#x27; scores and update the &lt;code&gt;HashMap&lt;&#x2F;code&gt; accordingly.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Solution 2:&lt;&#x2F;strong&gt; &lt;em&gt;Using &lt;code&gt;if let&lt;&#x2F;code&gt; Statements for Handling Entries&lt;&#x2F;em&gt;
In this solution, &lt;code&gt;if let&lt;&#x2F;code&gt; statements were used to handle entries in the &lt;code&gt;HashMap&lt;&#x2F;code&gt;, removing and updating teams&#x27; scores as needed.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Solution 3:&lt;&#x2F;strong&gt; &lt;em&gt;Using &lt;code&gt;if let&lt;&#x2F;code&gt; and &lt;code&gt;match&lt;&#x2F;code&gt; for Handling Entries&lt;&#x2F;em&gt;
This solution combined &lt;code&gt;if let&lt;&#x2F;code&gt; with &lt;code&gt;match&lt;&#x2F;code&gt; to handle the entries in the &lt;code&gt;HashMap&lt;&#x2F;code&gt;, similar to Solution 2, but with a slight variation in the syntax.&lt;&#x2F;p&gt;
&lt;p&gt;All three solutions achieved the goal of building the scores table and were valid approaches to solving the problem. The choice between these solutions may depend on personal coding style and preferences.&lt;&#x2F;p&gt;
&lt;p&gt;Key Takeaways:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Hash maps in Rust provide fast lookup and insertion times.&lt;&#x2F;li&gt;
&lt;li&gt;They enable efficient data retrieval and manipulation based on unique keys.&lt;&#x2F;li&gt;
&lt;li&gt;Hash maps are valuable tools for various scenarios, such as building scores tables or maintaining associations between data elements.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;By mastering the usage of hash maps, we expand our ability to manage and organize data efficiently in Rust. These skills are valuable for building robust and performant applications in a wide range of domains.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>11 Rustlings Modules</title>
          <pubDate>Mon, 17 Jul 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/11-rustlings-modules/</link>
          <guid>https://desmodrone.github.io/posts/11-rustlings-modules/</guid>
          <description>&lt;h1 id=&quot;modules&quot;&gt;Modules&lt;&#x2F;h1&gt;
&lt;p&gt;In this section we&#x27;ll give you an introduction to Rust&#x27;s module system.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch07-00-managing-growing-projects-with-packages-crates-and-modules.html&quot;&gt;The Module System&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;modules1-rs&quot;&gt;modules1.rs&lt;&#x2F;h2&gt;
&lt;p&gt;The first exercise focuses on controlling the visibility of functions within a module. The goal is to restrict access to the &lt;code&gt;get_secret_recipe&lt;&#x2F;code&gt; function outside the &lt;code&gt;sausage_factory&lt;&#x2F;code&gt; module. Let&#x27;s take a look at the initial code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; modules1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

mod sausage_factory {
    &amp;#x2F;&amp;#x2F; Don&amp;#x27;t let anybody outside of this module see this!
    fn get_secret_recipe() -&amp;gt; String {
        String::from(&amp;quot;Ginger&amp;quot;)
    }

    fn make_sausage() {
        get_secret_recipe();
        println!(&amp;quot;sausage!&amp;quot;);
    }
}

fn main() {
    sausage_factory::make_sausage();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions in this first exercise are to not let anyone outside of the &lt;code&gt;sausage_factory&lt;&#x2F;code&gt; module see the &lt;code&gt;get_secret_recipe&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modules1-rs-errors&quot;&gt;modules1.rs errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;modules&amp;#x2F;modules1.rs failed! Please try again. Here is the output:
error[E0603]: function `make_sausage` is private
  --&amp;gt; exercises&amp;#x2F;modules&amp;#x2F;modules1.rs:19:22
   |
19 |     sausage_factory::make_sausage();
   |                      ^^^^^^^^^^^^ private function
   |
note: the function `make_sausage` is defined here
  --&amp;gt; exercises&amp;#x2F;modules&amp;#x2F;modules1.rs:12:5
   |
12 |     fn make_sausage() {
   |     ^^^^^^^^^^^^^^^^^

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see that our errors tell us that our &lt;code&gt;make_sausage()&lt;&#x2F;code&gt; function is private and we can see that we are trying to access it in our &lt;code&gt;fn main()&lt;&#x2F;code&gt; so, our fix is simple, make the function that we need to see outside of the &lt;code&gt;sausage_factory&lt;&#x2F;code&gt; module accessible by adding a &lt;code&gt;pub&lt;&#x2F;code&gt; keyword. Let&#x27;s try this.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modules1-rs-solution&quot;&gt;modules1.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;mod sausage_factory {
    &amp;#x2F;&amp;#x2F; Don&amp;#x27;t let anybody outside of this module see this!
    fn get_secret_recipe() -&amp;gt; String {
        String::from(&amp;quot;Ginger&amp;quot;)
    }

    pub fn make_sausage() { &amp;#x2F;&amp;#x2F; adding `pub` here fixes our issue
        get_secret_recipe();
        println!(&amp;quot;sausage!&amp;quot;);
    }
}

fn main() {
    sausage_factory::make_sausage();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Simple solution by adding the &lt;code&gt;pub&lt;&#x2F;code&gt; keyword to our &lt;code&gt;make_sausage()&lt;&#x2F;code&gt; function we get access to it from our &lt;code&gt;main()&lt;&#x2F;code&gt; function and our code compiles and prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;sausage!
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;modules2-rs&quot;&gt;modules2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; modules2.rs
&amp;#x2F;&amp;#x2F; You can bring module paths into scopes and provide new names for them with the
&amp;#x2F;&amp;#x2F; &amp;#x27;use&amp;#x27; and &amp;#x27;as&amp;#x27; keywords. Fix these &amp;#x27;use&amp;#x27; statements to make the code compile.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

mod delicious_snacks {
    &amp;#x2F;&amp;#x2F; TODO: Fix these use statements
	use self::fruits::{PEAR as fruit};
    use self::veggies::CUCUMBER as ???

    mod fruits {
        pub const PEAR: &amp;amp;&amp;#x27;static str = &amp;quot;Pear&amp;quot;;
        pub const APPLE: &amp;amp;&amp;#x27;static str = &amp;quot;Apple&amp;quot;;
    }

    mod veggies {
        pub const CUCUMBER: &amp;amp;&amp;#x27;static str = &amp;quot;Cucumber&amp;quot;;
        pub const CARROT: &amp;amp;&amp;#x27;static str = &amp;quot;Carrot&amp;quot;;
    }
}

fn main() {
    println!(
        &amp;quot;favorite snacks: {} and {}&amp;quot;,
        delicious_snacks::fruit,
        delicious_snacks::veggie
    );
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions here are to bring our module into scope by using &lt;code&gt;use&lt;&#x2F;code&gt; and &lt;code&gt;as&lt;&#x2F;code&gt; keywords. We can see and incomplete &lt;code&gt;use&lt;&#x2F;code&gt; statement on line 11. Let&#x27;s take a quick look at the errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modules2-rs-errors&quot;&gt;modules2.rs errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;modules&amp;#x2F;modules2.rs failed! Please try again. Here is the output:
error: expected identifier, found `?`
  --&amp;gt; exercises&amp;#x2F;modules&amp;#x2F;modules2.rs:10:31
   |
10 |     use self::fruits::PEAR as ???
   |                               ^ expected identifier

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler confirms what we already know, but it actually gives us a big hint in telling us that it expects an identifier. So, let&#x27;s add the identifier.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modules2-rs-solution&quot;&gt;modules2.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;By looking at our code we can understand what the code is expecting as an identifier. It specifically shows in our &lt;code&gt;main()&lt;&#x2F;code&gt; function that we need to print the &lt;code&gt;delicious_snacks::fruit,&lt;&#x2F;code&gt; and the &lt;code&gt;delicious_snacks::veggie,&lt;&#x2F;code&gt; so this is a clear indication that we must identify our cucumber &amp;quot;as&amp;quot; a &lt;code&gt;veggie&lt;&#x2F;code&gt; let&#x27;s do that and see what happens.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;mod delicious_snacks {
    &amp;#x2F;&amp;#x2F; TODO: Fix these use statements
    pub use self::fruits::PEAR as fruit;
    pub use self::veggies::CUCUMBER as veggie; &amp;#x2F;&amp;#x2F; adding veggie identifier here

    mod fruits {
        pub const PEAR: &amp;amp;&amp;#x27;static str = &amp;quot;Pear&amp;quot;;
        pub const APPLE: &amp;amp;&amp;#x27;static str = &amp;quot;Apple&amp;quot;;
    }

    mod veggies {
        pub const CUCUMBER: &amp;amp;&amp;#x27;static str = &amp;quot;Cucumber&amp;quot;;
        pub const CARROT: &amp;amp;&amp;#x27;static str = &amp;quot;Carrot&amp;quot;;
    }
}

fn main() {
    println!(
        &amp;quot;favorite snacks: {} and {}&amp;quot;,
        delicious_snacks::fruit,
        delicious_snacks::veggie
    );
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And it works, we&#x27;re printing out of favorite snacks a pear and  cucumber using the &lt;code&gt;as&lt;&#x2F;code&gt; keyword.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
favorite snacks: Pear and Cucumber

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;modules3-rs&quot;&gt;modules3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; modules3.rs
&amp;#x2F;&amp;#x2F; You can use the &amp;#x27;use&amp;#x27; keyword to bring module paths from modules from anywhere
&amp;#x2F;&amp;#x2F; and especially from the Rust standard library into your scope.
&amp;#x2F;&amp;#x2F; Bring SystemTime and UNIX_EPOCH
&amp;#x2F;&amp;#x2F; from the std::time module. Bonus style points if you can do it with one line!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

&amp;#x2F;&amp;#x2F; TODO: Complete this use statement
use ???

fn main() {
    match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(n) =&amp;gt; println!(&amp;quot;1970-01-01 00:00:00 UTC was {} seconds ago!&amp;quot;, n.as_secs()),
        Err(_) =&amp;gt; panic!(&amp;quot;SystemTime before UNIX EPOCH!&amp;quot;),
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this third exercise, we encounter code that involves the use of &lt;code&gt;UNIX_EPOCH&lt;&#x2F;code&gt; and &lt;code&gt;SystemTime&lt;&#x2F;code&gt;. Let&#x27;s take a closer look at what these terms mean and how they relate to each other.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;UNIX_EPOCH&lt;&#x2F;code&gt; represents a specific point in time: the start of the Unix time system. In Unix-based operating systems, time is often measured as the number of seconds that have elapsed since January 1, 1970, at 00:00:00 UTC (Coordinated Universal Time). This point in time is commonly referred to as the Unix epoch.&lt;&#x2F;p&gt;
&lt;p&gt;On the other hand, &lt;code&gt;SystemTime&lt;&#x2F;code&gt; is a type provided by the Rust standard library that represents the system&#x27;s current time or a specific point in time. It is a flexible type that can handle different platforms and allows us to perform various operations on time values.&lt;&#x2F;p&gt;
&lt;p&gt;In the code snippet provided, the &lt;code&gt;match&lt;&#x2F;code&gt; statement is used to handle the result of calculating the duration between the current time (&lt;code&gt;SystemTime::now()&lt;&#x2F;code&gt;) and the Unix epoch (&lt;code&gt;UNIX_EPOCH&lt;&#x2F;code&gt;). By subtracting the Unix epoch from the current time, we can determine the duration that has passed since the Unix epoch.&lt;&#x2F;p&gt;
&lt;p&gt;If the calculation is successful (&lt;code&gt;Ok(n)&lt;&#x2F;code&gt;), we print the number of seconds that have elapsed since the Unix epoch. If an error occurs (&lt;code&gt;Err(_)&lt;&#x2F;code&gt;), indicating that the system time is before the Unix epoch, we panic with an appropriate error message.&lt;&#x2F;p&gt;
&lt;p&gt;By utilizing &lt;code&gt;UNIX_EPOCH&lt;&#x2F;code&gt; and &lt;code&gt;SystemTime&lt;&#x2F;code&gt;, we can work with time-related operations in Rust and perform calculations based on the Unix time system. Understanding these concepts enhances our ability to handle and manipulate time data effectively.&lt;&#x2F;p&gt;
&lt;p&gt;Now that we have a better understanding of &lt;code&gt;UNIX_EPOCH&lt;&#x2F;code&gt; and &lt;code&gt;SystemTime&lt;&#x2F;code&gt;, let&#x27;s proceed with the code solution to complete the exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modules3-rs-errors&quot;&gt;modules3.rs errors&lt;&#x2F;h2&gt;
&lt;p&gt;When analyzing the error messages in the &lt;code&gt;modules3.rs&lt;&#x2F;code&gt; exercise, we can see that they don&#x27;t provide any additional insights beyond the fact that an import statement is expected after the &lt;code&gt;use&lt;&#x2F;code&gt; keyword. The error message explicitly states that an identifier is anticipated after the &lt;code&gt;use&lt;&#x2F;code&gt; keyword. Therefore, to resolve this issue, we need to provide a valid identifier in our import statement.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;modules&amp;#x2F;modules3.rs failed! Please try again. Here is the output:
error: expected identifier, found `?`
  --&amp;gt; exercises&amp;#x2F;modules&amp;#x2F;modules3.rs:11:5
   |
11 | use ???
   |     ^ expected identifier

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;modules3-rs-solution&quot;&gt;modules3.rs solution&lt;&#x2F;h2&gt;
&lt;p&gt;Our hints are pretty direct we need to import from the &lt;code&gt;std::time&lt;&#x2F;code&gt; module both &lt;code&gt;UNIX_EPOCH&lt;&#x2F;code&gt; and &lt;code&gt;SystemTime&lt;&#x2F;code&gt; into our code, and in order to save space and time we should it in one line. The way we do this is by including adding curly braces&lt;code&gt;{}&lt;&#x2F;code&gt; into our import statement and separating each item with a comma, easy enough.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(n) =&amp;gt; println!(&amp;quot;19-01-01 00:00:00 UTC was {} seconds ago!&amp;quot;, n.as_secs()),
        Err(_) =&amp;gt; panic!(&amp;quot;SystemTime before UNIX EPOCH!&amp;quot;),
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the output we get&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
1970-01-01 00:00:00 UTC was 1687044064 seconds ago!

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we explored three exercises related to Rust&#x27;s module system. Here are the key takeaways:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Modules allow us to organize code by grouping related functionality together.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;pub&lt;&#x2F;code&gt; keyword is used to make items (functions, types, etc.) accessible outside their module.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;use&lt;&#x2F;code&gt; keyword can be used to bring module paths into scope, allowing us to use items from other modules with ease.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;as&lt;&#x2F;code&gt; keyword in the &lt;code&gt;use&lt;&#x2F;code&gt; statement allows us to provide new names for imported items.&lt;&#x2F;li&gt;
&lt;li&gt;The Rust standard library provides various modules that can be imported using the &lt;code&gt;use&lt;&#x2F;code&gt; keyword to leverage pre-existing functionality.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;By understanding and utilizing Rust&#x27;s module system effectively, we can write well-structured and maintainable code. Keep practicing and exploring different aspects of Rust to deepen your understanding of the language.&lt;&#x2F;p&gt;
&lt;p&gt;For further information on Rust&#x27;s module system, refer to the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch07-00-managing-growing-projects-with-packages-crates-and-modules.html&quot;&gt;official documentation&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>10 Rustlings Strings</title>
          <pubDate>Wed, 28 Jun 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/10-rustlings-strings/</link>
          <guid>https://desmodrone.github.io/posts/10-rustlings-strings/</guid>
          <description>&lt;h3 id=&quot;from-the-readme&quot;&gt;From the ReadMe:&lt;&#x2F;h3&gt;
&lt;p&gt;Rust has two string types, a string slice (&lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;) and an owned string (&lt;code&gt;String&lt;&#x2F;code&gt;).
We&#x27;re not going to dictate when you should use which one, but we&#x27;ll show you how
to identify and create them, as well as use them.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch08-02-strings.html&quot;&gt;Strings&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;strings1-rs&quot;&gt;strings1.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; strings1.rs
&amp;#x2F;&amp;#x2F; Make me compile without changing the function signature!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let answer = current_favorite_color();
    println!(&amp;quot;My current favorite color is {}&amp;quot;, answer);
}

fn current_favorite_color() -&amp;gt; String {
    &amp;quot;blue&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are pretty straight forward we must make this code compile without changing the function signature.
As always we&#x27;ll take a look at the errors to and see if we get any hints.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings1-rs-errors&quot;&gt;strings1.rs errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;strings&amp;#x2F;strings1.rs failed! Please try again. Here is the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;strings&amp;#x2F;strings1.rs:13:5
   |
12 | fn current_favorite_color() -&amp;gt; String {
   |                                ------ expected `String` because of return type
13 |     &amp;quot;blue&amp;quot;
   |     ^^^^^^- help: try using a conversion method: `.to_string()`
   |     |
   |     expected struct `String`, found `&amp;amp;str`

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We do get a hint, it tells us to try using a conversion method: &lt;code&gt;.to_string()&lt;&#x2F;code&gt;, so why not let&#x27;s try that.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings1-rs-solution&quot;&gt;strings1.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let answer = current_favorite_color();
    println!(&amp;quot;My current favorite color is {}&amp;quot;, answer);
}

fn current_favorite_color() -&amp;gt; String {
    &amp;quot;blue&amp;quot;.to_string()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Just like this, it works appending our &lt;code&gt;&amp;quot;blue&amp;quot;&lt;&#x2F;code&gt; string with &lt;code&gt;.to_string&lt;&#x2F;code&gt; converts our &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; to a &lt;code&gt;String&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Converting &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; to &lt;code&gt;String&lt;&#x2F;code&gt; with &lt;code&gt;.to_string()&lt;&#x2F;code&gt;:&lt;&#x2F;strong&gt; The method &lt;code&gt;.to_string()&lt;&#x2F;code&gt; is used to convert a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; (string slice) to an owned &lt;code&gt;String&lt;&#x2F;code&gt;. In Rust, &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; represents a string slice, which is an immutable reference to a string. A &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; is a view into a string, and is usually used in program arguments and for reading strings from files or other I&#x2F;O operations. On the other hand, &lt;code&gt;String&lt;&#x2F;code&gt; is a growable, mutable, owned, heap allocated data structure. When you call &lt;code&gt;.to_string()&lt;&#x2F;code&gt; on a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;, you essentially allocate a chunk of heap memory, copy the contents of the &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; to that newly allocated memory, and return a &lt;code&gt;String&lt;&#x2F;code&gt; that owns that heap memory. This is why &lt;code&gt;&amp;quot;blue&amp;quot;.to_string()&lt;&#x2F;code&gt; gives you an owned &lt;code&gt;String&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This is the output:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
My current favorite color is blue

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;strings2-rs&quot;&gt;strings2.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; strings2.rs
&amp;#x2F;&amp;#x2F; Make me compile without changing the function signature!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint strings2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let word = String::from(&amp;quot;green&amp;quot;); &amp;#x2F;&amp;#x2F; Try not changing this line :)
    if is_a_color_word(word) {
        println!(&amp;quot;That is a color word I know!&amp;quot;);
    } else {
        println!(&amp;quot;That is not a color word I know.&amp;quot;);
    }
}

fn is_a_color_word(attempt: &amp;amp;str) -&amp;gt; bool {
    attempt == &amp;quot;green&amp;quot; || attempt == &amp;quot;blue&amp;quot; || attempt == &amp;quot;red&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have another exercise that asks for a similar request: &lt;code&gt;compile without changing the function signature!&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings2-rs-errors&quot;&gt;strings2.rs errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;strings&amp;#x2F;strings2.rs failed! Please try again. Here is the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;strings&amp;#x2F;strings2.rs:9:24
   |
9  |     if is_a_color_word(word) {
   |        --------------- ^^^^
   |        |               |
   |        |               expected `&amp;amp;str`, found struct `String`
   |        |               help: consider borrowing here: `&amp;amp;word`
   |        arguments to this function are incorrect
   |
note: function defined here
  --&amp;gt; exercises&amp;#x2F;strings&amp;#x2F;strings2.rs:16:4
   |
16 | fn is_a_color_word(attempt: &amp;amp;str) -&amp;gt; bool {
   |    ^^^^^^^^^^^^^^^ -------------
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So, we&#x27;re being told a couple of things, that the arguments in our function are incorrect and that the the compiler is expecting a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; but it&#x27;s finding a &lt;code&gt;String&lt;&#x2F;code&gt; instead. So let&#x27;s try making it an &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; by adding a reference to &lt;code&gt;word&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings2-rs-solution&quot;&gt;strings2.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let word = String::from(&amp;quot;green&amp;quot;); &amp;#x2F;&amp;#x2F; Try not changing this line :)
    if is_a_color_word(&amp;amp;word) { &amp;#x2F;&amp;#x2F; added `&amp;amp;` to `word`
        println!(&amp;quot;That is a color word I know!&amp;quot;);
    } else {
        println!(&amp;quot;That is not a color word I know.&amp;quot;);
    }
}

fn is_a_color_word(attempt: &amp;amp;str) -&amp;gt; bool {
    attempt == &amp;quot;green&amp;quot; || attempt == &amp;quot;blue&amp;quot; || attempt == &amp;quot;red&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;The &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; operator to create a reference:&lt;&#x2F;strong&gt; The &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; operator in Rust is used to create a reference to a value. When you write &lt;code&gt;&amp;amp;word&lt;&#x2F;code&gt; in the call to &lt;code&gt;is_a_color_word(&amp;amp;word)&lt;&#x2F;code&gt;, you are passing a reference to &lt;code&gt;word&lt;&#x2F;code&gt; rather than &lt;code&gt;word&lt;&#x2F;code&gt; itself. This is important because the function &lt;code&gt;is_a_color_word&lt;&#x2F;code&gt; is expecting a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; (a string slice), not a &lt;code&gt;String&lt;&#x2F;code&gt;. If you tried to pass &lt;code&gt;word&lt;&#x2F;code&gt; directly, Rust would raise a type mismatch error because &lt;code&gt;word&lt;&#x2F;code&gt; is a &lt;code&gt;String&lt;&#x2F;code&gt; and not a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;. By using &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt;, you&#x27;re allowing &lt;code&gt;is_a_color_word&lt;&#x2F;code&gt; to borrow &lt;code&gt;word&lt;&#x2F;code&gt; as a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; for the duration of the function call.&lt;&#x2F;p&gt;
&lt;p&gt;With that we&#x27;re compiling here too, simple enough, we get the following print out:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
That is a color word I know!

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we change the line &lt;code&gt;let word = String::from(&amp;quot;red&amp;quot;)&lt;&#x2F;code&gt; or &lt;code&gt;&amp;quot;blue&amp;quot;&lt;&#x2F;code&gt; we&#x27;d continue to get the same printout but, if we change it say to &lt;code&gt;purple&lt;&#x2F;code&gt; we get this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
That is not a color word I know.

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;strings3-rs&quot;&gt;strings3.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; strings3.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn trim_me(input: &amp;amp;str) -&amp;gt; String {
    &amp;#x2F;&amp;#x2F; TODO: Remove whitespace from both ends of a string!
    input.().to_string()
}

fn compose_me(input: &amp;amp;str) -&amp;gt; String {
    &amp;#x2F;&amp;#x2F; TODO: Add &amp;quot; world!&amp;quot; to the string! There&amp;#x27;s multiple ways to do this!
    let mut result = input.to_owned();
    result.push_str(&amp;quot; world!&amp;quot;);
    result
}

fn replace_me(input: &amp;amp;str) -&amp;gt; String {
    &amp;#x2F;&amp;#x2F; TODO: Replace &amp;quot;cars&amp;quot; in the string with &amp;quot;balloons&amp;quot;!
    input.replace(&amp;quot;cars&amp;quot;, &amp;quot;balloons&amp;quot;)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn trim_a_string() {
        assert_eq!(trim_me(&amp;quot;Hello!     &amp;quot;), &amp;quot;Hello!&amp;quot;);
        assert_eq!(trim_me(&amp;quot;  What&amp;#x27;s up!&amp;quot;), &amp;quot;What&amp;#x27;s up!&amp;quot;);
        assert_eq!(trim_me(&amp;quot;   Hola!  &amp;quot;), &amp;quot;Hola!&amp;quot;);
    }

    #[test]
    fn compose_a_string() {
        assert_eq!(compose_me(&amp;quot;Hello&amp;quot;), &amp;quot;Hello world!&amp;quot;);
        assert_eq!(compose_me(&amp;quot;Goodbye&amp;quot;), &amp;quot;Goodbye world!&amp;quot;);
    }

    #[test]
    fn replace_a_string() {
        assert_eq!(replace_me(&amp;quot;I think cars are cool&amp;quot;), &amp;quot;I think balloons are cool&amp;quot;);
        assert_eq!(replace_me(&amp;quot;I love to look at cars&amp;quot;), &amp;quot;I love to look at balloons&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So here we have to make our code compile and pass the tests, we get a list of &lt;code&gt;TODO&lt;&#x2F;code&gt; items on how to finish our functions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings3-rs-errors&quot;&gt;strings3.rs errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;strings&amp;#x2F;strings3.rs failed! Please try again. Here is the output:
error: expected expression, found `?`
 --&amp;gt; exercises&amp;#x2F;strings&amp;#x2F;strings3.rs:8:5
  |
8 |     ???
  |     ^ expected expression

error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;strings&amp;#x2F;strings3.rs:13:5
   |
13 |     ???
   |     ^ expected expression

error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;strings&amp;#x2F;strings3.rs:18:5
   |
18 |     ???
   |     ^ expected expression

error: aborting due to 3 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our errors are clearly due to the missing function bodies.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings3-rs-solution&quot;&gt;strings3.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn trim_me(input: &amp;amp;str) -&amp;gt; String {
    &amp;#x2F;&amp;#x2F; TODO: Remove whitespace from both ends of a string!
    input.trim().to_string()
}

fn compose_me(input: &amp;amp;str) -&amp;gt; String {
    &amp;#x2F;&amp;#x2F; TODO: Add &amp;quot; world!&amp;quot; to the string! There&amp;#x27;s multiple ways to do this!
    let mut result = input.to_string();
    result.push_str(&amp;quot; world!&amp;quot;);
    result
}

fn replace_me(input: &amp;amp;str) -&amp;gt; String {
    &amp;#x2F;&amp;#x2F; TODO: Replace &amp;quot;cars&amp;quot; in the string with &amp;quot;balloons&amp;quot;!
    input.replace(&amp;quot;cars&amp;quot;, &amp;quot;ballons&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To pass the test and finalize the functions we have to use &lt;code&gt;methods&lt;&#x2F;code&gt; on each of the &lt;code&gt;input&lt;&#x2F;code&gt; parameters that are being passed through.&lt;&#x2F;p&gt;
&lt;p&gt;In our first function &lt;code&gt;trim_me&lt;&#x2F;code&gt; as the comment states we have to remove whitespace from the string. The &lt;code&gt;trim()&lt;&#x2F;code&gt; method does just that and we can use &lt;code&gt;.to_string&lt;&#x2F;code&gt; to convert our parameter &lt;code&gt;input&lt;&#x2F;code&gt; from a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; to a &lt;code&gt;String&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In the &lt;code&gt;compose_me&lt;&#x2F;code&gt; there are a few different ways to solve this, I chose to create a new variable &lt;code&gt;result&lt;&#x2F;code&gt; that contains the &lt;code&gt;input.to_string()&lt;&#x2F;code&gt; and then we use the &lt;code&gt;push_str&lt;&#x2F;code&gt; method on &lt;code&gt;result&lt;&#x2F;code&gt; to add the &amp;quot;&lt;code&gt;world!&lt;&#x2F;code&gt;&amp;quot; to our newly created &lt;code&gt;String&lt;&#x2F;code&gt;. Then finally return the &lt;code&gt;result&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Finally in our &lt;code&gt;replace_me&lt;&#x2F;code&gt; function we use the &lt;code&gt;replace()&lt;&#x2F;code&gt; method to simply replace &lt;code&gt;&amp;quot;cars&amp;quot;&lt;&#x2F;code&gt; to: &lt;code&gt;&amp;quot;balloons&amp;quot;&lt;&#x2F;code&gt; and that should do it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings4-rs&quot;&gt;strings4.rs&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; strings4.rs

&amp;#x2F;&amp;#x2F; Ok, here are a bunch of values-- some are `String`s, some are `&amp;amp;str`s. Your
&amp;#x2F;&amp;#x2F; task is to call one of these two functions on each value depending on what
&amp;#x2F;&amp;#x2F; you think each value is. That is, add either `string_slice` or `string`
&amp;#x2F;&amp;#x2F; before the parentheses on each line. If you&amp;#x27;re right, it will compile!
&amp;#x2F;&amp;#x2F; No hints this time!

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn string_slice(arg: &amp;amp;str) {
    println!(&amp;quot;{}&amp;quot;, arg);
}
fn string(arg: String) {
    println!(&amp;quot;{}&amp;quot;, arg);
}

fn main() {
    &amp;amp;str(&amp;quot;blue&amp;quot;);
    ???(&amp;quot;red&amp;quot;.to_string());
    ???(String::from(&amp;quot;hi&amp;quot;));
    ???(&amp;quot;rust is fun!&amp;quot;.to_owned());
    ???(&amp;quot;nice weather&amp;quot;.into());
    ???(format!(&amp;quot;Interpolation {}&amp;quot;, &amp;quot;Station&amp;quot;));
    ???(&amp;amp;String::from(&amp;quot;abc&amp;quot;)[0..1]);
    ???(&amp;quot;  hello there &amp;quot;.trim());
    ???(&amp;quot;Happy Monday!&amp;quot;.to_string().replace(&amp;quot;Mon&amp;quot;, &amp;quot;Tues&amp;quot;));
    ???(&amp;quot;mY sHiFt KeY iS sTiCkY&amp;quot;.to_lowercase());
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright this seems easy enough we have to understand if the value is a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; or a &lt;code&gt;String&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings4-rs-errors&quot;&gt;strings4.rs errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;strings&amp;#x2F;strings4.rs failed! Please try again. Here is the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;strings&amp;#x2F;strings4.rs:19:5
   |
19 |     ???(&amp;quot;blue&amp;quot;);
   |     ^ expected expression

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have one error, but it is obvious that we&#x27;ll have a few more after where we have the question marks.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings4-rs-solution&quot;&gt;strings4.rs solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn string_slice(arg: &amp;amp;str) {
    println!(&amp;quot;{}&amp;quot;, arg);
}
fn string(arg: String) {
    println!(&amp;quot;{}&amp;quot;, arg);
}

fn main() {
    string_slice(&amp;quot;blue&amp;quot;);
    string(&amp;quot;red&amp;quot;.to_string());
    string(String::from(&amp;quot;hi&amp;quot;));
    string(&amp;quot;rust is fun!&amp;quot;.to_owned());
    string_slice(&amp;quot;nice weather&amp;quot;.into());
    string(format!(&amp;quot;Interpolation {}&amp;quot;, &amp;quot;Station&amp;quot;));
    string_slice(&amp;amp;String::from(&amp;quot;abc&amp;quot;)[0..1]);
    string_slice(&amp;quot;  hello there &amp;quot;.trim());
    string(&amp;quot;Happy Monday!&amp;quot;.to_string().replace(&amp;quot;Mon&amp;quot;, &amp;quot;Tues&amp;quot;));
    string(&amp;quot;mY sHiFt KeY iS sTiCkY&amp;quot;.to_lowercase());
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Choosing between &lt;code&gt;string_slice&lt;&#x2F;code&gt; and &lt;code&gt;string&lt;&#x2F;code&gt; in &lt;code&gt;strings4.rs&lt;&#x2F;code&gt;:&lt;&#x2F;strong&gt; The &lt;code&gt;string_slice&lt;&#x2F;code&gt; function takes a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; (string slice) argument, while &lt;code&gt;string&lt;&#x2F;code&gt; function takes a &lt;code&gt;String&lt;&#x2F;code&gt; argument. When you&#x27;re calling these functions in &lt;code&gt;main()&lt;&#x2F;code&gt;, you need to determine whether each argument is a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; or a &lt;code&gt;String&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;For instance, &lt;code&gt;&amp;quot;blue&amp;quot;&lt;&#x2F;code&gt; is a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;, because it&#x27;s a string literal. In Rust, string literals are string slices.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;red&amp;quot;.to_string()&lt;&#x2F;code&gt;, on the other hand, is a &lt;code&gt;String&lt;&#x2F;code&gt;. As explained earlier, &lt;code&gt;.to_string()&lt;&#x2F;code&gt; is a method that converts a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; to a &lt;code&gt;String&lt;&#x2F;code&gt; by allocating heap memory and copying the string there.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;String::from(&amp;quot;hi&amp;quot;)&lt;&#x2F;code&gt; is also a &lt;code&gt;String&lt;&#x2F;code&gt;. &lt;code&gt;String::from&lt;&#x2F;code&gt; is a function that performs the same task as &lt;code&gt;.to_string()&lt;&#x2F;code&gt;, creating an owned string from a string literal or a string slice.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;nice weather&amp;quot;.into()&lt;&#x2F;code&gt; is an interesting case. The &lt;code&gt;.into()&lt;&#x2F;code&gt; method is a very generic conversion method that converts between various types. In this context, it will automatically be resolved to &lt;code&gt;String&lt;&#x2F;code&gt;, so it should be passed to &lt;code&gt;string&lt;&#x2F;code&gt; function. However, it&#x27;s worth noting that this automatic resolution is based on the current context and it can lead to potential confusion if the type resolution is ambiguous.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Understanding how to work with strings is essential in Rust, as it&#x27;s a common part of most programming tasks. We&#x27;ve learned that Rust has two main string types: &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; and &lt;code&gt;String&lt;&#x2F;code&gt;. The &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; type is a string slice, which is an immutable reference to a string, whereas &lt;code&gt;String&lt;&#x2F;code&gt; is an owned string that can be modified.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ve also practiced converting between these two types using the &lt;code&gt;to_string()&lt;&#x2F;code&gt; method, and we&#x27;ve learned how to create references to strings using the &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; operator. Additionally, we&#x27;ve used various methods to manipulate strings, such as &lt;code&gt;trim()&lt;&#x2F;code&gt;, &lt;code&gt;push_str()&lt;&#x2F;code&gt;, and &lt;code&gt;replace()&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The exercises and solutions provided in this post are a good starting point for understanding and mastering strings in Rust. Continue experimenting and practicing with these concepts to gain a solid understanding of how strings work in Rust.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>09 Rustlings Enums</title>
          <pubDate>Wed, 07 Jun 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/09-rustlings-enums/</link>
          <guid>https://desmodrone.github.io/posts/09-rustlings-enums/</guid>
          <description>&lt;p&gt;Rust allows you to define types called &amp;quot;enums&amp;quot; which enumerate possible values.
Enums are a feature in many languages, but their capabilities differ in each language. Rust’s enums are most similar to algebraic data types in functional languages, such as F#, OCaml, and Haskell.
Useful in combination with enums is Rust&#x27;s &amp;quot;pattern matching&amp;quot; facility, which makes it easy to run different code for different values of an enumeration.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch06-00-enums.html&quot;&gt;Enums&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch18-03-pattern-syntax.html&quot;&gt;Pattern syntax&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;enums1-rs&quot;&gt;&lt;code&gt;enums1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; enums1.rs
&amp;#x2F;&amp;#x2F; No hints this time! ;)

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[derive(Debug)]
enum Message {
    &amp;#x2F;&amp;#x2F; TODO: define a few types of messages as used below
}

fn main() {
    println!(&amp;quot;{:?}&amp;quot;, Message::Quit);
    println!(&amp;quot;{:?}&amp;quot;, Message::Echo);
    println!(&amp;quot;{:?}&amp;quot;, Message::Move);
    println!(&amp;quot;{:?}&amp;quot;, Message::ChangeColor);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we have our code, with not much instruction and no hint this time! But we do have a message in the comments: &lt;code&gt;TODO: define a few types of messages as used below&lt;&#x2F;code&gt;.  Let&#x27;s take a look at the errors as well.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;enums1-rs-errors&quot;&gt;&lt;code&gt;enums1.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;enums&amp;#x2F;enums1.rs failed! Please try again. Here is the output:

error[E0599]: no variant or associated item named `Quit` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums1.rs:12:31
   |
7  | enum Message {
   | ------------ variant or associated item `Quit` not found for this enum
...
12 |     println!(&amp;quot;{:?}&amp;quot;, Message::Quit);
   |                               ^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums1.rs:13:31
   |
7  | enum Message {
   | ------------ variant or associated item `Echo` not found for this enum
...
13 |     println!(&amp;quot;{:?}&amp;quot;, Message::Echo);
   |                               ^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `Move` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums1.rs:14:31
   |
7  | enum Message {
   | ------------ variant or associated item `Move` not found for this enum
...
14 |     println!(&amp;quot;{:?}&amp;quot;, Message::Move);
   |                               ^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums1.rs:15:31
   |
7  | enum Message {
   | ------------ variant or associated item `ChangeColor` not found for this enum
...
15 |     println!(&amp;quot;{:?}&amp;quot;, Message::ChangeColor);
   |                               ^^^^^^^^^^^ variant or associated item not found in `Message`

error: aborting due to 4 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our errors are pretty straight forward here, we essentially have a repeating messages for each of these errors&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;no variant or associated item named `Quit` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums1.rs:12:31
   |
7  | enum Message {
   | ------------ variant or associated item `Quit` not found for this enum
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which is telling us that we&#x27;re missing items in the &lt;code&gt;enum&lt;&#x2F;code&gt; which of course makes sense since we know that we have to fill out the rest of the &lt;code&gt;enum&lt;&#x2F;code&gt;. What&#x27;s nice is that the message is very clear and show&#x27;s us where our item are missing which is clearly the &lt;code&gt;enum Message&lt;&#x2F;code&gt;. So let&#x27;s get to it and fill out that &lt;code&gt;enum&lt;&#x2F;code&gt; and see what happens.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;enums1-rs-solution&quot;&gt;&lt;code&gt;enums1.rs&lt;&#x2F;code&gt;  solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[derive(Debug)]
enum Message {
    Quit,
    Echo,
    Move,
    ChangeColor,
}

fn main() {
    println!(&amp;quot;{:?}&amp;quot;, Message::Quit);
    println!(&amp;quot;{:?}&amp;quot;, Message::Echo);
    println!(&amp;quot;{:?}&amp;quot;, Message::Move);
    println!(&amp;quot;{:?}&amp;quot;, Message::ChangeColor);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;...and this compiles, this is relatively simple as all we had to do is look at the &lt;code&gt;main()&lt;&#x2F;code&gt; confirmed with the &lt;code&gt;errors&lt;&#x2F;code&gt; and we&#x27;ve got our complete &lt;code&gt;enum Message&lt;&#x2F;code&gt;, we didn&#x27;t need any hints now did we? Here&#x27;s our output:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Quit
Echo
Move
ChangeColor

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;enums2-rs&quot;&gt;&lt;code&gt;enums2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; enums2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[derive(Debug)]
enum Message {
    &amp;#x2F;&amp;#x2F; TODO: define the different variants used below
}

impl Message {
    fn call(&amp;amp;self) {
        println!(&amp;quot;{:?}&amp;quot;, self);
    }
}

fn main() {
    let messages = [
        Message::Move { x: 10, y: 30 },
        Message::Echo(String::from(&amp;quot;hello world&amp;quot;)),
        Message::ChangeColor(200, 255, 255),
        Message::Quit,
    ];

    for message in &amp;amp;messages {
        message.call();
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have a similar set-up here with what we saw in the previous exercise in which we have to define the different variants that are used in the rest of the code, in this case in our &lt;code&gt;main()&lt;&#x2F;code&gt; function. Let&#x27;s take a look at the errors like we always do.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;enums2-rs-errors&quot;&gt;&lt;code&gt;enums2.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;enums&amp;#x2F;enums2.rs failed! Please try again. Here is the output:
error[E0599]: no variant named `Move` found for enum `Message`
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums2.rs:19:18
   |
7  | enum Message {
   | ------------ variant `Move` not found here
...
19 |         Message::Move { x: 10, y: 30 },
   |                  ^^^^ variant not found in `Message`

error[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums2.rs:20:18
   |
7  | enum Message {
   | ------------ variant or associated item `Echo` not found for this enum
...
20 |         Message::Echo(String::from(&amp;quot;hello world&amp;quot;)),
   |                  ^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums2.rs:21:18
   |
7  | enum Message {
   | ------------ variant or associated item `ChangeColor` not found for this enum
...
21 |         Message::ChangeColor(200, 255, 255),
   |                  ^^^^^^^^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `Quit` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums2.rs:22:18
   |
7  | enum Message {
   | ------------ variant or associated item `Quit` not found for this enum
...
22 |         Message::Quit,
   |                  ^^^^ variant or associated item not found in `Message`

error: aborting due to 4 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Errors are similar to last time as well, but we can see that there&#x27;s something different so let&#x27;s take a look at how to solve this problem.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;enums2-rs-solution&quot;&gt;&lt;code&gt;enums2.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;p&gt;We can see that in the &lt;code&gt;main()&lt;&#x2F;code&gt; there isn&#x27;t simply a name of a enum variant like &lt;code&gt;Move&lt;&#x2F;code&gt; or &lt;code&gt;Echo&lt;&#x2F;code&gt; but there&#x27;s data attached to it. This is because unlike in other languages, &lt;code&gt;enums&lt;&#x2F;code&gt; in Rust can have data like structs, strings, integers, in fact you can even include another &lt;code&gt;enum&lt;&#x2F;code&gt;. So in this case we solve this problem by adding the variant with the data that is expected. If we look at  &lt;code&gt;Move&lt;&#x2F;code&gt;  we add the &lt;code&gt;{ x: i32, y: i32}&lt;&#x2F;code&gt; struct information. Let&#x27;s do the same for the rest of the variants.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[derive(Debug)]
enum Message {
    Move { x: i32, y: i32 },
    Echo(String),
    ChangeColor(i32, i32, i32),
    Quit,
}
impl Message {
    fn call(&amp;amp;self) {
        println!(&amp;quot;{:?}&amp;quot;, self);
    }
}

fn main() {
    let messages = [
        Message::Move { x: 10, y: 30 },
        Message::Echo(String::from(&amp;quot;hello world&amp;quot;)),
        Message::ChangeColor(200, 255, 255),
        Message::Quit,
    ];

    for message in &amp;amp;messages {
        message.call();
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With that our code compiles, we get our expected output with the different types of data attached. On to our final &lt;code&gt;enum&lt;&#x2F;code&gt; exercise.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Move { x: 10, y: 30 }
Echo(&amp;quot;hello world&amp;quot;)
ChangeColor(200, 255, 255)
Quit

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;enums3-rs&quot;&gt;&lt;code&gt;enums3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; enums3.rs
&amp;#x2F;&amp;#x2F; Address all the TODOs to make the tests pass!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

enum Message {
    &amp;#x2F;&amp;#x2F; TODO: implement the message variant types based on their usage below
}

struct Point {
    x: u8,
    y: u8,
}

struct State {
    color: (u8, u8, u8),
    position: Point,
    quit: bool,
}

impl State {
    fn change_color(&amp;amp;mut self, color: (u8, u8, u8)) {
        self.color = color;
    }

    fn quit(&amp;amp;mut self) {
        self.quit = true;
    }

    fn echo(&amp;amp;self, s: String) {
        println!(&amp;quot;{}&amp;quot;, s);
    }

    fn move_position(&amp;amp;mut self, p: Point) {
        self.position = p;
    }

    fn process(&amp;amp;mut self, message: Message) {
        &amp;#x2F;&amp;#x2F; TODO: create a match expression to process the different message variants
        &amp;#x2F;&amp;#x2F; Remember: When passing a tuple as a function argument, you&amp;#x27;ll need extra parentheses: fn function((t, u, p, l, e))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_match_message_call() {
        let mut state = State {
            quit: false,
            position: Point { x: 0, y: 0 },
            color: (0, 0, 0),
        };
        state.process(Message::ChangeColor(255, 0, 255));
        state.process(Message::Echo(String::from(&amp;quot;hello world&amp;quot;)));
        state.process(Message::Move(Point { x: 10, y: 15 }));
        state.process(Message::Quit);

        assert_eq!(state.color, (255, 0, 255));
        assert_eq!(state.position.x, 10);
        assert_eq!(state.position.y, 15);
        assert_eq!(state.quit, true);
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this exercise we see 2 different locations in which we have to complete the code.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Is the &lt;code&gt;enum Message&lt;&#x2F;code&gt; which is completely empty, we&#x27;ve done this a few times so it shouldn&#x27;t be too difficult.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;enum Message {
    &amp;#x2F;&amp;#x2F; TODO: implement the message variant types based on their usage below
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;The next area is the &lt;code&gt;process()&lt;&#x2F;code&gt; function, inside of our &lt;code&gt;impl State&lt;&#x2F;code&gt; in which we get instructions on how to complete by using a &lt;code&gt;match&lt;&#x2F;code&gt; expression.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    fn process(&amp;amp;mut self, message: Message) {
        &amp;#x2F;&amp;#x2F; TODO: create a match expression to process the different message variants
        &amp;#x2F;&amp;#x2F; Remember: When passing a tuple as a function argument, you&amp;#x27;ll need extra parentheses: fn function((t, u, p, l, e))
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now, we take a look at the errors to see if there are any additional hints for completing our task&lt;&#x2F;p&gt;
&lt;h2 id=&quot;enums3-rs-errors&quot;&gt;&lt;code&gt;enums3.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;enums&amp;#x2F;enums3.rs failed! Please try again. Here is the output:
error[E0599]: no variant or associated item named `ChangeColor` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums3.rs:56:32
   |
7  | enum Message {
   | ------------ variant or associated item `ChangeColor` not found for this enum
...
56 |         state.process(Message::ChangeColor(255, 0, 255));
   |                                ^^^^^^^^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `Echo` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums3.rs:57:32
   |
7  | enum Message {
   | ------------ variant or associated item `Echo` not found for this enum
...
57 |         state.process(Message::Echo(String::from(&amp;quot;hello world&amp;quot;)));
   |                                ^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `Move` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums3.rs:58:32
   |
7  | enum Message {
   | ------------ variant or associated item `Move` not found for this enum
...
58 |         state.process(Message::Move(Point { x: 10, y: 15 }));
   |                                ^^^^ variant or associated item not found in `Message`

error[E0599]: no variant or associated item named `Quit` found for enum `Message` in the current scope
  --&amp;gt; exercises&amp;#x2F;enums&amp;#x2F;enums3.rs:59:32
   |
7  | enum Message {
   | ------------ variant or associated item `Quit` not found for this enum
...
59 |         state.process(Message::Quit);
   |                                ^^^^ variant or associated item not found in `Message`

error: aborting due to 4 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So far, it looks pretty straight forward once again, the compiler is just telling us about the missing variants, so let&#x27;s start filling out some code.&lt;&#x2F;p&gt;
&lt;p&gt;If we fill out our &lt;code&gt;Message enum&lt;&#x2F;code&gt; in a similar way we have been in the previous exercises, but instead of passing in the coordinates directly to &lt;code&gt;Move&lt;&#x2F;code&gt; we pass in &lt;code&gt;Point&lt;&#x2F;code&gt; because we see that&#x27;s what we need to match in tests below.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;enum Message {
    Move (Point),
    Echo(String),
    ChangeColor(u8, u8, u8),
    Quit,
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s take a look at our next code block that we need to fill in and the instructions.
We&#x27;re told to use a match expression and to remember that when passing a tuple as a function argument we need to add extra parentheses. Alright, noted.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    fn process(&amp;amp;mut self, message: Message) {
        &amp;#x2F;&amp;#x2F; TODO: create a match expression to process the different message variants
        &amp;#x2F;&amp;#x2F; Remember: When passing a tuple as a function argument, you&amp;#x27;ll need extra parentheses: fn function((t, u, p, l, e))
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So here we&#x27;re going to go through the solution step-by-step since it&#x27;s something that&#x27;s a little more than we&#x27;ve had with any of the previous &lt;code&gt;enum&lt;&#x2F;code&gt; exercises.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;process-function&quot;&gt;&lt;code&gt;process ()&lt;&#x2F;code&gt; function&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn process(&amp;amp;mut self, message: Message) {
        match message {
            Message::ChangeColor(r, g, b) =&amp;gt; self.change_color((r, g, b)),
            Message::Echo(s) =&amp;gt; self.echo(s),
            Message::Move(p) =&amp;gt; self.move_position(p),
            Message::Quit =&amp;gt; self.quit(),
        }
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol&gt;
&lt;li&gt;We see that the &lt;code&gt;process&lt;&#x2F;code&gt; function that takes a mutable reference to &lt;code&gt;self&lt;&#x2F;code&gt; (an instance of the &lt;code&gt;State&lt;&#x2F;code&gt; struct) and a &lt;code&gt;message&lt;&#x2F;code&gt; of type &lt;code&gt;Message&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;We use the &lt;code&gt;match&lt;&#x2F;code&gt; keyword to pattern match the &lt;code&gt;message&lt;&#x2F;code&gt; against different variants of the &lt;code&gt;Message&lt;&#x2F;code&gt; enum.&lt;&#x2F;li&gt;
&lt;li&gt;The first match arm &lt;code&gt;Message::ChangeColor(r, g, b) =&amp;gt; self.change_color((r, g, b))&lt;&#x2F;code&gt; matches the &lt;code&gt;Message::ChangeColor&lt;&#x2F;code&gt; variant. It deconstructs the tuple &lt;code&gt;(r, g, b)&lt;&#x2F;code&gt; by providing individual variables &lt;code&gt;r&lt;&#x2F;code&gt;, &lt;code&gt;g&lt;&#x2F;code&gt;, and &lt;code&gt;b&lt;&#x2F;code&gt; in the pattern. This allows us to directly access the values of &lt;code&gt;r&lt;&#x2F;code&gt;, &lt;code&gt;g&lt;&#x2F;code&gt;, and &lt;code&gt;b&lt;&#x2F;code&gt; in the &lt;code&gt;Message::ChangeColor&lt;&#x2F;code&gt; variant. Then, it calls the &lt;code&gt;change_color&lt;&#x2F;code&gt; method of &lt;code&gt;self&lt;&#x2F;code&gt; (an instance of &lt;code&gt;State&lt;&#x2F;code&gt;) passing the values &lt;code&gt;(r, g, b)&lt;&#x2F;code&gt; as arguments.&lt;&#x2F;li&gt;
&lt;li&gt;The second match arm &lt;code&gt;Message::Echo(s) =&amp;gt; self.echo(s)&lt;&#x2F;code&gt; matches the &lt;code&gt;Message::Echo&lt;&#x2F;code&gt; variant. It deconstructs the &lt;code&gt;String&lt;&#x2F;code&gt; value &lt;code&gt;s&lt;&#x2F;code&gt; from the &lt;code&gt;Message&lt;&#x2F;code&gt; enum variant and calls the &lt;code&gt;echo&lt;&#x2F;code&gt; method of &lt;code&gt;self&lt;&#x2F;code&gt; (an instance of &lt;code&gt;State&lt;&#x2F;code&gt;) passing &lt;code&gt;s&lt;&#x2F;code&gt; as an argument.&lt;&#x2F;li&gt;
&lt;li&gt;The third match arm &lt;code&gt;Message::Move(p) =&amp;gt; self.move_position(p)&lt;&#x2F;code&gt; matches the &lt;code&gt;Message::Move&lt;&#x2F;code&gt; variant. It deconstructs the &lt;code&gt;Point&lt;&#x2F;code&gt; value &lt;code&gt;p&lt;&#x2F;code&gt; from the &lt;code&gt;Message&lt;&#x2F;code&gt; enum variant and calls the &lt;code&gt;move_position&lt;&#x2F;code&gt; method of &lt;code&gt;self&lt;&#x2F;code&gt; (an instance of &lt;code&gt;State&lt;&#x2F;code&gt;) passing &lt;code&gt;p&lt;&#x2F;code&gt; as an argument.&lt;&#x2F;li&gt;
&lt;li&gt;The fourth match arm &lt;code&gt;Message::Quit =&amp;gt; self.quit()&lt;&#x2F;code&gt; matches the &lt;code&gt;Message::Quit&lt;&#x2F;code&gt; variant. It doesn&#x27;t need to deconstruct any values, so we simply call the &lt;code&gt;quit&lt;&#x2F;code&gt; method of &lt;code&gt;self&lt;&#x2F;code&gt; (an instance of &lt;code&gt;State&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;By using the &lt;code&gt;match&lt;&#x2F;code&gt; expression, we are able to handle different variants of the &lt;code&gt;Message&lt;&#x2F;code&gt; enum and perform the appropriate actions based on each variant.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;enums3-rs-solution&quot;&gt;&lt;code&gt;enums3.rs&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;p&gt;Here&#x27;s the full block of code for reference&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; enums3.rs
&amp;#x2F;&amp;#x2F; Address all the TODOs to make the tests pass!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

enum Message {
    Move(Point),
    Echo(String),
    ChangeColor(u8, u8, u8),
    Quit,
}

struct Point {
    x: u8,
    y: u8,
}

struct State {
    color: (u8, u8, u8),
    position: Point,
    quit: bool,
}

impl State {
    fn change_color(&amp;amp;mut self, color: (u8, u8, u8)) {
        self.color = color;
    }

    fn quit(&amp;amp;mut self) {
        self.quit = true;
    }

    fn echo(&amp;amp;self, s: String) {
        println!(&amp;quot;{}&amp;quot;, s);
    }

    fn move_position(&amp;amp;mut self, p: Point) {
        self.position = p;
    }

    fn process(&amp;amp;mut self, message: Message) {
        match message {
            Message::ChangeColor(r, g, b) =&amp;gt; self.change_color((r, g, b)),
            Message::Echo(s) =&amp;gt; self.echo(s),
            Message::Move(p) =&amp;gt; self.move_position(p),
            Message::Quit =&amp;gt; self.quit(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_match_message_call() {
        let mut state = State {
            quit: false,
            position: Point { x: 0, y: 0 },
            color: (0, 0, 0),
        };
        state.process(Message::ChangeColor(255, 0, 255));
        state.process(Message::Echo(String::from(&amp;quot;hello world&amp;quot;)));
        state.process(Message::Move(Point { x: 10, y: 15 }));
        state.process(Message::Quit);

        assert_eq!(state.color, (255, 0, 255));
        assert_eq!(state.position.x, 10);
        assert_eq!(state.position.y, 15);
        assert_eq!(state.quit, true);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this post, we gained insights into the usage of enums. We discovered how enums can be used to define different types of messages and handle them effectively. By exploring code examples, we learned how to:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Define enum variants and handle missing variants to ensure successful compilation.&lt;&#x2F;li&gt;
&lt;li&gt;Introduce enum variants with associated data for more complex scenarios.&lt;&#x2F;li&gt;
&lt;li&gt;Extend the concept by implementing methods and matching different message variants.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Overall, we discovered the flexibility and power of enums in Rust, enabling us to handle diverse message types and execute appropriate actions based on the variants.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>08 Rustlings Structs</title>
          <pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/08-rustlings-structs/</link>
          <guid>https://desmodrone.github.io/posts/08-rustlings-structs/</guid>
          <description>&lt;p&gt;From the ReadMe:
Rust has three struct types: a classic C struct, a tuple struct, and a unit struct.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch05-01-defining-structs.html&quot;&gt;Structures&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch05-03-method-syntax.html&quot;&gt;Method Syntax&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;structs-in-rust&quot;&gt;Structs in Rust&lt;&#x2F;h2&gt;
&lt;p&gt;In Rust, structs are versatile containers that bring together multiple values into a cohesive unit. They offer three types: classic C structs, tuple structs, and unit structs.&lt;&#x2F;p&gt;
&lt;p&gt;Classic C structs allow you to define named fields, providing an intuitive way to organize and access related data. Tuple structs, on the other hand, resemble tuples, with fields accessed through indexing rather than names. Lastly, unit structs serve as simple markers or placeholders without any fields.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s take a quick dive into the types of structs:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Classic C Structs:&lt;&#x2F;strong&gt; These are essentially collections with named fields. They are ideal for larger and more complex data structures where each piece of data has a meaningful label.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Tuple Structs:&lt;&#x2F;strong&gt; These are a kind of middle ground between tuples and classic structs. They are useful when you want to give a tuple a name for type checking or to better signify its purpose, but you don&#x27;t necessarily need to name each field.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Unit Structs:&lt;&#x2F;strong&gt; These are used in cases where a struct doesn&#x27;t need to have any data associated with it. For example, they can be used to implement traits on some type, or as markers or flags.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;With structs, you have the power to create custom data structures that suit your needs, enhancing code organization and efficiency. Explore the provided links to delve deeper into the world of structs in Rust and unlock their potential for your projects.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look at our first exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs1-rs&quot;&gt;&lt;code&gt;Structs1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; structs1.rs
    &amp;#x2F;&amp;#x2F; Address all the TODOs to make the tests pass!
    &amp;#x2F;&amp;#x2F; Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.

    &amp;#x2F;&amp;#x2F; I AM NOT DONE

    struct ColorClassicStruct {
        &amp;#x2F;&amp;#x2F; TODO: Something goes here
    }

    struct ColorTupleStruct(&amp;#x2F;* TODO: Something goes here *&amp;#x2F;);

    #[derive(Debug)]
    struct UnitLikeStruct;

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn classic_c_structs() {
            &amp;#x2F;&amp;#x2F; TODO: Instantiate a classic c struct!
            &amp;#x2F;&amp;#x2F; let green =

            assert_eq!(green.red, 0);
            assert_eq!(green.green, 255);
            assert_eq!(green.blue, 0);
        }

        #[test]
        fn tuple_structs() {
            &amp;#x2F;&amp;#x2F; TODO: Instantiate a tuple struct!
            &amp;#x2F;&amp;#x2F; let green =

            assert_eq!(green.0, 0);
            assert_eq!(green.1, 255);
            assert_eq!(green.2, 0);
        }

        #[test]
        fn unit_structs() {
            &amp;#x2F;&amp;#x2F; TODO: Instantiate a unit-like struct!
            &amp;#x2F;&amp;#x2F; let unit_like_struct =
            let message = format!(&amp;quot;{:?}s are fun!&amp;quot;, unit_like_struct);

            assert_eq!(message, &amp;quot;UnitLikeStructs are fun!&amp;quot;);
        }
    }

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So here we&#x27;re getting clear instructions on what to do. We need to implement different types of structs in each &lt;code&gt;&#x2F;&#x2F;TODO&lt;&#x2F;code&gt; section. For completeness here are our errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs1-rs-errors&quot;&gt;&lt;code&gt;Structs1.rs&lt;&#x2F;code&gt;  errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;structs&amp;#x2F;structs1.rs failed! Please try again. Here is the output:
error[E0425]: cannot find value `green` in this scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:25:20
   |
25 |         assert_eq!(green.red, 0);
   |                    ^^^^^ not found in this scope

error[E0425]: cannot find value `green` in this scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:26:20
   |
26 |         assert_eq!(green.green, 255);
   |                    ^^^^^ not found in this scope

error[E0425]: cannot find value `green` in this scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:27:20
   |
27 |         assert_eq!(green.blue, 0);
   |                    ^^^^^ not found in this scope

error[E0425]: cannot find value `green` in this scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:35:20
   |
35 |         assert_eq!(green.0, 0);
   |                    ^^^^^ not found in this scope

error[E0425]: cannot find value `green` in this scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:36:20
   |
36 |         assert_eq!(green.1, 255);
   |                    ^^^^^ not found in this scope

error[E0425]: cannot find value `green` in this scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:37:20
   |
37 |         assert_eq!(green.2, 0);
   |                    ^^^^^ not found in this scope

error[E0425]: cannot find value `unit_like_struct` in this scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:44:49
   |
14 | struct UnitLikeStruct;
   | ---------------------- similarly named unit struct `UnitLikeStruct` defined here
...
44 |         let message = format!(&amp;quot;{:?}s are fun!&amp;quot;, unit_like_struct);
   |                                                 ^^^^^^^^^^^^^^^^ help: a unit struct with a similar name exists: `UnitLikeStruct`

warning: unused import: `super::*`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs1.rs:18:9
   |
18 |     use super::*;
   |         ^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

error: aborting due to 7 previous errors; 1 warning emitted
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;re getting 7 different errors and it looks like most of them are related to the fact that we are missing our structs so they &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; calls are failing. So let&#x27;s try and solve this.&lt;&#x2F;p&gt;
&lt;p&gt;Notice that the errors reported here are not solely due to missing structs but also due to missing variable declarations. For example, the variables &lt;code&gt;green&lt;&#x2F;code&gt; and &lt;code&gt;unit_like_struct&lt;&#x2F;code&gt; are used in the test assertions but haven&#x27;t been defined yet in the tests. This will be addressed in the following sections as we instantiate these variables along with defining and instantiating the corresponding structs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;defining-our-structs&quot;&gt;Defining our Structs&lt;&#x2F;h2&gt;
&lt;p&gt;Starting from the top of our code we see our first &lt;code&gt;TODO&#x27;s&lt;&#x2F;code&gt; in comments.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;   struct ColorClassicStruct {
        &amp;#x2F;&amp;#x2F; TODO: Something goes here
    }

    struct ColorTupleStruct(&amp;#x2F;* TODO: Something goes here *&amp;#x2F;);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have 2 different styles of structs that we need to create a &amp;quot;classic&amp;quot; and &amp;quot;tuple&amp;quot; types struct.  We fill out the structs using their usual structure and we get an indication of what is needed by looking at the &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; listed in each section. We can see that in the &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; we have values that could fit and &lt;code&gt;i32&lt;&#x2F;code&gt;&#x27;s since we see the max value is &lt;code&gt;255&lt;&#x2F;code&gt; we&#x27;ll use &lt;code&gt;i32&lt;&#x2F;code&gt;s as it&#x27;s the default value in Rust.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct ColorClassicStruct {
    red: i32,
    green: i32,
    blue: i32,
}
&amp;#x2F;&amp;#x2F; from the `assert_eq!` in `classic_c_structs` function
    &amp;#x2F;&amp;#x2F; assert_eq!(green.red, 0);
    &amp;#x2F;&amp;#x2F; assert_eq!(green.green, 255);
    &amp;#x2F;&amp;#x2F; assert_eq!(green.blue, 0);


struct ColorTupleStruct(i32, i32, i32);

&amp;#x2F;&amp;#x2F; from the `assert_eq!` in the `tuple_structs` function
    &amp;#x2F;&amp;#x2F; assert_eq!(green.0, 0);
    &amp;#x2F;&amp;#x2F; assert_eq!(green.1, 255);
    &amp;#x2F;&amp;#x2F; assert_eq!(green.2, 0);

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;ll do the same for the &lt;code&gt;ColorTupleStruct&lt;&#x2F;code&gt; getting hints as to how we need to define the Tuple struct with &lt;code&gt;(i32, i32, i32)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;instantiating-our-classic-struct&quot;&gt;Instantiating our Classic Struct&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we&#x27;ve defined our structs we need to create an new instance of our structs where we specify concrete values for each of the fields. We create instances of our struct by stating the name of the struct we can see that in our example we have this so far.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;   fn classic_c_structs() {
            &amp;#x2F;&amp;#x2F; TODO: Instantiate a classic c struct!
            &amp;#x2F;&amp;#x2F; let green =

            assert_eq!(green.red, 0);
            assert_eq!(green.green, 255);
            assert_eq!(green.blue, 0);
        }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So we&#x27;ll start by removing the comment slashes on &lt;code&gt;let green = &lt;&#x2F;code&gt; and fill out the rest with our values, again taking hints from the &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; lines we see that we should have values of &lt;code&gt;0, 255, 0&lt;&#x2F;code&gt; so let&#x27;s add that information into our &lt;code&gt;classic_c_structs()&lt;&#x2F;code&gt; function. It should like the code below:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    fn classic_c_structs() {
        &amp;#x2F;&amp;#x2F; TODO: Instantiate a classic c struct!
        let green = ColorClassicStruct {
            red: 0,
            green: 255,
            blue: 0,
        };
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;instantiating-our-tuple-struct&quot;&gt;Instantiating our Tuple Struct&lt;&#x2F;h2&gt;
&lt;p&gt;We see a similar set up for our Tuple struct with the code below. We have our &lt;code&gt;let gree =&lt;&#x2F;code&gt; commented out with a hint as to what the values should be by looking at our &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; macros&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;        fn tuple_structs() {
            &amp;#x2F;&amp;#x2F; TODO: Instantiate a tuple struct!
            &amp;#x2F;&amp;#x2F; let green =

            assert_eq!(green.0, 0);
            assert_eq!(green.1, 255);
            assert_eq!(green.2, 0);
        }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Remembering that Tuple structs have a different type of structure as we created &lt;code&gt;struct ColorTupleStruct(i32, i32, i32)&lt;&#x2F;code&gt;, we can instantiate our tuple struct in the following way:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn tuple_structs() {
        &amp;#x2F;&amp;#x2F; TODO: Instantiate a tuple struct!
        let green = ColorTupleStruct(0, 255, 0);

        assert_eq!(green.0, 0);
        assert_eq!(green.1, 255);
        assert_eq!(green.2, 0);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again taking hints from the values that we see in the &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; macro&#x27;s&lt;&#x2F;p&gt;
&lt;h2 id=&quot;instantiating-our-unit-like-structs&quot;&gt;Instantiating our Unit-Like Structs&lt;&#x2F;h2&gt;
&lt;p&gt;We have our final struct left to instantiate which if we recall from reading the The Rust Programming Language book, they are structs that have any fields. So looking at our unfinished code we see this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;        fn unit_structs() {
            &amp;#x2F;&amp;#x2F; TODO: Instantiate a unit-like struct!
            &amp;#x2F;&amp;#x2F; let unit_like_struct =
            let message = format!(&amp;quot;{:?}s are fun!&amp;quot;, unit_like_struct);

            assert_eq!(message, &amp;quot;UnitLikeStructs are fun!&amp;quot;);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So, as we don&#x27;t have any fields and hence no data stored in them we can simply finish our code like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn unit_structs() {
        &amp;#x2F;&amp;#x2F; TODO: Instantiate a unit-like struct!
        let unit_like_struct = UnitLikeStruct;
        let message = format!(&amp;quot;{:?}s are fun!&amp;quot;, unit_like_struct);

        assert_eq!(message, &amp;quot;UnitLikeStructs are fun!&amp;quot;);
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That should do the trick, let&#x27;s see if our code complies. It does!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs1-rs-solution&quot;&gt;&lt;code&gt;Structs1.rs&lt;&#x2F;code&gt;  Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
struct ColorClassicStruct {
    red: i32,
    green: i32,
    blue: i32,
}

struct ColorTupleStruct(i32, i32, i32);

#[derive(Debug)]
struct UnitLikeStruct;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn classic_c_structs() {
        &amp;#x2F;&amp;#x2F; TODO: Instantiate a classic c struct!
        let green = ColorClassicStruct {
            red: 0,
            green: 255,
            blue: 0,
        };

        assert_eq!(green.red, 0);
        assert_eq!(green.green, 255);
        assert_eq!(green.blue, 0);
    }

    #[test]
    fn tuple_structs() {
        &amp;#x2F;&amp;#x2F; TODO: Instantiate a tuple struct!
        let green = ColorTupleStruct(0, 255, 0);

        assert_eq!(green.0, 0);
        assert_eq!(green.1, 255);
        assert_eq!(green.2, 0);
    }

    #[test]
    fn unit_structs() {
        &amp;#x2F;&amp;#x2F; TODO: Instantiate a unit-like struct!
        let unit_like_struct = UnitLikeStruct;
        let message = format!(&amp;quot;{:?}s are fun!&amp;quot;, unit_like_struct);

        assert_eq!(message, &amp;quot;UnitLikeStructs are fun!&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our code compiles and we&#x27;ve finished and instantiated 3 different types of structs, our printout confirms this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;✅ Successfully tested exercises&amp;#x2F;structs&amp;#x2F;structs1.rs!

🎉 🎉  The code is compiling, and the tests pass! 🎉 🎉
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;On to the next one!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs2-rs&quot;&gt;&lt;code&gt;structs2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; structs2.rs
&amp;#x2F;&amp;#x2F; Address all the TODOs to make the tests pass!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[derive(Debug)]
struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}

fn create_order_template() -&amp;gt; Order {
    Order {
        name: String::from(&amp;quot;Bob&amp;quot;),
        year: 2019,
        made_by_phone: false,
        made_by_mobile: false,
        made_by_email: true,
        item_number: 123,
        count: 0,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();
        &amp;#x2F;&amp;#x2F; TODO: Create your own order using the update syntax and template above!
        &amp;#x2F;&amp;#x2F; let your_order =
        assert_eq!(your_order.name, &amp;quot;Hacker in Rust&amp;quot;);
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this code example we have instructions to address all the &lt;code&gt;&#x2F;&#x2F;TODO&#x27;s&lt;&#x2F;code&gt; which we can see that we only have one at the bottom of our code in our &lt;code&gt;tests&lt;&#x2F;code&gt;.
As always let&#x27;s look at our errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs2-rs-errors&quot;&gt;&lt;code&gt;structs2.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;structs&amp;#x2F;structs2.rs failed! Please try again. Here is the output:
error[E0609]: no field `name` on type `fn() {tests::your_order}`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs2.rs:39:31
   |
39 |         assert_eq!(your_order.name, &amp;quot;Hacker in Rust&amp;quot;);
   |                               ^^^^

error[E0609]: no field `year` on type `fn() {tests::your_order}`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs2.rs:40:31
   |
40 |         assert_eq!(your_order.year, order_template.year);
   |                               ^^^^

error[E0609]: no field `made_by_phone` on type `fn() {tests::your_order}`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs2.rs:41:31
   |
41 |         assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
   |                               ^^^^^^^^^^^^^

error[E0609]: no field `made_by_mobile` on type `fn() {tests::your_order}`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs2.rs:42:31
   |
42 |         assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
   |                               ^^^^^^^^^^^^^^

error[E0609]: no field `made_by_email` on type `fn() {tests::your_order}`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs2.rs:43:31
   |
43 |         assert_eq!(your_order.made_by_email, order_template.made_by_email);
   |                               ^^^^^^^^^^^^^

error[E0609]: no field `item_number` on type `fn() {tests::your_order}`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs2.rs:44:31
   |
44 |         assert_eq!(your_order.item_number, order_template.item_number);
   |                               ^^^^^^^^^^^

error[E0609]: no field `count` on type `fn() {tests::your_order}`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs2.rs:45:31
   |
45 |         assert_eq!(your_order.count, 1);
   |                               ^^^^^

error: aborting due to 7 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have a total of 7 errors all created by our missing struct instantiation. So, let&#x27;s get it to it, we&#x27;ll start from the top.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;instantiating-your-order&quot;&gt;Instantiating &lt;code&gt;your_order&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;If we look  at our first error we get a major hint as to what the compiler expects to see: &lt;code&gt; assert_eq!(your_order.name, &amp;quot;Hacker in Rust&amp;quot;)&lt;&#x2F;code&gt; so if we take a look at our sample code and build our &lt;code&gt;Order&lt;&#x2F;code&gt; in the same way as in the &lt;code&gt;create_order_template&lt;&#x2F;code&gt; function we should have a great start for what we need to do.&lt;&#x2F;p&gt;
&lt;p&gt;If we use our &lt;code&gt;Order&lt;&#x2F;code&gt; struct as a guide we can start entering the values for each field.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;for example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn your_order() {
        let order_template = create_order_template();
        &amp;#x2F;&amp;#x2F; TODO: Create your own order using the update syntax and template above!
        let your_order = Order {
            name: String::from(&amp;quot;Hacker in Rust&amp;quot;),
            year: u32,
            made_by_phone: bool,
            made_by_mobile: bool,
            made_by_email: bool,
            item_number: u32,
            count: u32,
        };
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again we see what is expected by looking at our &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; macro, so following this format it should be pretty easy to understand what each field should be.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;        assert_eq!(your_order.name, &amp;quot;Hacker in Rust&amp;quot;); &amp;#x2F;&amp;#x2F; String
        assert_eq!(your_order.year, order_template.year); &amp;#x2F;&amp;#x2F; u32 from the `oder_template.year`
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone); &amp;#x2F;&amp;#x2F; bool
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile); &amp;#x2F;&amp;#x2F; bool
        assert_eq!(your_order.made_by_email, order_template.made_by_email); &amp;#x2F;&amp;#x2F; bool
        assert_eq!(your_order.item_number, order_template.item_number); &amp;#x2F;&amp;#x2F; u32 from `item_number`
        assert_eq!(your_order.count, 1); &amp;#x2F;&amp;#x2F; u32 defined here as `1`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So there we go now all we need to is fill out the rest of the values and it should look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let your_order = Order {
            name: String::from(&amp;quot;Hacker in Rust&amp;quot;),
            year: 2019,
            made_by_phone: false,
            made_by_mobile: false,
            made_by_email: true,
            item_number: 123,
            count: 1,
        };
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;structs2-rs-solution&quot;&gt;&lt;code&gt;structs2.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[derive(Debug)]
struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}

fn create_order_template() -&amp;gt; Order {
    Order {
        name: String::from(&amp;quot;Bob&amp;quot;),
        year: 2019,
        made_by_phone: false,
        made_by_mobile: false,
        made_by_email: true,
        item_number: 123,
        count: 0,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();
        &amp;#x2F;&amp;#x2F; TODO: Create your own order using the update syntax and template above!
        let your_order = Order {
            name: String::from(&amp;quot;Hacker in Rust&amp;quot;),
            year: 2019,
            made_by_phone: false,
            made_by_mobile: false,
            made_by_email: true,
            item_number: 123,
            count: 1,
        };
        assert_eq!(your_order.name, &amp;quot;Hacker in Rust&amp;quot;);
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;✅ Successfully tested exercises&amp;#x2F;structs&amp;#x2F;structs2.rs!

🎉 🎉  The code is compiling, and the tests pass! 🎉 🎉
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;understanding-rust-struct-update-syntax&quot;&gt;Understanding Rust Struct Update Syntax&lt;&#x2F;h2&gt;
&lt;p&gt;Before we move on to the next exercise, it&#x27;s worth mentioning a Rust feature that could be beneficial here - the struct update syntax. It allows you to create a new instance of a struct, and selectively update some or all fields. This is especially useful when you have a template or default struct that you want to use as a base for your new struct.&lt;&#x2F;p&gt;
&lt;p&gt;To do so, you use &lt;code&gt;..&lt;&#x2F;code&gt; followed by the instance name. It should look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let your_order = Order {
    name: String::from(&amp;quot;Hacker in Rust&amp;quot;),
    count: 1,
    ..order_template
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This code creates a new &lt;code&gt;Order&lt;&#x2F;code&gt; that is the same as &lt;code&gt;order_template&lt;&#x2F;code&gt;, except &lt;code&gt;name&lt;&#x2F;code&gt; is &amp;quot;Hacker in Rust&amp;quot; and &lt;code&gt;count&lt;&#x2F;code&gt; is 1.&lt;&#x2F;p&gt;
&lt;p&gt;We can use this syntax to make our code more efficient and maintain the logic of using a template.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs2-rs-solution-with-update-syntax&quot;&gt;&lt;code&gt;structs2.rs&lt;&#x2F;code&gt; Solution with Update Syntax&lt;&#x2F;h2&gt;
&lt;p&gt;So, with struct update syntax, the solution becomes:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();
        let your_order = Order {
            name: String::from(&amp;quot;Hacker in Rust&amp;quot;),
            count: 1,
            ..order_template
        };
        assert_eq!(your_order.name, &amp;quot;Hacker in Rust&amp;quot;);
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The test function &lt;code&gt;your_order()&lt;&#x2F;code&gt; now uses the update syntax to create &lt;code&gt;your_order&lt;&#x2F;code&gt; from &lt;code&gt;order_template&lt;&#x2F;code&gt;, changing only the &lt;code&gt;name&lt;&#x2F;code&gt; and &lt;code&gt;count&lt;&#x2F;code&gt; fields, and leaving the rest as in &lt;code&gt;order_template&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This is just an alternate way of solving the problem and could be particularly useful if &lt;code&gt;Order&lt;&#x2F;code&gt; had many more fields that remained the same between &lt;code&gt;order_template&lt;&#x2F;code&gt; and &lt;code&gt;your_order&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;On to &lt;code&gt;structs3.rs&lt;&#x2F;code&gt;!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs3-rs&quot;&gt;&lt;code&gt;structs3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; structs3.rs
&amp;#x2F;&amp;#x2F; Structs contain data, but can also have logic. In this exercise we have
&amp;#x2F;&amp;#x2F; defined the Package struct and we want to test some logic attached to it.
&amp;#x2F;&amp;#x2F; Make the code compile and the tests pass!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[derive(Debug)]
struct Package {
    sender_country: String,
    recipient_country: String,
    weight_in_grams: i32,
}

impl Package {
    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -&amp;gt; Package {
        if weight_in_grams &amp;lt;= 0 {
            panic!(&amp;quot;Can not ship a weightless package.&amp;quot;)
        } else {
            Package {
                sender_country,
                recipient_country,
                weight_in_grams,
            }
        }
    }

    fn is_international(&amp;amp;self) -&amp;gt; ??? {
        &amp;#x2F;&amp;#x2F; Something goes here...
    }

    fn get_fees(&amp;amp;self, cents_per_gram: i32) -&amp;gt; ??? {
        &amp;#x2F;&amp;#x2F; Something goes here...
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn fail_creating_weightless_package() {
        let sender_country = String::from(&amp;quot;Spain&amp;quot;);
        let recipient_country = String::from(&amp;quot;Austria&amp;quot;);

        Package::new(sender_country, recipient_country, -2210);
    }

    #[test]
    fn create_international_package() {
        let sender_country = String::from(&amp;quot;Spain&amp;quot;);
        let recipient_country = String::from(&amp;quot;Russia&amp;quot;);

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(package.is_international());
    }

    #[test]
    fn create_local_package() {
        let sender_country = String::from(&amp;quot;Canada&amp;quot;);
        let recipient_country = sender_country.clone();

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(!package.is_international());
    }

    #[test]
    fn calculate_transport_fees() {
        let sender_country = String::from(&amp;quot;Spain&amp;quot;);
        let recipient_country = String::from(&amp;quot;Spain&amp;quot;);

        let cents_per_gram = 3;

        let package = Package::new(sender_country, recipient_country, 1500);

        assert_eq!(package.get_fees(cents_per_gram), 4500);
        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright this is a longer piece of code to go through but we see that there is essentially 2 areas that we need to fill out, before we look at that let&#x27;s look at the errors.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;structs&amp;#x2F;structs3.rs failed! Please try again. Here is the output:
error: expected identifier, found `{`
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs3.rs:29:39
   |
16 | impl Package {
   |              - while parsing this item list starting here
...
29 |     fn is_international(&amp;amp;self) -&amp;gt; ??? {
   |                                       ^ expected identifier
...
36 | }
   | - the item list ends here

error[E0599]: no method named `is_international` found for struct `Package` in the current scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs3.rs:58:25
   |
10 | struct Package {
   | -------------- method `is_international` not found for this struct
...
58 |         assert!(package.is_international());
   |                         ^^^^^^^^^^^^^^^^ method not found in `Package`

error[E0599]: no method named `is_international` found for struct `Package` in the current scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs3.rs:68:26
   |
10 | struct Package {
   | -------------- method `is_international` not found for this struct
...
68 |         assert!(!package.is_international());
   |                          ^^^^^^^^^^^^^^^^ method not found in `Package`

error[E0599]: no method named `get_fees` found for struct `Package` in the current scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs3.rs:80:28
   |
10 | struct Package {
   | -------------- method `get_fees` not found for this struct
...
80 |         assert_eq!(package.get_fees(cents_per_gram), 4500);
   |                            ^^^^^^^^ method not found in `Package`

error[E0599]: no method named `get_fees` found for struct `Package` in the current scope
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs3.rs:81:28
   |
10 | struct Package {
   | -------------- method `get_fees` not found for this struct
...
81 |         assert_eq!(package.get_fees(cents_per_gram * 2), 9000);
   |                            ^^^^^^^^ method not found in `Package`

error: aborting due to 5 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright we&#x27;re seeing errors due to the missing code blocks and also the usual &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; macros that are expecting something that is not there. So let&#x27;s get to work!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;defining-return-values&quot;&gt;Defining Return Values&lt;&#x2F;h2&gt;
&lt;p&gt;First we define the return values &lt;code&gt;String&lt;&#x2F;code&gt; and an &lt;code&gt;i32&lt;&#x2F;code&gt;, instead of the &lt;code&gt;???&lt;&#x2F;code&gt; we previously had.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    fn is_international(&amp;amp;self) -&amp;gt; String {
        &amp;#x2F;&amp;#x2F; Something goes here...
    }

    fn get_fees(&amp;amp;self, cents_per_gram: i32) -&amp;gt; i32 {
        &amp;#x2F;&amp;#x2F; Something goes here...
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We still get error&#x27;s here when we save but they&#x27;re different essentially telling us that this function &lt;code&gt;has no tail&lt;&#x2F;code&gt; or essentially isn&#x27;t returning anything as we have defined it in the signature so of course we have to fix that. Here are the new errors:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;structs&amp;#x2F;structs3.rs failed! Please try again. Here is the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs3.rs:29:35
   |
29 |     fn is_international(&amp;amp;self) -&amp;gt; String {
   |        ----------------           ^^^^^^ expected struct `String`, found `()`
   |        |
   |        implicitly returns `()` as its body has no tail or `return` expression

error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;structs&amp;#x2F;structs3.rs:33:48
   |
33 |     fn get_fees(&amp;amp;self, cents_per_gram: i32) -&amp;gt; i32 {
   |        --------                                ^^^ expected `i32`, found `()`
   |        |
   |        implicitly returns `()` as its body has no tail or `return` expression
   |
help: consider returning the local binding `cents_per_gram`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;is-international-function&quot;&gt;&lt;code&gt;is_international&lt;&#x2F;code&gt; function&lt;&#x2F;h2&gt;
&lt;p&gt;So let&#x27;s take breakdown the &lt;code&gt;is_interational&lt;&#x2F;code&gt; function and see what it is that we need to do inside of here.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;function-declaration&quot;&gt;Function declaration:&lt;&#x2F;h3&gt;
&lt;p&gt;The line &lt;code&gt;fn is_international(&amp;amp;self) -&amp;gt; bool&lt;&#x2F;code&gt; declares a function named &lt;code&gt;is_international&lt;&#x2F;code&gt;. The &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; argument means that this function is a method, which operates on an instance of the &lt;code&gt;Package&lt;&#x2F;code&gt; struct.&lt;&#x2F;p&gt;
&lt;p&gt;This function will return a &lt;code&gt;bool&lt;&#x2F;code&gt; type, which is a boolean that can be either &lt;code&gt;true&lt;&#x2F;code&gt; or &lt;code&gt;false&lt;&#x2F;code&gt; as we have already defined earlier.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;function-body&quot;&gt;Function body:&lt;&#x2F;h3&gt;
&lt;p&gt;Inside the function, we add &lt;code&gt;self.sender_country != self.recipient_country&lt;&#x2F;code&gt; which is the basic logic that determines whether a package is international.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;self.sender_country&lt;&#x2F;code&gt; accesses the &lt;code&gt;sender_country&lt;&#x2F;code&gt; field  of the current &lt;code&gt;Package&lt;&#x2F;code&gt; instance, and &lt;code&gt;self.recipient_country&lt;&#x2F;code&gt; accesses the &lt;code&gt;recipient_country&lt;&#x2F;code&gt; field.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;!=&lt;&#x2F;code&gt; is the inequality operator in Rust, which checks if the two values on its left and right are not equal. In this case, it&#x27;s comparing the &lt;code&gt;sender_country&lt;&#x2F;code&gt; and &lt;code&gt;recipient_country&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;return-value&quot;&gt;Return value:&lt;&#x2F;h3&gt;
&lt;p&gt;If &lt;code&gt;sender_country&lt;&#x2F;code&gt; and &lt;code&gt;recipient_country&lt;&#x2F;code&gt; are not equal, the expression evaluates to &lt;code&gt;true&lt;&#x2F;code&gt;, meaning that the package is international. If they are equal, the expression evaluates to &lt;code&gt;false&lt;&#x2F;code&gt;, meaning that the package is not international.&lt;&#x2F;p&gt;
&lt;p&gt;This boolean value is what the function returns, because it&#x27;s the last (and in this case, the only) expression in the function. In Rust, the last expression in a function is implicitly returned.&lt;&#x2F;p&gt;
&lt;p&gt;In sum, &lt;code&gt;is_international&lt;&#x2F;code&gt; is a method that checks if the sender and recipient countries of a package are different. If they are, the package is international, and the method returns &lt;code&gt;true&lt;&#x2F;code&gt;. If they&#x27;re the same, the package is not international, and the method returns &lt;code&gt;false&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;get-fees-function&quot;&gt;&lt;code&gt;get_fees&lt;&#x2F;code&gt; function&lt;&#x2F;h3&gt;
&lt;p&gt;Now let&#x27;s break down the &lt;code&gt;get_fees&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;function-declaration-1&quot;&gt;Function declaration&lt;&#x2F;h3&gt;
&lt;p&gt;The line &lt;code&gt;fn get_fees(&amp;amp;self, cents_per_gram: i32) -&amp;gt; i32&lt;&#x2F;code&gt; declares a function named &lt;code&gt;get_fees&lt;&#x2F;code&gt;. The &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; argument means that this function is a method, which operates on an instance of the &lt;code&gt;Package&lt;&#x2F;code&gt; struct.&lt;&#x2F;p&gt;
&lt;p&gt;In addition to &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt;, the function takes another argument, &lt;code&gt;cents_per_gram&lt;&#x2F;code&gt;, which represents the cost per gram to ship a package.
The &lt;code&gt;-&amp;gt; i32&lt;&#x2F;code&gt; means this function will return an integer (&lt;code&gt;i32&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;function-body-1&quot;&gt;Function body:&lt;&#x2F;h3&gt;
&lt;p&gt;Inside the function, &lt;code&gt;cents_per_gram * self.weight_in_grams&lt;&#x2F;code&gt; is the logic used to calculate the shipping fee for a package.
&lt;code&gt;self.weight_in_grams&lt;&#x2F;code&gt; accesses the &lt;code&gt;weight_in_grams&lt;&#x2F;code&gt; field of the current &lt;code&gt;Package&lt;&#x2F;code&gt; instance.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;*&lt;&#x2F;code&gt; is the multiplication operator in Rust, which multiplies &lt;code&gt;cents_per_gram&lt;&#x2F;code&gt; (the cost per gram to ship a package) with &lt;code&gt;self.weight_in_grams&lt;&#x2F;code&gt; (the weight of the package).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;return-value-1&quot;&gt;Return Value&lt;&#x2F;h3&gt;
&lt;p&gt;The multiplication gives the total cost to ship the package. Since &lt;code&gt;cents_per_gram&lt;&#x2F;code&gt; is in cents, and &lt;code&gt;weight_in_grams&lt;&#x2F;code&gt; is in grams, the result is in cents too.
This integer value is what the function returns. As in the &lt;code&gt;is_international&lt;&#x2F;code&gt; function, the last expression in the function is implicitly returned in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;In summary, &lt;code&gt;get_fees&lt;&#x2F;code&gt; is a method that calculates and returns the shipping fee for a package based on the cost per gram and the weight of the package.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary-of-methods&quot;&gt;Summary of methods&lt;&#x2F;h2&gt;
&lt;p&gt;Rust is a language that uses something called &amp;quot;methods&amp;quot; to perform actions on data. In our example, &lt;code&gt;Package&lt;&#x2F;code&gt; is a collection of data (the sender and recipient countries, and the weight), and the functions &lt;code&gt;is_international&lt;&#x2F;code&gt; and &lt;code&gt;get_fees&lt;&#x2F;code&gt; are methods that do something with this data.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; is a reference to the current object - the &amp;quot;package&amp;quot; we&#x27;re working with at the moment. It&#x27;s like saying &amp;quot;this package&amp;quot; or &amp;quot;the package I&#x27;m currently handling&amp;quot;. It&#x27;s used because the method is working on the data inside the current &lt;code&gt;Package&lt;&#x2F;code&gt; object.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;is_international(&amp;amp;self) -&amp;gt; bool&lt;&#x2F;code&gt; is a method that checks if the package is international. It does this by comparing the sender and recipient countries: if they&#x27;re different, it means the package is international, and the method returns &lt;code&gt;true&lt;&#x2F;code&gt;. If they&#x27;re the same, the package is not international, and the method returns &lt;code&gt;false&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;get_fees(&amp;amp;self, cents_per_gram: i32) -&amp;gt; i32&lt;&#x2F;code&gt; is a method that calculates the fees to ship the package. It does this by multiplying the weight of the package (&lt;code&gt;self.weight_in_grams&lt;&#x2F;code&gt;) by the cost per gram (&lt;code&gt;cents_per_gram&lt;&#x2F;code&gt;). The result is the total fee, which is returned by the method.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;So, in short: &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; means &amp;quot;this package&amp;quot;, &lt;code&gt;is_international&lt;&#x2F;code&gt; checks if the sender and recipient countries are different, and &lt;code&gt;get_fees&lt;&#x2F;code&gt; calculates the shipping fees based on the weight of the package and the cost per gram.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Okay, this was a long one, we dove into the basics of Structs in Rust and how they can carry both data and logic.
Through this exploration, we gained a better understanding of Rust&#x27;s data structures, method definitions and syntax. Moreover, we tackled a practical example with tests, giving us a real world scenario to apply our knowledge.&lt;&#x2F;p&gt;
&lt;p&gt;Remember, Rust&#x27;s system of Structs and methods allows you to write code that is not only efficient but also safe and readable. This is particularly important in systems programming and other contexts where performance is crucial. With this knowledge, you&#x27;ll be able to tackle more complex Rust projects and continue to build on your programming skills.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>07 Rustlings Move Semantics Part 2</title>
          <pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/07-rustlings-move-semantics2/</link>
          <guid>https://desmodrone.github.io/posts/07-rustlings-move-semantics2/</guid>
          <description>&lt;p&gt;From the Rustlings ReadMe:
These exercises are adapted from &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pnkfelix&quot;&gt;pnkfelix&lt;&#x2F;a&gt;&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;pnkfelix.github.io&#x2F;rust-examples-icfp2014&#x2F;&quot;&gt;Rust Tutorial&lt;&#x2F;a&gt; -- Thank you Felix!!!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;p&gt;For this section, the book links are especially important.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-01-what-is-ownership.html&quot;&gt;Ownership&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-02-references-and-borrowing.html&quot;&gt;Reference and borrowing&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;move-semantics-part-2&quot;&gt;Move Semantics Part 2&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;ve already covered the first three exercises of &lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;07-rustlings-move-semantics1&#x2F;&quot;&gt;Move Semantics&lt;&#x2F;a&gt; in part one, in this episode we tackle the next three. Let&#x27;s get started!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics4-rs&quot;&gt;&lt;code&gt;move_semantics4.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; move_semantics4.rs
&amp;#x2F;&amp;#x2F; Refactor this code so that instead of passing `vec0` into the `fill_vec` function,
&amp;#x2F;&amp;#x2F; the Vector gets created in the function itself and passed back to the main
&amp;#x2F;&amp;#x2F; function.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}

&amp;#x2F;&amp;#x2F; `fill_vec()` no longer takes `vec: Vec&amp;lt;i32&amp;gt;` as argument
fn fill_vec() -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions here are to refactor our code so that instead of passing &lt;code&gt;vec0&lt;&#x2F;code&gt; into the &lt;code&gt;fill_vec&lt;&#x2F;code&gt; function, the Vector gets created in the function itself and passed back to the main function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics4-rs-errors&quot;&gt;&lt;code&gt;move_semantics4.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics4.rs failed! Please try again. Here is the output:
error[E0423]: expected value, found macro `vec`
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics4.rs:23:19
   |
23 |     let mut vec = vec;
   |                   ^^^ not a value

error[E0061]: this function takes 0 arguments but 1 argument was supplied
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics4.rs:12:20
   |
12 |     let mut vec1 = fill_vec(vec0);
   |                    ^^^^^^^^ ---- argument of type `Vec&amp;lt;_&amp;gt;` unexpected
   |
note: function defined here
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics4.rs:22:4
   |
22 | fn fill_vec() -&amp;gt; Vec&amp;lt;i32&amp;gt; {
   |    ^^^^^^^^
help: remove the extra argument
   |
12 |     let mut vec1 = fill_vec();
   |                            ~~

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Error&#x27;s  are telling us that on line 23, &lt;code&gt;vec&lt;&#x2F;code&gt; is not a value in addition it tells us that the function &lt;code&gt;fill_vec()&lt;&#x2F;code&gt; takes 0 arguments but one is being supplied.  So let&#x27;s remove the argument on line 12 from the &lt;code&gt;fill_vec(vec0)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;After we do that we still get some errors, but they&#x27;re different now.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics4.rs failed! Please try again. Here is the output:
error[E0423]: expected value, found macro `vec`
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics4.rs:23:19
   |
23 |     let mut vec = vec;
   |                   ^^^ not a value

error[E0282]: type annotations needed for `Vec&amp;lt;T&amp;gt;`
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics4.rs:10:9
   |
10 |     let vec0 = Vec::new();
   |         ^^^^
   |
help: consider giving `vec0` an explicit type, where the type for type parameter `T` is specified
   |
10 |     let vec0: Vec&amp;lt;T&amp;gt; = Vec::new();
   |             ++++++++

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The error&#x27;s start point us to using generics with &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; but our solution should be must simpler than that, since our instructions are to refactor our code to not create &lt;code&gt;vec0&lt;&#x2F;code&gt; but to create a new vector in our &lt;code&gt;fill_vec()&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s see what happens if we simple remove the &lt;code&gt;let vec0 = Vec::new();&lt;&#x2F;code&gt; line from our code but and add the &lt;code&gt;let mut vec = Vec::new();&lt;&#x2F;code&gt; to our &lt;code&gt;fill_vec()&lt;&#x2F;code&gt; function. Hey guess what? It works. Below is the update code solution.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics4-solution&quot;&gt;&lt;code&gt;move_semantics4&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
	&amp;#x2F;&amp;#x2F; removed previous vector creation here
    let mut vec1 = fill_vec();

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}

fn fill_vec() -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut vec = Vec::new(); &amp;#x2F;&amp;#x2F; added vector creation within the function

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is our output:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
vec1 has length 3 content `[22, 44, 66]`
vec1 has length 4 content `[22, 44, 66, 88]`

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;move-semantics5-rs&quot;&gt;&lt;code&gt;move_semantics5.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; move_semantics5.rs
&amp;#x2F;&amp;#x2F; Make me compile only by reordering the lines in `main()`, but without
&amp;#x2F;&amp;#x2F; adding, changing or removing any of them.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let mut x = 100;
    let y = &amp;amp;mut x;
    let z = &amp;amp;mut x;
    *y += 100;
    *z += 1000;
    assert_eq!(x, 1200);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This looks like an easy one, no need to write anything we just need to re-order the sequence of the lines. Let&#x27;s look at the errors and see if we can get any hints on what we need to do.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics5-rs-errors&quot;&gt;&lt;code&gt;move_semantics5.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics5.rs failed! Please try again. Here is the output:
error[E0499]: cannot borrow `x` as mutable more than once at a time
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics5.rs:11:13
   |
10 |     let y = &amp;amp;mut x;
   |             ------ first mutable borrow occurs here
11 |     let z = &amp;amp;mut x;
   |             ^^^^^^ second mutable borrow occurs here
12 |     *y += 100;
   |     --------- first borrow later used here
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The Rust compiler tells us that we are borrowing &lt;code&gt;x&lt;&#x2F;code&gt; mutably too many times, so let&#x27;s go step by step and see what is happening on each line.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;We declare a mutable variable &lt;code&gt;x&lt;&#x2F;code&gt; and assign it the value &lt;code&gt;100&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;We create a mutable reference &lt;code&gt;y&lt;&#x2F;code&gt; that borrows &lt;code&gt;x&lt;&#x2F;code&gt; using &lt;code&gt;&amp;amp;mut x&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Then, we create another mutable reference &lt;code&gt;z&lt;&#x2F;code&gt; that also borrows &lt;code&gt;x&lt;&#x2F;code&gt; using &lt;code&gt;&amp;amp;mut x&lt;&#x2F;code&gt;. This is where the problem arises.
&lt;ul&gt;
&lt;li&gt;The rules of borrowing state that you can have either one mutable reference or any number of immutable references to a value at a given time.&lt;&#x2F;li&gt;
&lt;li&gt;In this case, we already have &lt;code&gt;y&lt;&#x2F;code&gt; as a mutable reference to &lt;code&gt;x&lt;&#x2F;code&gt;, so we can&#x27;t create another mutable reference &lt;code&gt;z&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;The code tries to dereference &lt;code&gt;y&lt;&#x2F;code&gt; using &lt;code&gt;*y&lt;&#x2F;code&gt; and add &lt;code&gt;100&lt;&#x2F;code&gt; to the value of &lt;code&gt;x&lt;&#x2F;code&gt;. This is invalid because &lt;code&gt;y&lt;&#x2F;code&gt; is still in scope and holds a mutable reference to &lt;code&gt;x&lt;&#x2F;code&gt;, and at this point, &lt;code&gt;z&lt;&#x2F;code&gt; also exists.&lt;&#x2F;li&gt;
&lt;li&gt;Similarly, when the code tries to dereference &lt;code&gt;z&lt;&#x2F;code&gt; using &lt;code&gt;*z&lt;&#x2F;code&gt; and add &lt;code&gt;1000&lt;&#x2F;code&gt; to the value of &lt;code&gt;x&lt;&#x2F;code&gt;, it violates the borrowing rules.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;So how do we solve this? Let&#x27;s try by dereferencing &lt;code&gt;y&lt;&#x2F;code&gt; before we try to borrow it again with &lt;code&gt;z&lt;&#x2F;code&gt; by moving the line &lt;code&gt;*y += 100;&lt;&#x2F;code&gt;
above the 2nd attempt mutable borrow which is &lt;code&gt;let z = &amp;amp;mut x;&lt;&#x2F;code&gt;. Doing so should allow us to compile.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics5-rs-solution&quot;&gt;&lt;code&gt;move_semantics5.rs&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let mut x = 100;
    let y = &amp;amp;mut x;
    *y += 100;
    let z = &amp;amp;mut x;
    *z += 1000;
    assert_eq!(x, 1200);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It compiles! We don&#x27;t get an output because there is not &lt;code&gt;println!&lt;&#x2F;code&gt; statement instead we have an &lt;code&gt;assert_eq!&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The code compiles successfully because it follows the borrowing rules in Rust. Here&#x27;s a step-by-step explanation:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;We start by declaring a mutable variable &lt;code&gt;x&lt;&#x2F;code&gt; and assigning it the value &lt;code&gt;100&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;We then create a mutable reference &lt;code&gt;y&lt;&#x2F;code&gt; that borrows &lt;code&gt;x&lt;&#x2F;code&gt; using &lt;code&gt;&amp;amp;mut x&lt;&#x2F;code&gt;. This allows us to modify &lt;code&gt;x&lt;&#x2F;code&gt; through &lt;code&gt;y&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;We dereference &lt;code&gt;y&lt;&#x2F;code&gt; using &lt;code&gt;*y&lt;&#x2F;code&gt; and add &lt;code&gt;100&lt;&#x2F;code&gt; to the value of &lt;code&gt;x&lt;&#x2F;code&gt;. This modifies &lt;code&gt;x&lt;&#x2F;code&gt; to &lt;code&gt;200&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Next, we create another mutable reference &lt;code&gt;z&lt;&#x2F;code&gt; that also borrows &lt;code&gt;x&lt;&#x2F;code&gt; using &lt;code&gt;&amp;amp;mut x&lt;&#x2F;code&gt;. This is allowed because there are no other references to &lt;code&gt;x&lt;&#x2F;code&gt; at this point.&lt;&#x2F;li&gt;
&lt;li&gt;We dereference &lt;code&gt;z&lt;&#x2F;code&gt; using &lt;code&gt;*z&lt;&#x2F;code&gt; and add &lt;code&gt;1000&lt;&#x2F;code&gt; to the value of &lt;code&gt;x&lt;&#x2F;code&gt;. This modifies &lt;code&gt;x&lt;&#x2F;code&gt; to &lt;code&gt;1200&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Finally, we use &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; to check if &lt;code&gt;x&lt;&#x2F;code&gt; is equal to &lt;code&gt;1200&lt;&#x2F;code&gt;. Since the value of &lt;code&gt;x&lt;&#x2F;code&gt; is indeed &lt;code&gt;1200&lt;&#x2F;code&gt;, the assertion passes.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Let&#x27;s move on to our final &lt;code&gt;move_semantics&lt;&#x2F;code&gt; exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics6-rs&quot;&gt;&lt;code&gt;move_semantics6.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; move_semantics6.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.
&amp;#x2F;&amp;#x2F; You can&amp;#x27;t change anything except adding or removing references.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let data = &amp;quot;Rust is great!&amp;quot;.to_string();

    get_char(data);

    string_uppercase(&amp;amp;data);
}

&amp;#x2F;&amp;#x2F; Should not take ownership
fn get_char(data: String) -&amp;gt; char {
    data.chars().last().unwrap()
}

&amp;#x2F;&amp;#x2F; Should take ownership
fn string_uppercase(mut data: &amp;amp;String) {
    data = &amp;amp;data.to_uppercase();

    println!(&amp;quot;{}&amp;quot;, data);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are to not change anything but the references, so we&#x27;ll look at the errors to get a better understanding as to where we are having issues.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics6-rs-errors&quot;&gt;&lt;code&gt;move_semantics6.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs failed! Please try again. Here is the output:
error[E0382]: borrow of moved value: `data`
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:12:22
   |
8  |     let data = &amp;quot;Rust is great!&amp;quot;.to_string();
   |         ---- move occurs because `data` has type `String`, which does not implement the `Copy` trait
9  |
10 |     get_char(data);
   |              ---- value moved here
11 |
12 |     string_uppercase(&amp;amp;data);
   |                      ^^^^^ value borrowed here after move
   |
note: consider changing this parameter type in function `get_char` to borrow instead if owning the value is not necessary
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:16:19
   |
16 | fn get_char(data: String) -&amp;gt; char {
   |    --------       ^^^^^^ this parameter takes ownership of the value
   |    |
   |    in this function
help: consider cloning the value if the performance cost is acceptable
   |
10 |     get_char(data.clone());
   |                  ++++++++

error[E0716]: temporary value dropped while borrowed
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:22:13
   |
21 | fn string_uppercase(mut data: &amp;amp;String) {
   |                               - let us call the lifetime of this reference `&amp;#x27;1`
22 |     data = &amp;amp;data.to_uppercase();
   |     --------^^^^^^^^^^^^^^^^^^^- temporary value is freed at the end of this statement
   |     |       |
   |     |       creates a temporary value which is freed while still in use
   |     assignment requires that borrow lasts for `&amp;#x27;1`

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright let&#x27;s go down the list understanding what there errors are telling us and see how we can fix them.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;8  |     let data = &amp;quot;Rust is great!&amp;quot;.to_string();
   |         ---- move occurs because `data` has type `String`, which does not implement the `Copy` trait
9  |
10 |     get_char(data);
   |              ---- value moved here
11 |
12 |     string_uppercase(&amp;amp;data);
   |                      ^^^^^ value borrowed here after move
   note: consider changing this parameter type in function `get_char` to borrow instead if owning the value is not necessary
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:16:19
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;here the compiler is telling us clearly where to look &lt;code&gt;data&lt;&#x2F;code&gt; does not implement the copy trait so we when we pass it through as a parameter in &lt;code&gt;get_char(data),&lt;&#x2F;code&gt; it becomes owned by &lt;code&gt;get_char()&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the next batch of errors we get a suggestion about cloning, but we know that we can&#x27;t change any of the code other than changing the references, so this is not the path we want to take.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;16 | fn get_char(data: String) -&amp;gt; char {
   |    --------       ^^^^^^ this parameter takes ownership of the value
   |    |
   |    in this function
help: consider cloning the value if the performance cost is acceptable
   |
10 |     get_char(data.clone());
   |                  ++++++++

error[E0716]: temporary value dropped while borrowed
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt; |
21 | fn string_uppercase(mut data: &amp;amp;String) {
   |                               - let us call the lifetime of this reference `&amp;#x27;1&amp;#x27;`
22 |     data = &amp;amp;data.to_uppercase();
   |     --------^^^^^^^^^^^^^^^^^^^- temporary value is freed at the end of this statement
   |     |       |
   |     |       creates a temporary value which is freed while still in use
   |     assignment requires that borrow lasts for `&amp;#x27;1`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We now get a message about the lifetime of a reference which we haven&#x27;t covered yet so let&#x27;s just keep this in mind for now, but again our task is to essentially just change how the functions handle ownership. So let&#x27;s go back and look at the functions in the code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Should not take ownership
fn get_char(data: String) -&amp;gt; char {
    data.chars().last().unwrap()
}

&amp;#x2F;&amp;#x2F; Should take ownership
fn string_uppercase(mut data: &amp;amp;String) {
    data = &amp;amp;data.to_uppercase();

    println!(&amp;quot;{}&amp;quot;, data);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Looking at these two code blocks it looks straightforward, it&#x27;s clear that we must change where the &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; symbol is being used and essentially swap positions in each function to this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Should not take ownership
fn get_char(data: &amp;amp;String) -&amp;gt; char {
    data.chars().last().unwrap()
}

&amp;#x2F;&amp;#x2F; Should take ownership
fn string_uppercase(mut data: String) {
    data = data.to_uppercase();

    println!(&amp;quot;{}&amp;quot;, data);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once we&#x27;ve done this we get new error&#x27;s but it should be pretty clear what we need to do in the &lt;code&gt;fn main()&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs failed! Please try again. Here is the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:10:14
   |
10 |     get_char(data);
   |     -------- ^^^^
   |     |        |
   |     |        expected `&amp;amp;String`, found struct `String`
   |     |        help: consider borrowing here: `&amp;amp;data`
   |     arguments to this function are incorrect
   |
note: function defined here
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:16:4
   |
16 | fn get_char(data: &amp;amp;String) -&amp;gt; char {
   |    ^^^^^^^^ -------------

error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:12:22
   |
12 |     string_uppercase(&amp;amp;data);
   |     ---------------- ^^^^^ expected struct `String`, found `&amp;amp;String`
   |     |
   |     arguments to this function are incorrect
   |
note: function defined here
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics6.rs:21:4
   |
21 | fn string_uppercase(mut data: String) {
   |    ^^^^^^^^^^^^^^^^ ----------------
help: consider removing the borrow
   |
12 -     string_uppercase(&amp;amp;data);
12 +     string_uppercase(data);
   |

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler gives us great information on what we should do literally showing us what we can do to make the code compile. So let&#x27;s try it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics6-rs-solution&quot;&gt;&lt;code&gt;move_semantics6.rs&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let data = &amp;quot;Rust is great!&amp;quot;.to_string();

    get_char(&amp;amp;data);

    string_uppercase(data);
}

&amp;#x2F;&amp;#x2F; Should not take ownership
fn get_char(data: &amp;amp;String) -&amp;gt; char {
    data.chars().last().unwrap()
}

&amp;#x2F;&amp;#x2F; Should take ownership
fn string_uppercase(mut data: String) {
    data = data.to_uppercase();

    println!(&amp;quot;{}&amp;quot;, data);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There we have it our solution is to again swap the &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; symbol&#x27;s position to match that of the function&#x27;s signature to make sure that we are borrowing and taking ownership as the function expects. With that we get our print out:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
RUST IS GREAT!

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h3&gt;
&lt;p&gt;Rust&#x27;s move semantics are important for understanding memory management and ownership in the language. By leveraging references, borrowing, and ownership, Rust ensures memory safety and eliminates many common programming errors like null pointer dereferences and dangling references.&lt;&#x2F;p&gt;
&lt;p&gt;In this blog post, we explored three exercises related to move semantics. We refactored code, re-ordered lines, and adjusted ownership to solve the problems. Through these exercises, we gained a better understanding of how move semantics work in Rust and how to manipulate ownership and references effectively.&lt;&#x2F;p&gt;
&lt;p&gt;Move semantics play a crucial role in Rust&#x27;s design philosophy, enabling high-performance and safe code without sacrificing expressiveness. By embracing move semantics and mastering the intricacies of ownership, borrowing, and references, Rust developers can write robust and efficient code.&lt;&#x2F;p&gt;
&lt;p&gt;Remember, practice is key to mastering move semantics and other advanced features of Rust. Keep exploring, experimenting, and building projects to deepen your understanding and become a proficient Rust programmer. Happy coding!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>07 Rustlings Move Semantics Part 1</title>
          <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/07-rustlings-move-semantics1/</link>
          <guid>https://desmodrone.github.io/posts/07-rustlings-move-semantics1/</guid>
          <description>&lt;p&gt;From the Rustlings ReadMe:
These exercises are adapted from &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pnkfelix&quot;&gt;pnkfelix&lt;&#x2F;a&gt;&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;pnkfelix.github.io&#x2F;rust-examples-icfp2014&#x2F;&quot;&gt;Rust Tutorial&lt;&#x2F;a&gt; -- Thank you Felix!!!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;p&gt;For this section, the book links are especially important.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-01-what-is-ownership.html&quot;&gt;Ownership&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-02-references-and-borrowing.html&quot;&gt;Reference and borrowing&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;&#x2F;h2&gt;
&lt;p&gt;Ownership, References, and Borrowing are essential components of Rust&#x27;s unique characteristics. It&#x27;s crucial to have a solid understanding of these concepts to harness the full potential of Rust. In this introduction, we&#x27;ll provide a brief overview of each aspect, but you can find more detailed information in the links provided above.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-is-ownership&quot;&gt;What is Ownership?&lt;&#x2F;h2&gt;
&lt;p&gt;Ownership in Rust is a set of rules that dictate how a program manages memory. All programs require a memory management system during execution. While some languages rely on garbage collection to automatically locate and clean up unused memory, and others require the programmer to allocate and free memory manually, Rust takes a different approach. Rust&#x27;s memory management is handled through ownership rules that are checked at compile time. If any of these rules are violated, the code will not compile. The advantage of this system is that it doesn&#x27;t slow down our program during runtime.&lt;&#x2F;p&gt;
&lt;p&gt;For many programmers, the ownership concept is a novel idea and may require some adjustment. However, once you have a firm grasp of ownership, you&#x27;ll have a strong foundation on what sets Rust apart from other languages and makes it memory safe.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;references-and-borrowing&quot;&gt;References and Borrowing&lt;&#x2F;h2&gt;
&lt;p&gt;Due to Rust&#x27;s strict ownership rules, the language provides tools to reference or borrow different parts of your code as a means of accessing or using data without &amp;quot;consuming&amp;quot; it. These tools introduce another set of rules that must be learned to fully leverage Rust&#x27;s features. With a thorough understanding of References and Borrowing, you can work efficiently within Rust&#x27;s ownership system, allowing for more reliable and performant programs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics1-rs&quot;&gt;&lt;code&gt;move_semantics1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; move_semantics1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let vec1 = fill_vec(vec0);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here&#x27;s our first exercise, which not much in the sense of instructions on how to solve our problem. As always let&#x27;s take a look at what the Rust compiler is telling us.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics1-rs-errors&quot;&gt;&lt;code&gt;move_semantics1.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics1.rs failed! Please try again. Here is the output:
error[E0596]: cannot borrow `vec1` as mutable, as it is not declared as mutable
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics1.rs:13:5
   |
13 |     vec1.push(88);
   |     ^^^^^^^^^^^^^ cannot borrow as mutable
   |
help: consider changing this to be mutable
   |
9  |     let mut vec1 = fill_vec(vec0);
   |         +++

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We get a lot of help here from this output clearly telling us where and what the problem is.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;where &lt;code&gt;line 13&lt;&#x2F;code&gt;: &lt;code&gt;vec1.push(88)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;what &lt;code&gt;cannot borrow as mutable&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We even a very clear suggestion on what we should add on line &lt;code&gt;9&lt;&#x2F;code&gt;, so let&#x27;s do this.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;9  |     let mut vec1 = fill_vec(vec0);
   |         +++
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;move-semantics1-solution&quot;&gt;&lt;code&gt;move_semantics1&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0); &amp;#x2F;&amp;#x2F; adding `mut`

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Doing exactly as the Rust compiler says gets us an easy win.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
vec1 has length 3 content `[22, 44, 66]`
vec1 has length 4 content `[22, 44, 66, 88]`

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since this was such an easy exercise, let&#x27;s play around with the code, if you look at the hint by typing &lt;code&gt;hint&lt;&#x2F;code&gt; in terminal, you&#x27;ll see it gives you another little challenge.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Also: Try accessing `vec0` after having called `fill_vec()`. See what happens!

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;See if you can get this to work, it should be pretty straight forward if you follow the compiler hints, I was able to get this to print.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
vec1 has length 3 content `[22, 44, 66]`
vec1 has length 4 content `[22, 44, 66, 88]`
vec0 has length 1 content `[1]`

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;On to the next one!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics2-rs&quot;&gt;&lt;code&gt;move_semantics2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; move_semantics2.rs
&amp;#x2F;&amp;#x2F; Make me compile without changing line 13 or moving line 10!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    &amp;#x2F;&amp;#x2F; Do not change the following line!
    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec0&amp;quot;, vec0.len(), vec0);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we get one line of instruction, make this code compile without changing line 13 or moving line 10. Now let&#x27;s take a look at what the Rust compiler is telling us.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics2-rs-errors&quot;&gt;&lt;code&gt;move_semantics2.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics2.rs failed! Please try again. Here is the output:
error[E0382]: borrow of moved value: `vec0`
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics2.rs:13:57
   |
8  |     let vec0 = Vec::new();
   |         ---- move occurs because `vec0` has type `Vec&amp;lt;i32&amp;gt;`, which does not implement the `Copy` trait
9  |
10 |     let mut vec1 = fill_vec(vec0);
   |                             ---- value moved here
...
13 |     println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec0&amp;quot;, vec0.len(), vec0);
   |                                                         ^^^^^^^^^^ value borrowed here after move
   |
note: consider changing this parameter type in function `fill_vec` to borrow instead if owning the value is not necessary
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics2.rs:20:18
   |
20 | fn fill_vec(vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
   |    --------      ^^^^^^^^ this parameter takes ownership of the value
   |    |
   |    in this function
help: consider cloning the value if the performance cost is acceptable
   |
10 |     let mut vec1 = fill_vec(vec0.clone());
   |                                 ++++++++

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright, we have a lot to see here, the first error on line 8 tells us that &lt;code&gt;vec0&lt;&#x2F;code&gt; is being moved to line 10 to the line &lt;code&gt;let mut vec1 = fill_vec(0);&lt;&#x2F;code&gt;
The note tells us to consider changing the parameter type, but that shouldn&#x27;t be where we should be looking because in this case we do want to return a &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt;. If we continue reading our errors, we get the answer in the line  &lt;code&gt;help: consider cloning the value if the performanc cost is acceptable&lt;&#x2F;code&gt;. This is very helpful and clear answer.  If you played around with the code on [[#move_semantics1.rs]] you might have already encountered this solution. So let&#x27;s try this &lt;code&gt;clone()&lt;&#x2F;code&gt; solution.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics2-solution&quot;&gt;&lt;code&gt;move_semantics2&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0.clone()); &amp;#x2F;&amp;#x2F; adding clone() here

    &amp;#x2F;&amp;#x2F; Do not change the following line!
    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec0&amp;quot;, vec0.len(), vec0);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It works. Again, you shouldn&#x27;t be too surprised if you played around with the previous code that we had since it&#x27;s pretty much the same code.
Our code compiles and this is our output.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
vec0 has length 0 content `[]`
vec1 has length 4 content `[22, 44, 66, 88]`

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we look at the hint, we actually have a few different options to make this code compile. The compiler told us one solution with cloning along with the warning that we should be aware that there could be a performance cost if our data is big. In our case it works because it&#x27;s not, but using &lt;code&gt;clone()&lt;&#x2F;code&gt; is not always a good solution. So, let&#x27;s look at alternate solutions from the Rustlings hint.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;hint&lt;&#x2F;strong&gt;
So, &lt;code&gt;vec0&lt;&#x2F;code&gt; is passed into the &lt;code&gt;fill_vec&lt;&#x2F;code&gt; function as an argument. In Rust,
when an argument is passed to a function and it&#x27;s not explicitly returned,
you can&#x27;t use the original variable anymore. We call this &amp;quot;moving&amp;quot; a variable.
Variables that are moved into a function (or block scope) and aren&#x27;t explicitly
returned get &amp;quot;dropped&amp;quot; at the end of that function. This is also what happens here.
There&#x27;s a few ways to fix this, try them all if you want:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Make another, separate version of the data that&#x27;s in &lt;code&gt;vec0&lt;&#x2F;code&gt; and pass that to &lt;code&gt;fill_vec&lt;&#x2F;code&gt; instead.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Make &lt;code&gt;fill_vec&lt;&#x2F;code&gt; borrow its argument instead of taking ownership of it, and then copy the data within the function in order to return an owned &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Make &lt;code&gt;fill_vec&lt;&#x2F;code&gt; &lt;em&gt;mutably&lt;&#x2F;em&gt; borrow a reference to its argument (which will need to be mutable), modify it directly, then not return anything. Then you can get rid of &lt;code&gt;vec1&lt;&#x2F;code&gt; entirely -- note that this will change what gets printed by the first &lt;code&gt;println!&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Option 1, is what we already did by cloning the data inside of &lt;code&gt;vec0&lt;&#x2F;code&gt; we created a separate version so let&#x27;s look at the other 2 options.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;solution-2&quot;&gt;Solution 2&lt;&#x2F;h2&gt;
&lt;p&gt;Tells us that we should make &lt;code&gt;fill_vec&lt;&#x2F;code&gt; borrow its arguments instead of owning them, then we copy the data within the function and return and owned &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt;. Let&#x27;s see how we can implement this.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(&amp;amp;vec0); &amp;#x2F;&amp;#x2F; ad the `&amp;amp;` to our `vec0`

    &amp;#x2F;&amp;#x2F; Do not change the following line!
    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec0&amp;quot;, vec0.len(), vec0);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}
&amp;#x2F;&amp;#x2F; change the paramter of our function here to be a reference with &amp;amp;Vec&amp;lt;i32&amp;gt;
fn fill_vec(vec: &amp;amp;Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let mut vec = vec.clone(); &amp;#x2F;&amp;#x2F; we use clone() here to copy the data

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So here&#x27;s the second solution and although it handles the problem a little differently it still has to copy the data using &lt;code&gt;clone()&lt;&#x2F;code&gt;. So it would still have similar performance hits if we had a huge vector of data. However, it&#x27;s worth noting that the second solution is more idiomatic Rust. In Rust, it&#x27;s common to use the clone method directly on the caller&#x27;s side, making it clear that a clone is being created and ownership is being transferred.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;solution-3&quot;&gt;Solution 3&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let mut vec0 = Vec::new(); &amp;#x2F;&amp;#x2F; Make vec0 mutable

    fill_vec(&amp;amp;mut vec0); &amp;#x2F;&amp;#x2F; Pass a mutable reference to vec0

    &amp;#x2F;&amp;#x2F; Do not change the following line!
    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec0&amp;quot;, vec0.len(), vec0);

    vec0.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec0&amp;quot;, vec0.len(), vec0); &amp;#x2F;&amp;#x2F; Update the label to &amp;quot;vec0&amp;quot;
}

&amp;#x2F;&amp;#x2F; Change the function parameter to accept a mutable reference with &amp;amp;mut Vec&amp;lt;i32&amp;gt;
&amp;#x2F;&amp;#x2F; Remove the return type, as the function doesn&amp;#x27;t need to return anything
fn fill_vec(vec: &amp;amp;mut Vec&amp;lt;i32&amp;gt;) {
    vec.push(22);
    vec.push(44);
    vec.push(66);
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now let&#x27;s took at our final solution that changes a bit more how the code functions. In this modified version, &lt;code&gt;fill_vec&lt;&#x2F;code&gt; now takes a mutable reference to a &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt; (indicated by &lt;code&gt;&amp;amp;mut Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt;), allowing it to modify the input vector directly. Since the input vector is modified in place, the function doesn&#x27;t need to return anything. As a result, there is no need for a separate &lt;code&gt;vec1&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We also see that our output changes&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
vec0 has length 3 content `[22, 44, 66]`
vec0 has length 4 content `[22, 44, 66, 88]`

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;so-which-solution-is-best&quot;&gt;So which Solution is Best?&lt;&#x2F;h2&gt;
&lt;p&gt;The best solution depends on your specific requirements:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;If you need to keep the original vector unchanged and create a modified version, choose either solution 1 or 2. Solution 2 is more idiomatic Rust.&lt;&#x2F;li&gt;
&lt;li&gt;If you don&#x27;t need the original vector in its initial state and want to modify it directly, solution 3 is the best choice, as it avoids creating a new vector and is more efficient.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In general, solution 3 is the most efficient because it directly modifies the original vector without creating a new one. However, this may not be suitable for every use case, as it changes the original vector&#x27;s content. Let&#x27;s move on to the next exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics3&quot;&gt;&lt;code&gt;move_semantics3&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; move_semantics3.rs
&amp;#x2F;&amp;#x2F; Make me compile without adding new lines-- just changing existing lines!
&amp;#x2F;&amp;#x2F; (no lines with multiple semicolons necessary!)
&amp;#x2F;&amp;#x2F; Execute `rustlings hint move_semantics3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This exercise says we can&#x27;t add any additional lines of code, but we can change the lines. Let&#x27;s take a look at what the compiler is saying.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics3-errors&quot;&gt;&lt;code&gt;move_semantics3&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics3.rs failed! Please try again. Here is the output:
error[E0596]: cannot borrow `vec` as mutable, as it is not declared as mutable
  --&amp;gt; exercises&amp;#x2F;move_semantics&amp;#x2F;move_semantics3.rs:20:13
   |
20 | fn fill_vec(vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
   |             ^^^ not mutable
21 |     vec.push(22);
   |     ------------ cannot borrow as mutable
22 |     vec.push(44);
   |     ------------ cannot borrow as mutable
23 |     vec.push(66);
   |     ------------ cannot borrow as mutable
   |
help: consider changing this to be mutable
   |
20 | fn fill_vec(mut vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
   |             +++

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As always we get great help from the compiler. This seems pretty straight forward, let&#x27;s do what the compiler suggests and see what happens.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;move-semantics3-solution&quot;&gt;&lt;code&gt;move_semantics3&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&amp;quot;{} has length {} content `{:?}`&amp;quot;, &amp;quot;vec1&amp;quot;, vec1.len(), vec1);
}
&amp;#x2F;&amp;#x2F; adding `mut` to the `vec` paramater
fn fill_vec(mut vec: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Success!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
vec1 has length 3 content `[22, 44, 66]`
vec1 has length 4 content `[22, 44, 66, 88]`

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Following the Rust compiler&#x27;s help is very easy  in this case, if we notice the code is very similar to the previous exercise but this code is missing the &lt;code&gt;let mut vec = vec;&lt;&#x2F;code&gt; line from the &lt;code&gt;fn fill_vec&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wrapping-up-the-rustlings-move-semantics-journey-continues&quot;&gt;Wrapping Up: The Rustlings Move Semantics Journey Continues!&lt;&#x2F;h2&gt;
&lt;p&gt;There you have it! We&#x27;ve explored the first three &lt;code&gt;move_semantics&lt;&#x2F;code&gt; exercises from the Rustlings course. To keep these blog posts digestible, we&#x27;ll be diving into the next 3 &lt;code&gt;move_semantics&lt;&#x2F;code&gt; challenges in a separate post, so keep an eye out for that!&lt;&#x2F;p&gt;
&lt;p&gt;Now, let&#x27;s do a quick recap of what we&#x27;ve covered in this post: we guided you through the first 3 &lt;code&gt;move_semantics&lt;&#x2F;code&gt; exercises, shedding light on how to tackle each problem by interpreting the error messages and hints provided. We also compared various solutions for each exercise, highlighting the trade-offs and stressing the importance of choosing the right method based on your code&#x27;s specific needs. Our focus was on understanding the concepts of ownership, borrowing, and mutable borrowing in Rust – essential ingredients for writing efficient and safe code.&lt;&#x2F;p&gt;
&lt;p&gt;By working through these exercises and comprehending the solutions, you&#x27;re now better prepared to handle ownership and borrowing situations in your Rust projects. Stay tuned for more Rustling adventures!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>06 Rustlings Vectors</title>
          <pubDate>Wed, 10 May 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/06-rustlings-vecs/</link>
          <guid>https://desmodrone.github.io/posts/06-rustlings-vecs/</guid>
          <description>&lt;h1 id=&quot;vectors&quot;&gt;Vectors&lt;&#x2F;h1&gt;
&lt;p&gt;Vectors are a widely-used data structure in Rust programming. In many programming languages, they might be referred to as Arrays. However, Rust operates at a lower level, which leads to a distinction between arrays and vectors. In Rust, an array is usually stored on the stack, which means it cannot grow or shrink, and its size must be determined at compile time. On the other hand, a vector is stored in the heap, allowing for greater flexibility as these size restrictions do not apply.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look at these couple of exercises from Rustlings&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch08-01-vectors.html&quot;&gt;Storing Lists of Values with Vectors&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.slice.html#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;iter&#x2F;trait.Iterator.html#method.map&quot;&gt;&lt;code&gt;map&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;vecs1-rs&quot;&gt;&lt;code&gt;vecs1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; vecs1.rs
&amp;#x2F;&amp;#x2F; Your task is to create a `Vec` which holds the exact same elements
&amp;#x2F;&amp;#x2F; as in the array `a`.
&amp;#x2F;&amp;#x2F; Make me compile and pass the test!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn array_and_vec() -&amp;gt; ([i32; 4], Vec&amp;lt;i32&amp;gt;) {
    let a = [10, 20, 30, 40]; &amp;#x2F;&amp;#x2F; a plain array
    let v = &amp;#x2F;&amp;#x2F; TODO: declare your vector here with the macro for vectors

    (a, v)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_array_and_vec_similarity() {
        let (a, v) = array_and_vec();
        assert_eq!(a, v[..]);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are clear here in the comments create a vector that holds the elements&lt;code&gt; [10, 20, 30, 40]&lt;&#x2F;code&gt; just like &lt;code&gt;a&lt;&#x2F;code&gt; does. Simple enough.&lt;&#x2F;p&gt;
&lt;p&gt;For completeness let&#x27;s also log what we are seeing as the errors.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;vecs1-rs-errors&quot;&gt;&lt;code&gt;vecs1.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;vecs&amp;#x2F;vecs1.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected `;`, found `}`
  --&amp;gt; exercises&amp;#x2F;vecs&amp;#x2F;vecs1.rs:13:11
   |
13 |     (a, v)
   |           ^ help: add `;` here
14 | }
   | - unexpected token

error[E0425]: cannot find value `v` in this scope
  --&amp;gt; exercises&amp;#x2F;vecs&amp;#x2F;vecs1.rs:13:9
   |
13 |     (a, v)
   |         ^ help: a local variable with a similar name exists: `a`

error[E0308]: mismatched types
 --&amp;gt; exercises&amp;#x2F;vecs&amp;#x2F;vecs1.rs:9:23
  |
9 | fn array_and_vec() -&amp;gt; ([i32; 4], Vec&amp;lt;i32&amp;gt;) {
  |    -------------      ^^^^^^^^^^^^^^^^^^^^ expected tuple, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
  |
  = note:  expected tuple `([i32; 4], Vec&amp;lt;i32&amp;gt;)`
          found unit type `()`

error: aborting due to 3 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can see that the Rust compiler is a little confused and is suggesting ways to complete our code that are not what we are trying to do, but it&#x27;s good to get a sense of what the compiler is doing in this situation so we can potentially understand other issues as we encounter them.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;vecs1-rs-solution&quot;&gt;&lt;code&gt;vecs1.rs&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn array_and_vec() -&amp;gt; ([i32; 4], Vec&amp;lt;i32&amp;gt;) {
    let a = [10, 20, 30, 40]; &amp;#x2F;&amp;#x2F; a plain array
    let v = vec![10, 20, 30, 40]; &amp;#x2F;&amp;#x2F; using `vec!` macro to define a vector
    (a, v)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_array_and_vec_similarity() {
        let (a, v) = array_and_vec();
        assert_eq!(a, v[..]);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Completing the &lt;code&gt;let v&lt;&#x2F;code&gt; line with &lt;code&gt;vec![10, 20, 30, 40];&lt;&#x2F;code&gt; easily solves our exercise here.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;additional-notes&quot;&gt;Additional Notes&lt;&#x2F;h2&gt;
&lt;p&gt;Remember that there is more than one way to create a &lt;code&gt;vector&lt;&#x2F;code&gt; in Rust, we used the macro with &lt;code&gt;vec!&lt;&#x2F;code&gt; because it&#x27;s very convenient but we can also create vectors using the &lt;code&gt;Vec::new()&lt;&#x2F;code&gt; function to create a new vector and then fill it with the &lt;code&gt;push()&lt;&#x2F;code&gt; method.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s see what that would look like in this exercise:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn array_and_vec() -&amp;gt; ([i32; 4], Vec&amp;lt;i32&amp;gt;) {
    let a = [10, 20, 30, 40]; &amp;#x2F;&amp;#x2F; a plain array
    let mut v = Vec::new(); &amp;#x2F;&amp;#x2F; using `Vec::new()` function remembering to make it `mut`

    &amp;#x2F;&amp;#x2F; placing elements into the array with `push()` method
    v.push(10);
    v.push(20);
    v.push(30);
    v.push(40);

    (a, v)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This will also get our code to compile, but as you can see it&#x27;s a lot more effort to do, so in this case it&#x27;s much easier to use the &lt;code&gt;Vec!&lt;&#x2F;code&gt; macro.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;vecs2-rs&quot;&gt;&lt;code&gt;vecs2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; vecs2.rs
&amp;#x2F;&amp;#x2F; A Vec of even numbers is given. Your task is to complete the loop
&amp;#x2F;&amp;#x2F; so that each number in the Vec is multiplied by 2.
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Make me pass the test!
&amp;#x2F;&amp;#x2F;
&amp;#x2F;&amp;#x2F; Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn vec_loop(mut v: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    for i in v.iter_mut() {
        &amp;#x2F;&amp;#x2F; TODO: Fill this up so that each element in the Vec `v` is
        &amp;#x2F;&amp;#x2F; multiplied by 2.
        ???
    }

    &amp;#x2F;&amp;#x2F; At this point, `v` should be equal to [4, 8, 12, 16, 20].
    v
}

fn vec_map(v: &amp;amp;Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    v.iter().map(|num| {
        &amp;#x2F;&amp;#x2F; TODO: Do the same thing as above - but instead of mutating the
        &amp;#x2F;&amp;#x2F; Vec, you can just return the new number!
        ???
    }).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_loop() {
        let v: Vec&amp;lt;i32&amp;gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_loop(v.clone());

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;());
    }

    #[test]
    fn test_vec_map() {
        let v: Vec&amp;lt;i32&amp;gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_map(&amp;amp;v);

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;());
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright we have a more involved exercise here with 2 different areas that we need to write out. Our instructors are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Complete the loop so that each number in the Vec is multiplied by 2.&lt;&#x2F;li&gt;
&lt;li&gt;First vector is mutable and the comments tell us that the vector we should have at the end of the calculations should be &lt;code&gt;[4, 8, 12, 16, 20]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Our second vector is not mutable, so our instructions are to not mutate the vector but just return the new number.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;vecs2-rs-1&quot;&gt;&lt;code&gt;vecs2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;vecs&amp;#x2F;vecs2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;vecs&amp;#x2F;vecs2.rs:15:9
   |
15 |         ???
   |         ^ expected expression

error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;vecs&amp;#x2F;vecs2.rs:26:9
   |
26 |         ???
   |         ^ expected expression

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These are the errors, pretty obvious as to why we are getting these.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look the first loop and see how we complete it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn vec_loop(mut v: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    for i in v.iter_mut() {
        *i *= 2; &amp;#x2F;&amp;#x2F; using the *i to access each element as well as `*=` to modify each element
    }

    &amp;#x2F;&amp;#x2F; At this point, `v` should be equal to [4, 8, 12, 16, 20].
    v
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s a pretty simple solution, using &lt;code&gt;*i *= 2&lt;&#x2F;code&gt;  to multiply each element by 2, the main thing to remember is the use of the dereference &lt;code&gt;*&lt;&#x2F;code&gt; operator when accessing each element and then &lt;code&gt;*=&lt;&#x2F;code&gt; to modify or update each element with the new number. If we run the code now, we see that we&#x27;re down to one error. So far so good.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;vecs&amp;#x2F;vecs2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;vecs&amp;#x2F;vecs2.rs:25:13
   |
25 |             ???
   |             ^ expected expression

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now let&#x27;s work on the 2nd for loop.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn vec_map(v: &amp;amp;Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    v.iter().map(|num| {
        &amp;#x2F;&amp;#x2F; TODO: Do the same thing as above - but instead of mutating the
        &amp;#x2F;&amp;#x2F; Vec, you can just return the new number!
        ???
    }).collect()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we see the use of a &lt;code&gt;map&lt;&#x2F;code&gt; and &lt;code&gt;closure&lt;&#x2F;code&gt; which we haven&#x27;t covered yet in our Rustlings journey, so let&#x27;s just ignore those for now, but we have to complete the iterator but as they tell us in the comments, instead of mutating the vector just return a new number, so since we don&#x27;t have to update each element and only multiply each element, we can simply use the multiplication &lt;code&gt;*&lt;&#x2F;code&gt; operator and use the &lt;code&gt;num&lt;&#x2F;code&gt; that&#x27;s being passed in through the closure to do so. It would look something like this: &lt;code&gt;num * 2&lt;&#x2F;code&gt; .&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn vec_map(v: &amp;amp;Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    v.iter().map(|num| {
        num * 2
    }).collect()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For the &lt;code&gt;vec_map&lt;&#x2F;code&gt; function, we use &lt;code&gt;v.iter().map(|num| num * 2).collect()&lt;&#x2F;code&gt;. Here, &lt;code&gt;num&lt;&#x2F;code&gt; represents each element in the vector, and &lt;code&gt;num * 2&lt;&#x2F;code&gt; returns a new number that is twice the original value. We use &lt;code&gt;collect()&lt;&#x2F;code&gt; to gather the resulting items into a collection, in this case, another vector. Notice the function signature &lt;code&gt;vec_map(v: &amp;amp;Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt;, where &lt;code&gt;v&lt;&#x2F;code&gt; is borrowed (&lt;code&gt;&amp;amp;v&lt;&#x2F;code&gt;). This concept, known as borrowing, is fundamental to Rust&#x27;s system of ownership.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;vecs2-rs-solution&quot;&gt;&lt;code&gt;vecs2.rs&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn vec_loop(mut v: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    for i in v.iter_mut() {
        *i *= 2;
    }
    v
}

fn vec_map(v: &amp;amp;Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    v.iter().map(|num| num * 2).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_loop() {
        let v: Vec&amp;lt;i32&amp;gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_loop(v.clone());

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;());
    }

    #[test]
    fn test_vec_map() {
        let v: Vec&amp;lt;i32&amp;gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_map(&amp;amp;v);

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;());
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here&#x27;s the complete block of code, clean-up a bit for clarity without the comments etc. With this code we will pass our test and we can move on to the next set of exercises.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;In this blog post, we explored Rust Vectors, a powerful and flexible data structure for handling dynamic arrays. We learned the difference between arrays and vectors in Rust and looked at some examples to understand how to create and manipulate vectors. We covered two different exercises: creating a vector from an array and performing operations on vector elements.&lt;&#x2F;p&gt;
&lt;p&gt;We learned how to create a vector using the &lt;code&gt;vec!&lt;&#x2F;code&gt; macro and how to create a vector with the &lt;code&gt;Vec::new()&lt;&#x2F;code&gt; function, and we also looked at the difference between mutable and immutable vectors. We discussed how to use loops and the &lt;code&gt;map&lt;&#x2F;code&gt; function for iterating over vectors and performing operations on their elements.&lt;&#x2F;p&gt;
&lt;p&gt;By understanding and utilizing Rust vectors, you can create efficient and flexible programs that can handle a wide range of scenarios involving dynamic arrays.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>05 Rustlings Primitive Types</title>
          <pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/05-rustlings-primitive-types/</link>
          <guid>https://desmodrone.github.io/posts/05-rustlings-primitive-types/</guid>
          <description>&lt;p&gt;Rust has a couple of basic types that are directly implemented into the
compiler. In this section, we&#x27;ll go through the most important ones.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;p&gt;Additional reading resources can be found here:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch03-02-data-types.html&quot;&gt;Data Types&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch04-03-slices.html&quot;&gt;The Slice Type&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;primitive-types1-rs&quot;&gt;&lt;code&gt;primitive_types1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; primitive_types1.rs
&amp;#x2F;&amp;#x2F; Fill in the rest of the line that has code missing!
&amp;#x2F;&amp;#x2F; No hints, there&amp;#x27;s no tricks, just get used to typing these :)

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    &amp;#x2F;&amp;#x2F; Booleans (`bool`)

    let is_morning = true;
    if is_morning {
        println!(&amp;quot;Good morning!&amp;quot;);
    }

    let &amp;#x2F;&amp;#x2F; Finish the rest of this line like the example! Or make it be false!
    if is_evening {
        println!(&amp;quot;Good evening!&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the code comments it&#x27;s clear that we are looking at &lt;strong&gt;Booleans&lt;&#x2F;strong&gt; which are a type that is either &lt;code&gt;true&lt;&#x2F;code&gt; or &lt;code&gt;false&lt;&#x2F;code&gt; . With that in mind, let&#x27;s take a look at what the errors are to make sure we have a complete picture.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;primitive-trype1-rs-errors&quot;&gt;&lt;code&gt;primitive_trype1.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types1.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected identifier, found keyword `if`
  --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types1.rs:16:5
   |
16 |     if is_evening {
   |     ^^ expected identifier, found keyword

error: expected one of `:`, `;`, `=`, `@`, or `|`, found `is_evening`
  --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types1.rs:16:8
   |
16 |     if is_evening {
   |        ^^^^^^^^^^ expected one of `:`, `;`, `=`, `@`, or `|`

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These errors point to the fact that the &lt;code&gt;if_evening&lt;&#x2F;code&gt; portion of the code is incomplete, in fact it&#x27;s almost like the compiler is saying &amp;quot;wait a minute, shouldn&#x27;t you let me know what &lt;code&gt;is_evening&lt;&#x2F;code&gt; is?&amp;quot; instead, it found the keyword &lt;code&gt;if&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;primitive-types1-rs-solution&quot;&gt;&lt;code&gt;primitive_types1.rs&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; primitive_types1.rs
&amp;#x2F;&amp;#x2F; Fill in the rest of the line that has code missing!
&amp;#x2F;&amp;#x2F; No hints, there&amp;#x27;s no tricks, just get used to typing these :)

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    &amp;#x2F;&amp;#x2F; Booleans (`bool`)

    let is_morning = true;
    if is_morning {
        println!(&amp;quot;Good morning!&amp;quot;);
    }

    let is_evening = false; &amp;#x2F;&amp;#x2F; easy enough to complete this as above
    if is_evening {
        println!(&amp;quot;Good evening!&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This works out pretty quickly, by just defining what &lt;code&gt;is_evening&lt;&#x2F;code&gt; is with &lt;code&gt;let is_evening = false;&lt;&#x2F;code&gt; we get the code to compile and it prints:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;🎉 🎉  The code is compiling! 🎉 🎉

Output:
====================
Good morning!

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Great, but what would happen if we make the both of them &lt;code&gt;true&lt;&#x2F;code&gt;? Let&#x27;s find out.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {
    &amp;#x2F;&amp;#x2F; Booleans (`bool`)

    let is_morning = true;
    if is_morning {
        println!(&amp;quot;Good morning!&amp;quot;);
    }

    let is_evening = true; &amp;#x2F;&amp;#x2F; making both `true`
    if is_evening {
        println!(&amp;quot;Good evening!&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This time we get a slightly different print, but the code still compiles.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;🎉 🎉  The code is compiling! 🎉 🎉

Output:
====================
Good morning!
Good evening!

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Simple enough, we&#x27;re on to the next one.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;primitive-types2-rs&quot;&gt;&lt;code&gt;primitive_types2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; primitive_types2.rs
&amp;#x2F;&amp;#x2F; Fill in the rest of the line that has code missing!
&amp;#x2F;&amp;#x2F; No hints, there&amp;#x27;s no tricks, just get used to typing these :)

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    &amp;#x2F;&amp;#x2F; Characters (`char`)

    &amp;#x2F;&amp;#x2F; Note the _single_ quotes, these are different from the double quotes
    &amp;#x2F;&amp;#x2F; you&amp;#x27;ve been seeing around.
    let my_first_initial = &amp;#x27;C&amp;#x27;;
    if my_first_initial.is_alphabetic() {
        println!(&amp;quot;Alphabetical!&amp;quot;);
    } else if my_first_initial.is_numeric() {
        println!(&amp;quot;Numerical!&amp;quot;);
    } else {
        println!(&amp;quot;Neither alphabetic nor numeric!&amp;quot;);
    }

    let &amp;#x2F;&amp;#x2F; Finish this line like the example! What&amp;#x27;s your favorite character?
    &amp;#x2F;&amp;#x2F; Try a letter, try a number, try a special character, try a character
    &amp;#x2F;&amp;#x2F; from a different language than your own, try an emoji!
    if your_character.is_alphabetic() {
        println!(&amp;quot;Alphabetical!&amp;quot;);
    } else if your_character.is_numeric() {
        println!(&amp;quot;Numerical!&amp;quot;);
    } else {
        println!(&amp;quot;Neither alphabetic nor numeric!&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again we have no hints, so we have pay close attention to the code and the errors we get from the Rust compiler.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected identifier, found keyword `if`
  --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types2.rs:24:5
   |
24 |     if your_character.is_alphabetic() {
   |     ^^ expected identifier, found keyword

error: expected one of `:`, `;`, `=`, `@`, or `|`, found `your_character`
  --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types2.rs:24:8
   |
24 |     if your_character.is_alphabetic() {
   |        ^^^^^^^^^^^^^^ expected one of `:`, `;`, `=`, `@`, or `|`

error: aborting due to 2 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This looks similar to what we got in our previous exercise, essentially telling us that the &lt;code&gt;your_character&lt;&#x2F;code&gt; part of the code is incomplete.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s go through the comments in the code.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The first comment in &lt;code&gt;fn main()&lt;&#x2F;code&gt;  tells us that we are looking at &lt;strong&gt;Characters&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Second comment makes sure that we notice the use of single quotes on the line &lt;code&gt;let my_first_intial = &#x27;C&#x27; &lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;The third comment tells us to finish the &lt;code&gt;let&lt;&#x2F;code&gt; statement using the example we&#x27;ve seen but use our favorite character.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Looking at how the rest of the code is written, to make it easier on us, we can use the &lt;code&gt;your_character&lt;&#x2F;code&gt; variable that is being used, but of course as the errors tells us, is undefined. Let&#x27;s define it.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {

    let my_first_initial = &amp;#x27;C&amp;#x27;;
    if my_first_initial.is_alphabetic() {
        println!(&amp;quot;Alphabetical!&amp;quot;);
    } else if my_first_initial.is_numeric() {
        println!(&amp;quot;Numerical!&amp;quot;);
    } else {
        println!(&amp;quot;Neither alphabetic nor numeric!&amp;quot;);
    }

    let your_character = &amp;#x27;🦀&amp;#x27;; &amp;#x2F;&amp;#x2F; we define it as a crab emoji just for fun.
    if your_character.is_alphabetic() {
        println!(&amp;quot;Alphabetical!&amp;quot;);
    } else if your_character.is_numeric() {
        println!(&amp;quot;Numerical!&amp;quot;);
    } else {
        println!(&amp;quot;Neither alphabetic nor numeric!&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;primitive-types3-rs&quot;&gt;&lt;code&gt;primitive_types3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; primitive_types3.rs
&amp;#x2F;&amp;#x2F; Create an array with at least 100 elements in it where the ??? is.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let a = ???

    if a.len() &amp;gt;= 100 {
        println!(&amp;quot;Wow, that&amp;#x27;s a big array!&amp;quot;);
    } else {
        println!(&amp;quot;Meh, I eat arrays like that for breakfast.&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we have clear instructions on what we need to do, and we even have a hint if we need it.  But let&#x27;s look at the errors first:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types3.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
 --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types3.rs:8:13
  |
8 |     let a = ???
  |             ^ expected expression

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Short and sweet, we see that on line 8, there&#x27;s an expected expression where we need to replace the &lt;code&gt;???&lt;&#x2F;code&gt; question marks. So what kind of expression do we need, well the instructions tell us it should be an array with at least 100 elements in it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;array-review&quot;&gt;Array Review&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s quickly review the ways that we can create an array in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;One of the simplest ways we can create an array in Rust is by using the &lt;code&gt;[]&lt;&#x2F;code&gt; square brackets and listing the elements inside of it, like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let a = [1, 2, 3, 4, 5, 6];
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can also define the array&#x27;s type by using another set of square brackets before the definition of the array, in a similar what that you define types when defining variables.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let a: [i32; 6] = [1, 2, 3, 4, 5, 6];
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These are both valid, but remember in our exercise we have to make an array with at least 100 elements in it -- there must be a better way. Luckily there is, as long as we want the array to contain the same value we can initialize the array like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let a = [3;5];
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This will give us an array called &lt;code&gt;a&lt;&#x2F;code&gt; with that will contain &lt;code&gt;5&lt;&#x2F;code&gt; elements with their value set to &lt;code&gt;3&lt;&#x2F;code&gt; this is the same as writing&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let a = [3, 3, 3, 3, 3];
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;but clearly in a more concise way.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;primitive-types3-rs-solution&quot;&gt;&lt;code&gt;primitive_types3.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have this information fresh in our minds we can clearly see the winning solution for our problem of having 100 elements in an array.
Let&#x27;s do it.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {
    let a = [1; 100];

    if a.len() &amp;gt;= 100 {
        println!(&amp;quot;Wow, that is a big array!&amp;quot;);
    } else {
        println!(&amp;quot;Meh, I eat arrays like that for breakfast.&amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We get this back from the compiler:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Wow, that is a big array!

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and just to confirm, what if we make the array less than 100 elements? Let&#x27;s just change the &lt;code&gt;100&lt;&#x2F;code&gt; to &lt;code&gt;99&lt;&#x2F;code&gt; like this: &lt;code&gt;let a = [1; 99];&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Meh, I eat arrays like that for breakfast.

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;primitive-types4-rs&quot;&gt;&lt;code&gt;primitive_types4.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; primitive_types4.rs
&amp;#x2F;&amp;#x2F; Get a slice out of Array a where the ??? is so that the test passes.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[test]
fn slice_out_of_array() {
    let a = [1, 2, 3, 4, 5];

    let nice_slice = ???

    assert_eq!([2, 3, 4], nice_slice)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;primitive-types4-rs-error&quot;&gt;&lt;code&gt;primitive_types4.rs&lt;&#x2F;code&gt; error&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types4.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types4.rs:11:22
   |
11 |     let nice_slice = ???
   |                      ^ expected expression

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this piece of code we see almost the exact same set-up having to define a variable, in this case we need to define it with a slice.  Remembering a slice is essentially how we refer to part of an array, remember when we had the 100 element array in the previous exercise, or even a bigger array that had thousands of elements. Well what if only needed to access part of the array? We would use a slice in this scenario so let&#x27;s do it.&lt;&#x2F;p&gt;
&lt;p&gt;We define a slice by using &lt;code&gt;&amp;amp;[ ]&lt;&#x2F;code&gt; the &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; makes it like a reference, so we don&#x27;t have ownership of the array, but we can go deeper into this another time, let&#x27;s just define this slice.&lt;&#x2F;p&gt;
&lt;p&gt;The error code is also very straightforward, we&#x27;re being told that we&#x27;re missing an expression.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;primitive-types4-rs-solution&quot;&gt;&lt;code&gt;primitive_types4.rs&lt;&#x2F;code&gt; solution&lt;&#x2F;h2&gt;
&lt;p&gt;we get a hint by the &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; part of the code as to what it&#x27;s looking for, elements &lt;code&gt;2&lt;&#x2F;code&gt;, &lt;code&gt;3&lt;&#x2F;code&gt;, and &lt;code&gt;4&lt;&#x2F;code&gt; so that&#x27;s what we&#x27;ll do.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn slice_out_of_array() {
    let a = [1, 2, 3, 4, 5];

    let nice_slice = &amp;amp;a[1..4]; &amp;#x2F;&amp;#x2F; using `a&amp;amp;[]` to create a slice we use the `..` to define the range

    assert_eq!([2, 3, 4], nice_slice)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So in this case we define the range to to be between &lt;code&gt;1 and 4&lt;&#x2F;code&gt; but remember that the first element in the array is at index &lt;code&gt;0&lt;&#x2F;code&gt; and element &lt;code&gt;4&lt;&#x2F;code&gt; is index &lt;code&gt;5&lt;&#x2F;code&gt;. Rust excludes the final element and therefore we get numbers &lt;code&gt;2, 3, 4&lt;&#x2F;code&gt; which correspond to index &lt;code&gt;1, 2, 3&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;All we get on this one is that the test is passing and code is compiling.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;🎉 🎉  The code is compiling, and the tests pass! 🎉 🎉
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Just to confirm what we&#x27;re talking about above, let&#x27;s use a different slice range that what know is the solution, let&#x27;s use &lt;code&gt;&amp;amp;a[0..5]&lt;&#x2F;code&gt; and see what happens.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let nice_slice = &amp;amp;a[0..5];
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;test-failed&quot;&gt;Test Failed&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;running 1 test
test slice_out_of_array ... FAILED

successes:

successes:

failures:

---- slice_out_of_array stdout ----
thread &amp;#x27;slice_out_of_array&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `[2, 3, 4]`,
 right: `[1, 2, 3, 4, 5]`&amp;#x27;, exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types4.rs:13:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    slice_out_of_array

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As expected the test fails, and we see the elements that we select by using the &lt;code&gt;&amp;amp;a[0..5]&lt;&#x2F;code&gt; makes the test panic because the &lt;code&gt;assertion failed: (left == right)&lt;&#x2F;code&gt; in our code the left doesn&#x27;t equal the right and we can see that we are accessing the elements starting at index &lt;code&gt;0&lt;&#x2F;code&gt; and ending at index &lt;code&gt;5&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;primitive-types5-rs&quot;&gt;&lt;code&gt;primitive_types5.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; primitive_types5.rs
&amp;#x2F;&amp;#x2F; Destructure the `cat` tuple so that the println will work.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let cat = (&amp;quot;Furry McFurson&amp;quot;, 3.5);
    let &amp;#x2F;* your pattern here *&amp;#x2F; = cat;

    println!(&amp;quot;{} is {} years old.&amp;quot;, name, age);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;primitive-types5-rs-error&quot;&gt;&lt;code&gt;primitive_types5.rs&lt;&#x2F;code&gt;  error&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types5.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected pattern, found `=`
 --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types5.rs:9:33
  |
9 |     let &amp;#x2F;* your pattern here *&amp;#x2F; = cat;
  |                                 ^ expected pattern

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions are to destructure the &lt;code&gt;cat&lt;&#x2F;code&gt; tuple so that the &lt;code&gt;println&lt;&#x2F;code&gt; will work, seems simple enough we have a clear indication in the code where this should take place, in our &lt;code&gt;let&lt;&#x2F;code&gt; variable assignment on line 8.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-tuple-type&quot;&gt;The Tuple Type&lt;&#x2F;h2&gt;
&lt;p&gt;So let&#x27;s quickly recap a Tuple and how we destructure it. A tuple is a compound type meaning that it can group together elements of different types, for example in our &lt;code&gt;let cat = (&amp;quot;Furry McFurson&amp;quot;, 3.5)&lt;&#x2F;code&gt; we can see that we have a &amp;amp;str and a floating-point type.
Let&#x27;s keep things simple for now and not go too deep into the &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; and what it means, for now we know it represents a string in our code.&lt;&#x2F;p&gt;
&lt;p&gt;So, another way we could have defined this tuple to be more explicit would have been like so (similar to our array in a previous exercise, where we defined the type for an array):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let cat: (&amp;amp;str, f64) = (&amp;quot;Furry McFurson&amp;quot;, 3.5);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we bind tuple to a variable, like in this case &lt;code&gt;cat&lt;&#x2F;code&gt; the variable is bound to the entire tuple as it&#x27;s considered a single compound element. So to get a single element out of the tuple we have to &lt;em&gt;destructure&lt;&#x2F;em&gt; the tuple by sort of inverting the variable like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let (a, b) = variable
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;primitive-types5-rs-solution&quot;&gt;&lt;code&gt;primitive_types5.rs&lt;&#x2F;code&gt;  solution&lt;&#x2F;h2&gt;
&lt;p&gt;In our case we can see that in the &lt;code&gt;println!&lt;&#x2F;code&gt; statement we are looking for a &lt;code&gt;name&lt;&#x2F;code&gt; and &lt;code&gt;age&lt;&#x2F;code&gt; elements, so let&#x27;s plug these into our code.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let cat = (&amp;quot;Furry McFurson&amp;quot;, 3.5);
    let (name, age) = cat;

    println!(&amp;quot;{} is {} years old.&amp;quot;, name, age);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s check our output&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Furry McFurson is 3.5 years old.

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;primitive-types6-rs&quot;&gt;&lt;code&gt;primitive_types6.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; primitive_types6.rs
&amp;#x2F;&amp;#x2F; Use a tuple index to access the second element of `numbers`.
&amp;#x2F;&amp;#x2F; You can put the expression for the second element where ??? is so that the test passes.
&amp;#x2F;&amp;#x2F; Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

#[test]
fn indexing_tuple() {
    let numbers = (1, 2, 3);
    &amp;#x2F;&amp;#x2F; Replace below ??? with the tuple indexing syntax.
    let second = ???;

    assert_eq!(2, second,
        &amp;quot;This is not the 2nd number in the tuple!&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;primitive-types6-rs-error&quot;&gt;&lt;code&gt;primitive_types6.rs&lt;&#x2F;code&gt;  error&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types6.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected expression, found `?`
  --&amp;gt; exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types6.rs:12:18
   |
12 |     let second = ???;
   |                  ^ expected expression

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our instructions say to use a tuple index to access the second element of &lt;code&gt;numbers&lt;&#x2F;code&gt; and we can use place the expression in line 12 where the &lt;code&gt;let second = ???&lt;&#x2F;code&gt;, simple enough.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tuple-indexing&quot;&gt;Tuple Indexing&lt;&#x2F;h2&gt;
&lt;p&gt;But how do we access a tuple directly? By using the variable a period &lt;code&gt;.&lt;&#x2F;code&gt; followed by the index value.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let indexing = variable.0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright then, let&#x27;s apply this to our problem.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;primitive-types6-rs-solution&quot;&gt;&lt;code&gt;primitive_types6.rs&lt;&#x2F;code&gt;  solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[test]
fn indexing_tuple() {
    let numbers = (1, 2, 3);

    let second = numbers.1; &amp;#x2F;&amp;#x2F; using the tuple indexing syntax to get the 2nd element which is at index `1`

    assert_eq!(2, second, &amp;quot;This is not the 2nd number in the tuple!&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The only tricky part is to remember that indexes start at &lt;code&gt;0&lt;&#x2F;code&gt; so the second element is at index &lt;code&gt;1&lt;&#x2F;code&gt;. So if we were for example to change the &lt;code&gt;number.1&lt;&#x2F;code&gt; to &lt;code&gt;number.2&lt;&#x2F;code&gt;, if we mistakenly thought the correct index was &lt;code&gt;2&lt;&#x2F;code&gt; we&#x27;d get this text in our test:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;running 1 test
test indexing_tuple ... FAILED

successes:

successes:

failures:

---- indexing_tuple stdout ----
thread &amp;#x27;indexing_tuple&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `2`,
 right: `3`: This is not the 2nd number in the tuple!&amp;#x27;, exercises&amp;#x2F;primitive_types&amp;#x2F;primitive_types6.rs:14:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    indexing_tuple

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With the correct index number we don&#x27;t get anything special but a celebratory &lt;code&gt;code is compiling &lt;&#x2F;code&gt; message.  &lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this post, we tackled various exercises related to primitive types in Rust. We explored arrays, tuples, slices, and tuple indexing while understanding how to create and manipulate them. We also learned about the error messages provided by the Rust compiler and how to interpret and resolve them to make our code work as expected.&lt;&#x2F;p&gt;
&lt;p&gt;These exercises are essential for building a strong foundation in Rust, as primitive types are the building blocks for more complex data structures and programs. By mastering these concepts, you&#x27;ll be well-prepared to tackle more advanced Rust topics and further enhance your Rust programming skills.&lt;&#x2F;p&gt;
&lt;p&gt;Keep practicing and exploring the Rust language, and don&#x27;t forget to consult the official Rust documentation when in doubt!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>04 Rustlings quiz1</title>
          <pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/04-rustlings-quiz1/</link>
          <guid>https://desmodrone.github.io/posts/04-rustlings-quiz1/</guid>
          <description>&lt;p&gt;Now we have our first quiz building on what we&#x27;ve learned so far. Here is the code and instructions written in the comments.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;quiz1-rs&quot;&gt;&lt;code&gt;quiz1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; quiz1.rs
&amp;#x2F;&amp;#x2F; This is a quiz for the following sections:
&amp;#x2F;&amp;#x2F; - Variables
&amp;#x2F;&amp;#x2F; - Functions
&amp;#x2F;&amp;#x2F; - If

&amp;#x2F;&amp;#x2F; Mary is buying apples. The price of an apple is calculated as follows:
&amp;#x2F;&amp;#x2F; - An apple costs 2 rustbucks.
&amp;#x2F;&amp;#x2F; - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!
&amp;#x2F;&amp;#x2F; Write a function that calculates the price of an order of apples given
&amp;#x2F;&amp;#x2F; the quantity bought. No hints this time!

&amp;#x2F;&amp;#x2F; I AM NOT DONE

&amp;#x2F;&amp;#x2F; Put your function here!
&amp;#x2F;&amp;#x2F; fn calculate_price_of_apples {

&amp;#x2F;&amp;#x2F; Don&amp;#x27;t modify this function!
#[test]
fn verify_test() {
    let price1 = calculate_price_of_apples(35);
    let price2 = calculate_price_of_apples(40);
    let price3 = calculate_price_of_apples(41);
    let price4 = calculate_price_of_apples(65);

    assert_eq!(70, price1);
    assert_eq!(80, price2);
    assert_eq!(41, price3);
    assert_eq!(65, price4);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is pretty straight forward, it&#x27;s clear we have to write a little bit of code, let&#x27;s recap what we know.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Mary is buying apples.&lt;&#x2F;li&gt;
&lt;li&gt;each apple is worth 2 rustbucks.&lt;&#x2F;li&gt;
&lt;li&gt;If Mary purchases more than 40 apples, the apple price for each goes down to 1 rust buck for each apple.&lt;&#x2F;li&gt;
&lt;li&gt;We need to create a function that calculates the correct price given the amount of apples purchased&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;quiz1-rs-errors&quot;&gt;&lt;code&gt;quiz1.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;quiz1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0425]: cannot find function `calculate_price_of_apples` in this scope
  --&amp;gt; exercises&amp;#x2F;quiz1.rs:21:18
   |
21 |     let price1 = calculate_price_of_apples(35);
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `calculate_price_of_apples` in this scope
  --&amp;gt; exercises&amp;#x2F;quiz1.rs:22:18
   |
22 |     let price2 = calculate_price_of_apples(40);
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `calculate_price_of_apples` in this scope
  --&amp;gt; exercises&amp;#x2F;quiz1.rs:23:18
   |
23 |     let price3 = calculate_price_of_apples(41);
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `calculate_price_of_apples` in this scope
  --&amp;gt; exercises&amp;#x2F;quiz1.rs:24:18
   |
24 |     let price4 = calculate_price_of_apples(65);
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We are getting are getting 4 errors all related to the &lt;code&gt;calculate_price_of_apples&lt;&#x2F;code&gt; function being out of scope. Well, that should be pretty obvious as to why, it&#x27;s not there...or in this case commented out.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;working-on-a-solution&quot;&gt;Working on a Solution&lt;&#x2F;h2&gt;
&lt;p&gt;As noted in the errors, we need to implement the function &lt;code&gt;fn_calculate_price_of_apples&lt;&#x2F;code&gt; so let&#x27;s start there, by removing the comment forward slashes. We&#x27;ll just add the code here without the additional comments.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Put your function here!
   fn calculate_price_of_apples {

&amp;#x2F;&amp;#x2F; Don&amp;#x27;t modify this function!
#[test]
fn verify_test() {
    let price1 = calculate_price_of_apples(35);
    let price2 = calculate_price_of_apples(40);
    let price3 = calculate_price_of_apples(41);
    let price4 = calculate_price_of_apples(65);

    assert_eq!(70, price1);
    assert_eq!(80, price2);
    assert_eq!(41, price3);
    assert_eq!(65, price4);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we think of what we&#x27;ve learned so far: &lt;code&gt;variables&lt;&#x2F;code&gt;, &lt;code&gt;if&lt;&#x2F;code&gt; statements and &lt;code&gt;functions&lt;&#x2F;code&gt; we should be able to use these and apply them to our quiz here, let&#x27;s start the function signature, we need to be explicit when defining our function signatures in Rust, so our function signature is missing a whole lot of information.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;completing-our-function-signature&quot;&gt;Completing our Function Signature&lt;&#x2F;h2&gt;
&lt;p&gt;If we need any hints we can go back to our &lt;code&gt;function&lt;&#x2F;code&gt; lesson and see how this current function looks incomplete, we should quickly notice that our current function signature looks incomplete compared to our previous exercises, so let&#x27;s fix that, by defining a variable that gets passed through the function as an &lt;code&gt;i32&lt;&#x2F;code&gt;, as well as adding a return value of &lt;code&gt;i32&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; how it&amp;#x27;s currently defined

fn calculate_price_of_apples {

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is how we&#x27;re going to update the function signature:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;add the parameters of &lt;code&gt;apples:i32&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;add a return value of &lt;code&gt;i32&lt;&#x2F;code&gt; so we can get that number from the function.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; passing through an `i32` that we define as `apples`

fn calculate_price_of_apples(apples:i32) -&amp;gt; i32 {

&amp;#x2F;&amp;#x2F; also adding the ` -&amp;gt; i32` to show that we&amp;#x27;ll also return an `i32`

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;adding-variables&quot;&gt;Adding Variables&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at variables we have to create inside of our function to complete the calculation of our price.
I guess the most logical variables would be the price right, we have the regular price and the discount price.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn calculate_price_of_apples(apples: i32) -&amp;gt; i32 {
	let regular_price: i32 = 2; &amp;#x2F;&amp;#x2F; defining a regular price
	let discount_price: i32 = 1; &amp;#x2F;&amp;#x2F; defining a dicount price
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Easy enough right? We have defined a &lt;code&gt;regular_price&lt;&#x2F;code&gt; and a &lt;code&gt;discount_price&lt;&#x2F;code&gt; is based on the information we were given. Now let&#x27;s go to the next step in our function defining our &lt;code&gt;if&lt;&#x2F;code&gt; expression.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;controlling-our-conditions-with-if&quot;&gt;Controlling our Conditions with &lt;code&gt;if&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s quickly recap what we tools we have made so far:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We&#x27;ve defined our function signature so it takes and returns and &lt;code&gt;i32&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;We&#x27;ve created two different variables that define a &lt;code&gt;regular_price&lt;&#x2F;code&gt; or a &lt;code&gt;discounted_price&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Now we need a way to let our function choose a branch of code depending the quantity of apples. The &lt;code&gt;if&lt;&#x2F;code&gt; keyword let&#x27;s us do this as we previously learned in lesson 3 so let&#x27;s implement this within our function.&lt;&#x2F;p&gt;
&lt;p&gt;First let&#x27;s think about this in plain English, remembering that Mary get&#x27;s a price break &lt;em&gt;after&lt;&#x2F;em&gt; apple number 40, we can say that &amp;quot;if Mary buys 40 or less apples&amp;quot; it&#x27;s regular price, &amp;quot;if Mary buys 41 or more apples&amp;quot; it&#x27;s a discount price. Of course in code it&#x27;s a little different and we can always reference the &lt;code&gt;if&lt;&#x2F;code&gt; lesson for the syntax.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn calculate_price_of_apples(apples: i32) -&amp;gt; i32 {
	let regular_price: i32 = 2;
	let discount_price: i32 = 1;
	   &amp;#x2F;&amp;#x2F; defining if the quantity of `apples` purchased are 40 or less
	   if apples &amp;lt;= 40 {
		&amp;#x2F;&amp;#x2F; here&amp;#x27;s the simple math to calculate the result
		apples * regular_price
		&amp;#x2F;&amp;#x2F; `else` let&amp;#x27;s us add the other part of the expression
		} else {
		 &amp;#x2F;&amp;#x2F; this multiples the number of apples which are above 40
		apples * discount_price
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And that&#x27;s it, our code compiles and passes all tests, so we&#x27;ve finished our first quiz. This is what the final full code will look like, without all the comments for visual clarity:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn calculate_price_of_apples(apples: i32) -&amp;gt; i32 {
    let regular_price: i32 = 2;
    let discount_price: i32 = 1;

    if apples &amp;lt;= 40 {

        apples * regular_price
    } else {
        apples * discount_price
    }
}
&amp;#x2F;&amp;#x2F; Don&amp;#x27;t modify this function!
#[test]
fn verify_test() {
    let price1 = calculate_price_of_apples(35);
    let price2 = calculate_price_of_apples(40);
    let price3 = calculate_price_of_apples(41);
    let price4 = calculate_price_of_apples(65);

    assert_eq!(70, price1);
    assert_eq!(80, price2);
    assert_eq!(41, price3);
    assert_eq!(65, price4);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we reviewed a Rust quiz about variables, functions, and if statements. We worked through the errors provided by the compiler and wrote a solution to calculate the price of apples based on the quantity bought. We first defined the function signature, which was incomplete, and added the appropriate information to pass and return an &lt;code&gt;i32&lt;&#x2F;code&gt;. We then created variables for the regular and discounted prices of the apples. Finally, we used an &lt;code&gt;if&lt;&#x2F;code&gt; expression to control the calculation of the price based on the quantity of apples bought, with a break for the discounted price starting at 40 apples.&lt;&#x2F;p&gt;
&lt;p&gt;By working through this quiz, we demonstrated how to apply the concepts of variables, functions, and if statements in Rust to solve a problem. We hope this blog post provides a clear and helpful review of these concepts and helps you better understand how to use them in your own Rust programming.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>03 Rustlings if</title>
          <pubDate>Fri, 21 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/03-rustlings-if/</link>
          <guid>https://desmodrone.github.io/posts/03-rustlings-if/</guid>
          <description>&lt;p&gt;&lt;code&gt;if&lt;&#x2F;code&gt;, is the most basic but still very versatile type of control flow, these next couple of exercises will go through this little word.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;additional-reading&quot;&gt;Additional Reading&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch03-05-control-flow.html#if-expressions&quot;&gt;Control Flow - if expressions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;if1-rs&quot;&gt;&lt;code&gt;if1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; if1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub fn bigger(a: i32, b: i32) -&amp;gt; i32 {
    &amp;#x2F;&amp;#x2F; Complete this function to return the bigger number!
    &amp;#x2F;&amp;#x2F; Do not use:
    &amp;#x2F;&amp;#x2F; - another function call
    &amp;#x2F;&amp;#x2F; - additional variables
}

&amp;#x2F;&amp;#x2F; Don&amp;#x27;t mind this for now :)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ten_is_bigger_than_eight() {
        assert_eq!(10, bigger(10, 8));
    }

    #[test]
    fn fortytwo_is_bigger_than_thirtytwo() {
        assert_eq!(42, bigger(32, 42));
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright looks like we have our first real writing of some basic code -- we need to create an &lt;code&gt;if&lt;&#x2F;code&gt; statement that will compare 2 numbers or variables &lt;code&gt;a&lt;&#x2F;code&gt; or &lt;code&gt;b&lt;&#x2F;code&gt; and return which one is bigger.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;if1-rs-errors&quot;&gt;&lt;code&gt;if1.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;if&amp;#x2F;if1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
 --&amp;gt; exercises&amp;#x2F;if&amp;#x2F;if1.rs:6:34
  |
6 | pub fn bigger(a: i32, b: i32) -&amp;gt; i32 {
  |        ------                    ^^^ expected `i32`, found `()`
  |        |
  |        implicitly returns `()` as its body has no tail or `return` expression
  |
note: consider returning one of these bindings
 --&amp;gt; exercises&amp;#x2F;if&amp;#x2F;if1.rs:6:15
  |
6 | pub fn bigger(a: i32, b: i32) -&amp;gt; i32 {
  |               ^       ^

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s look at what the &lt;code&gt;rust_errors&lt;&#x2F;code&gt; are telling us here.&lt;&#x2F;p&gt;
&lt;p&gt;The line &lt;code&gt;^^^ expected&lt;&#x2F;code&gt;i32&lt;code&gt;, found &lt;&#x2F;code&gt;()`` is essentially telling us that there is no return expression because there is nothing in the body of the function &lt;code&gt;bigger&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The solution is pretty simple, it&#x27;s  to add an &lt;code&gt;if&lt;&#x2F;code&gt; &lt;code&gt;a &amp;lt; b&lt;&#x2F;code&gt; expression.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;if1-rs-solution&quot;&gt;&lt;code&gt;if1.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn bigger(a: i32, b: i32) -&amp;gt; i32 {
    if a &amp;lt; b {
        b
    } else {
        a
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This compiles but the hint reminds me that it can also be done in one line, let&#x27;s try that, it works just fine and looks like this&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn bigger(a: i32, b:i32) -&amp;gt; i32 {
	if a &amp;lt; b { b } else { a }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I&#x27;m also reminded that :&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;in Rust the &lt;code&gt;if&lt;&#x2F;code&gt; condition doesn&#x27;t need to be surrounded by parentheses&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;if&#x2F;else&lt;&#x2F;code&gt; conditionals are expressions&lt;&#x2F;li&gt;
&lt;li&gt;Each condition is followed by a &lt;code&gt;{}&lt;&#x2F;code&gt; block&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Okay, let&#x27;s move on to the next exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;if2-rs&quot;&gt;&lt;code&gt;if2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; if2.rs

&amp;#x2F;&amp;#x2F; Step 1: Make me compile!
&amp;#x2F;&amp;#x2F; Step 2: Get the bar_for_fuzz and default_to_baz tests passing!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub fn foo_if_fizz(fizzish: &amp;amp;str) -&amp;gt; &amp;amp;str {
    if fizzish == &amp;quot;fizz&amp;quot; {
        &amp;quot;foo&amp;quot;
    } else {
        1
    }
}

&amp;#x2F;&amp;#x2F; No test changes needed!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn foo_for_fizz() {
        assert_eq!(foo_if_fizz(&amp;quot;fizz&amp;quot;), &amp;quot;foo&amp;quot;)
    }

    #[test]
    fn bar_for_fuzz() {
        assert_eq!(foo_if_fizz(&amp;quot;fuzz&amp;quot;), &amp;quot;bar&amp;quot;)
    }

    #[test]
    fn default_to_baz() {
        assert_eq!(foo_if_fizz(&amp;quot;literally anything&amp;quot;), &amp;quot;baz&amp;quot;)
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;if2-rs-errors&quot;&gt;&lt;code&gt;if2.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;if&amp;#x2F;if2.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;if&amp;#x2F;if2.rs:13:9
   |
9  | pub fn foo_if_fizz(fizzish: &amp;amp;str) -&amp;gt; &amp;amp;str {
   |                                      ---- expected `&amp;amp;str` because of return type
...
13 |         1
   |         ^ expected `&amp;amp;str`, found integer

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first comments state that we first have to make the code compile, so the first thing to do in this case is to add the &lt;code&gt;bar&lt;&#x2F;code&gt; by replacing the &lt;code&gt;1&lt;&#x2F;code&gt; which the Rust compile clearly states that it expected an &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; and this is an integer.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; if2.rs

&amp;#x2F;&amp;#x2F; Step 1: Make me compile!
&amp;#x2F;&amp;#x2F; Step 2: Get the bar_for_fuzz and default_to_baz tests passing!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub fn foo_if_fizz(fizzish: &amp;amp;str) -&amp;gt; &amp;amp;str {
    if fizzish == &amp;quot;fizz&amp;quot; {
        &amp;quot;foo&amp;quot;
    } else {
        &amp;quot;bar&amp;quot; &amp;#x2F;&amp;#x2F; add bar to get it to compile
    }
}

&amp;#x2F;&amp;#x2F; No test changes needed!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn foo_for_fizz() {
        assert_eq!(foo_if_fizz(&amp;quot;fizz&amp;quot;), &amp;quot;foo&amp;quot;)
    }

    #[test]
    fn bar_for_fuzz() {
        assert_eq!(foo_if_fizz(&amp;quot;fuzz&amp;quot;), &amp;quot;bar&amp;quot;)
    }

    #[test]
    fn default_to_baz() {
        assert_eq!(foo_if_fizz(&amp;quot;literally anything&amp;quot;), &amp;quot;baz&amp;quot;)
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once we replace this with &lt;code&gt;bar&lt;&#x2F;code&gt; it compiles, but it still doesn&#x27;t pass the test, which is our step 2. in the comments.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Testing of exercises&amp;#x2F;if&amp;#x2F;if2.rs failed! Please try again. Here&amp;#x27;s the output:

running 3 tests
test tests::bar_for_fuzz ... ok
test tests::foo_for_fizz ... ok
test tests::default_to_baz ... FAILED

successes:

successes:
    tests::bar_for_fuzz
    tests::foo_for_fizz

failures:

---- tests::default_to_baz stdout ----
thread &amp;#x27;tests::default_to_baz&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `&amp;quot;bar&amp;quot;`,
 right: `&amp;quot;baz&amp;quot;`&amp;#x27;, exercises&amp;#x2F;if&amp;#x2F;if2.rs:34:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::default_to_baz

test result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So here we see that the first two test are passing &lt;code&gt;bar_for_fuzz&lt;&#x2F;code&gt; and &lt;code&gt;foo_for_fizz&lt;&#x2F;code&gt; but &lt;code&gt;default_to_baz&lt;&#x2F;code&gt; is not. So let&#x27;s take a closer look at the tests and see why this is happening.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;foo-for-fizz-test&quot;&gt;&lt;code&gt;foo_for_fizz&lt;&#x2F;code&gt; test&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    #[test]
    fn foo_for_fizz() {
        assert_eq!(foo_if_fizz(&amp;quot;fizz&amp;quot;), &amp;quot;foo&amp;quot;) &amp;#x2F;&amp;#x2F; first test clearly defined in our `if` statement
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which is in our code with&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;if fizzish == &amp;quot;fizz&amp;quot; {
	&amp;quot;foo&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;bar-for-fuzz-test&quot;&gt;&lt;code&gt;bar_for_fuzz&lt;&#x2F;code&gt; test&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    #[test]
    fn bar_for_fuzz() {
        assert_eq!(foo_if_fizz(&amp;quot;fuzz&amp;quot;), &amp;quot;bar&amp;quot;) &amp;#x2F;&amp;#x2F; if we have &amp;quot;fuzz&amp;quot; we should get &amp;quot;bar&amp;quot;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This tells us that if have &lt;code&gt;Fuzz&lt;&#x2F;code&gt; then we get bar, but this is working only because we have &lt;code&gt;&amp;quot;bar&amp;quot;&lt;&#x2F;code&gt; as our &lt;code&gt;else&lt;&#x2F;code&gt; not because we have &lt;code&gt;&amp;quot;fuzz&amp;quot;&lt;&#x2F;code&gt; defined.&lt;&#x2F;p&gt;
&lt;p&gt;We do so by adding an &lt;code&gt;else if&lt;&#x2F;code&gt; statement like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;else if fizzish == &amp;quot;fuzz&amp;quot; {
	&amp;quot;bar&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This will meet the conditions of our second test&lt;&#x2F;p&gt;
&lt;h2 id=&quot;default-to-baz-test&quot;&gt;&lt;code&gt;default_to_baz&lt;&#x2F;code&gt; test&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[test]
    fn default_to_baz() {
        assert_eq!(foo_if_fizz(&amp;quot;literally anything&amp;quot;), &amp;quot;baz&amp;quot;)
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In our final test we see that it&#x27;s saying whatever else, doesn&#x27;t matter what it is, just give me &lt;code&gt;&amp;quot;baz&amp;quot;&lt;&#x2F;code&gt; so we can easily do that by adding our final &lt;code&gt;else&lt;&#x2F;code&gt; condition to our &lt;code&gt;foo_if_fizz&lt;&#x2F;code&gt; function, that would look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn foo_if_fizz(fizzish: &amp;amp;str) -&amp;gt; &amp;amp;str {
    if fizzish == &amp;quot;fizz&amp;quot; {
        &amp;quot;foo&amp;quot;
    } else if fizzish == &amp;quot;fuzz&amp;quot; {
        &amp;quot;bar&amp;quot;
    } else { &amp;#x2F;&amp;#x2F; whatever else it is, just make it `&amp;quot;baz&amp;quot;`
        &amp;quot;baz&amp;quot;
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This gets our code to compile and pass it&#x27;s tests successfully.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Progress: [########&amp;gt;---------------------------------------------------] 14&amp;#x2F;94
✅ Successfully tested exercises&amp;#x2F;if&amp;#x2F;if2.rs!

🎉 🎉  The code is compiling, and the tests pass! 🎉 🎉
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright, I guess we get our first quiz after this 😧.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we delved into Rust &lt;code&gt;if&lt;&#x2F;code&gt; expressions, which are a fundamental part of the language&#x27;s control flow. We explored how to use &lt;code&gt;if&lt;&#x2F;code&gt;, &lt;code&gt;else if&lt;&#x2F;code&gt;, and &lt;code&gt;else&lt;&#x2F;code&gt; statements to create conditionals and solve problems in Rust. Additionally, we learned about Rust&#x27;s unique features, such as not requiring parentheses around &lt;code&gt;if&lt;&#x2F;code&gt; conditions and the treatment of &lt;code&gt;if&#x2F;else&lt;&#x2F;code&gt; conditionals as expressions. By understanding and mastering Rust &lt;code&gt;if&lt;&#x2F;code&gt; expressions, you&#x27;ll be better equipped to write efficient and clean Rust code for various applications.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>02 Rustlings functions</title>
          <pubDate>Wed, 19 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/02-rustlings-functions/</link>
          <guid>https://desmodrone.github.io/posts/02-rustlings-functions/</guid>
          <description>&lt;p&gt;With function we can learn to write more complex code and lean on the Rust debug errors for help.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch03-03-how-functions-work.html&quot;&gt;How Functions Work&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;functions1-rs&quot;&gt;&lt;code&gt;functions1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    call_me();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;rust-error-for-function1-rs&quot;&gt;Rust Error for &lt;code&gt;function1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s take a look at the compiler output so we can see what it&#x27;s telling us fix.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️ Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0425]: cannot find function `call_me` in this scope
 --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions1.rs:7:5
  |
7 |     call_me();
  |     ^^^^^^^ not found in this scope

error: aborting due to previous error

For more information about this error, try `rustc --explain E0425`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So what is this telling us? It&#x27;s essentially saying that &lt;code&gt;call me&lt;&#x2F;code&gt; is not defined within &lt;code&gt;fn main()&lt;&#x2F;code&gt; because we&#x27;re trying to call it, but it doesn&#x27;t know what to do with it. So let&#x27;s fix it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function1-rs-solution&quot;&gt;&lt;code&gt;function1.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.

fn main() {
    fn call_me() {  &amp;#x2F;&amp;#x2F; we define a basic function called call_me()
    }
    call_me();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s easy enough we create a functioned called &lt;code&gt;call_me()&lt;&#x2F;code&gt; inside of our &lt;code&gt;fn main()&lt;&#x2F;code&gt; so when we call it, the compiler knows where to look. Of course at this point it&#x27;s not doing much of anything.&lt;&#x2F;p&gt;
&lt;p&gt;We can modify this a little and make the function do something, like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    fn call_me() {
        println!(&amp;quot;Call me please&amp;quot;) &amp;#x2F;&amp;#x2F; add a println! with at string inside the call_me() function
    }
    call_me();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Putting a &lt;code&gt;println!&lt;&#x2F;code&gt; with some text will print out the text when &lt;code&gt;call_me()&lt;&#x2F;code&gt; is called. In this case: &lt;code&gt;Call me please&lt;&#x2F;code&gt; or if we wanted to some math, we could do:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.

fn main() {
    fn call_me() {
        println!(&amp;quot;{}&amp;quot;, 4+4) &amp;#x2F;&amp;#x2F; here we change the string into a simple addition
    }
    call_me();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This would print: &lt;code&gt;8&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function2-rs&quot;&gt;&lt;code&gt;function2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    call_me(3);
}

fn call_me(num:) {
    for i in 0..num {
        println!(&amp;quot;Ring! Call number {}&amp;quot;, i + 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;rust-errors-for-function2-rs&quot;&gt;Rust Errors for &lt;code&gt;function2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected type, found `)`
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions2.rs:10:16
   |
10 | fn call_me(num:) {
   |                ^ expected type

error[E0425]: cannot find value `num` in this scope
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions2.rs:11:17
   |
11 |     for i in 0..num {
   |                 ^^^ not found in this scope
   |
help: you might have meant to write `.` instead of `..`
   |
11 -     for i in 0..num {
11 +     for i in 0.num {
   |

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0425`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright so I&#x27;ve got a couple of errors here:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Line 10, there&#x27;s a type expected, so we fix that by adding &lt;code&gt;i32&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Adding the type solved all of our problems, nothing else do here.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function2-rs-solution&quot;&gt;&lt;code&gt;function2.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.

fn main() {
    call_me(3);
}

fn call_me(num: i32) { &amp;#x2F;&amp;#x2F; added the `i32` type here
    for i in 0..num {
        println!(&amp;quot;Ring! Call number {}&amp;quot;, i + 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This reminds us that Rust&#x27;s function signatures require type annotations. Once we fixed the function&#x27;s signature we get the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Ring! Call number 1
Ring! Call number 2
Ring! Call number 3

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;function3-rs&quot;&gt;&lt;code&gt;function3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions3.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    call_me();
}

fn call_me(num: u32) {
    for i in 0..num {
        println!(&amp;quot;Ring! Call number {}&amp;quot;, i + 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;rust-errors-for-function3-rs&quot;&gt;Rust errors for &lt;code&gt;function3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions3.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0061]: this function takes 1 argument but 0 arguments were supplied
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions3.rs:7:5
   |
7  |     call_me();
   |     ^^^^^^^-- an argument of type `u32` is missing
   |
note: function defined here
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions3.rs:10:4
   |
10 | fn call_me(num: u32) {
   |    ^^^^^^^ --------
help: provide the argument
   |
7  |     call_me(&amp;#x2F;* u32 *&amp;#x2F;);
   |            ~~~~~~~~~~~

error: aborting due to previous error

For more information about this error, try `rustc --explain E0061`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once again the Rust compiler comes through with a very clear suggestion pointing out that &lt;code&gt;call_me()&lt;&#x2F;code&gt; is missing an argument of type &lt;code&gt;u32&lt;&#x2F;code&gt; it even provides &lt;code&gt;help&lt;&#x2F;code&gt; in the last segment showing us where to put the &lt;code&gt;u32&lt;&#x2F;code&gt;: &lt;code&gt;call_me(&#x2F;* u32 *&#x2F;);&lt;&#x2F;code&gt; How great is that. So what &lt;code&gt;u32&lt;&#x2F;code&gt; should we put in there? Let&#x27;s try &lt;code&gt;6&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;functions3-rs-solution&quot;&gt;&lt;code&gt;functions3.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions3.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions3` or use the `hint` watch subcommand for a hint.

fn main() {
    call_me(6); &amp;#x2F;&amp;#x2F; we&amp;#x27;ve added 6 here
}

fn call_me(num: u32) {
    for i in 0..num {
        println!(&amp;quot;Ring! Call number {}&amp;quot;, i + 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And just like that we&#x27;re back in business. Our &lt;code&gt;fn main()&lt;&#x2F;code&gt; runs and calls &lt;code&gt;call_me&lt;&#x2F;code&gt; six times because that&#x27;s the number we&#x27;ve passed in to &lt;code&gt;call_me(6)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Ring! Call number 1
Ring! Call number 2
Ring! Call number 3
Ring! Call number 4
Ring! Call number 5
Ring! Call number 6

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Just to be clear in this case we could put any &lt;code&gt;u32&lt;&#x2F;code&gt; we wanted, including &lt;code&gt;0&lt;&#x2F;code&gt;, but that doesn&#x27;t print anything. We can&#x27;t pass in a negative number in this case either because defined a &lt;code&gt;u32&lt;&#x2F;code&gt; and exceeding the limit of a &lt;code&gt;u32&lt;&#x2F;code&gt; would also fail.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function4-rs&quot;&gt;&lt;code&gt;function4.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions4.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions4` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; This store is having a sale where if the price is an even number, you get
&amp;#x2F;&amp;#x2F; 10 Rustbucks off, but if it&amp;#x27;s an odd number, it&amp;#x27;s 3 Rustbucks off.
&amp;#x2F;&amp;#x2F; (Don&amp;#x27;t worry about the function bodies themselves, we&amp;#x27;re only interested
&amp;#x2F;&amp;#x2F; in the signatures for now. If anything, this is a good way to peek ahead
&amp;#x2F;&amp;#x2F; to future exercises!)

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let original_price = 51;
    println!(&amp;quot;Your sale price is {}&amp;quot;, sale_price(original_price));
}

fn sale_price(price: i32) -&amp;gt; {
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
}

fn is_even(num: i32) -&amp;gt; bool {
    num % 2 == 0
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;re getting a little more instruction here, but as always the key lies in looking at the Rust compiler&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions4.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected type, found `{`
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions4.rs:17:30
   |
17 | fn sale_price(price: i32) -&amp;gt; {
   |                              ^ expected type

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Looks pretty straight forward, line 17 is missing a type in the function&#x27;s signature, looks like we should expect to return an &lt;code&gt;i32&lt;&#x2F;code&gt;, so let&#x27;s try that.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let original_price = 51;
    println!(&amp;quot;Your sale price is {}&amp;quot;, sale_price(original_price));
}

fn sale_price(price: i32) -&amp;gt; i32 { &amp;#x2F;&amp;#x2F; added return type here: `i32`
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
}

fn is_even(num: i32) -&amp;gt; bool {
    num % 2 == 0
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And it works. Nothing too difficult, if you look at the &lt;code&gt;is_even&lt;&#x2F;code&gt; function there the function is returning a &lt;code&gt;bool&lt;&#x2F;code&gt; instead of an &lt;code&gt;i32&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Your sale price is 48

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;function5-rs&quot;&gt;&lt;code&gt;function5.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions5.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions5` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let answer = square(3);
    println!(&amp;quot;The square of 3 is {}&amp;quot;, answer);
}

fn square(num: i32) -&amp;gt; i32 {
    num * num;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;function5-rs-errors&quot;&gt;&lt;code&gt;function5.rs&lt;&#x2F;code&gt; Errors&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions5.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions5.rs:11:24
   |
11 | fn square(num: i32) -&amp;gt; i32 {
   |    ------              ^^^ expected `i32`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
12 |     num * num;
   |              - help: remove this semicolon to return this value

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is once again a very helpful explanation from the compiler, if we look at the &lt;code&gt;help: remove this semicolon to return this value&lt;&#x2F;code&gt; note, it tells why we are getting the error on line 11. Because with a &lt;code&gt;;&lt;&#x2F;code&gt; semicolon this function has no return value and this function expects a return value as we have defined in the function signature. So how do we solve this?&lt;&#x2F;p&gt;
&lt;p&gt;The easiest way is to remove the semicolon as the Rust compiler suggests, but just so we have another solution we can also use the &lt;code&gt;return&lt;&#x2F;code&gt; keyword. From my understanding it&#x27;s more idiomatic to just remove the &lt;code&gt;;&lt;&#x2F;code&gt; but I wanted to also bring up the possibility of using &lt;code&gt;return&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The reason this happens in Rust is because the compiler distinguishes between expressions and statements. Expressions return a value based on their operands(s), and statements simply return a &lt;code&gt;()&lt;&#x2F;code&gt; type.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function5-rs-solution&quot;&gt;&lt;code&gt;function5.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let answer = square(3);
    println!(&amp;quot;The square of 3 is {}&amp;quot;, answer);
}

fn square(num: i32) -&amp;gt; i32 {
    num * num
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
The square of 3 is 9

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we&#x27;ve explored various Rust functions and the importance of function signatures, including specifying the correct types for both input parameters and return values. We have also seen how the Rust compiler provides helpful error messages and suggestions to guide us in fixing issues with our code. Additionally, we&#x27;ve briefly touched upon the differences between expressions and statements in Rust, which determine whether a value is returned or not.&lt;&#x2F;p&gt;
&lt;p&gt;Remember that Rust functions are powerful tools for writing clean, maintainable code. Keep practicing and exploring different function patterns, and you&#x27;ll soon become proficient in writing complex Rust programs.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>01 Rustlings variables</title>
          <pubDate>Mon, 17 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/01-rustlings-variables/</link>
          <guid>https://desmodrone.github.io/posts/01-rustlings-variables/</guid>
          <description>&lt;p&gt;In Rust, variables are immutable by default.
When a variable is immutable, once a value is bound to a name, you can’t change that value.
You can however, make a variable mutable by adding &lt;code&gt;mut&lt;&#x2F;code&gt; in front of the variable name.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-reading&quot;&gt;Further reading:&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch03-01-variables-and-mutability.html&quot;&gt;Variables and Mutability&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;variables1-rs&quot;&gt;&lt;code&gt;variables1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables1.rs
&amp;#x2F;&amp;#x2F; Make me compile!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables1` or use the `hint` watch subcommand for a hint.

fn main() {
    let x = 5; &amp;#x2F;&amp;#x2F; very simple excerize that is missing the `let`
    println!(&amp;quot;x has the value {}&amp;quot;, x);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Adding the &lt;code&gt;let&lt;&#x2F;code&gt; to the statement allows &lt;code&gt;x&lt;&#x2F;code&gt; to bind to &lt;code&gt;5&lt;&#x2F;code&gt;, very straight forward solution&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables2-rs&quot;&gt;&lt;code&gt;variables2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables2` or use the `hint` watch subcommand for a hint.

fn main() {
    let x: u8 = 5; &amp;#x2F;&amp;#x2F; you could also just write `let x = 5`
    if x == 10 {
        println!(&amp;quot;x is ten!&amp;quot;);
    } else {
        println!(&amp;quot;x is not ten!&amp;quot;);
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is basically the opposite of what we saw before with the variable binding in the &lt;code&gt;variables1.rs&lt;&#x2F;code&gt; example, except in this case we&#x27;re missing the number that &lt;code&gt;x&lt;&#x2F;code&gt; should be bound to.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables3-rs&quot;&gt;&lt;code&gt;variables3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables3.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.

fn main() {
    let x: i32 = -123; &amp;#x2F;&amp;#x2F; adding `= -123` for the code to compile.
    println!(&amp;quot;Number {}&amp;quot;, x);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since we have &lt;code&gt;x&lt;&#x2F;code&gt; as an &lt;code&gt;i32&lt;&#x2F;code&gt; let&#x27;s have some fun and add a negative number. Again this was missing the second half of the statement.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables4-rs&quot;&gt;&lt;code&gt;variables4.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables4.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables4` or use the `hint` watch subcommand for a hint.

fn main() {
    let mut x = 3; &amp;#x2F;&amp;#x2F; mut is the key here
    println!(&amp;quot;Number {}&amp;quot;, x);
    x = 5; &amp;#x2F;&amp;#x2F; don&amp;#x27;t change this line
    println!(&amp;quot;Number {}&amp;quot;, x);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As the opening text declares variables are immutable by default so this code doesn&#x27;t compile because &lt;code&gt;x&lt;&#x2F;code&gt; is being  bound twice to different numbers without declaring it &lt;code&gt;mut&lt;&#x2F;code&gt;, this code will not compile.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables5-rs&quot;&gt;&lt;code&gt;variables5.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables5.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables5` or use the `hint` watch subcommand for a hint.

fn main() {
    let number = &amp;quot;T-H-R-E-E&amp;quot;; &amp;#x2F;&amp;#x2F; don&amp;#x27;t change this line
    println!(&amp;quot;Spell a Number : {}&amp;quot;, number);
    let number = 3; &amp;#x2F;&amp;#x2F; don&amp;#x27;t rename this variable
    println!(&amp;quot;Number plus two is : {}&amp;quot;, number + 2);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this exercise we don&#x27;t rename the variable &lt;code&gt;number&lt;&#x2F;code&gt; but we shadow it by declaring it again with &lt;code&gt;let&lt;&#x2F;code&gt; this allows us to change the type from a &lt;code&gt;&amp;amp;Str&lt;&#x2F;code&gt; to a integer.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables6-rs&quot;&gt;&lt;code&gt;variables6.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables6.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables6` or use the `hint` watch subcommand for a hint.


const NUMBER: i32 = 3; &amp;#x2F;&amp;#x2F; added `:i32`
fn main() {
    println!(&amp;quot;Number {}&amp;quot;, NUMBER);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Constants are another type of variable that is available, but these are &lt;em&gt;always&lt;&#x2F;em&gt; immutable they&#x27;re declared with &lt;code&gt;const&lt;&#x2F;code&gt; instead of let and types must always be annotated. So we have to add &lt;code&gt;: i32&lt;&#x2F;code&gt; to make the code compile.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Understanding variables and their mutability is an essential aspect of learning Rust. This blog post covered the Rustlings exercises that demonstrated the usage of variables in different scenarios, including how to declare and shadow variables, work with constants, and use the &lt;code&gt;mut&lt;&#x2F;code&gt; keyword to make variables mutable. These fundamental concepts lay the groundwork for grasping more advanced topics in Rust programming.&lt;&#x2F;p&gt;
&lt;p&gt;As you continue your Rust journey, always remember that variables in Rust are immutable by default, providing safety and predictability in your code. When needed, you can use the &lt;code&gt;mut&lt;&#x2F;code&gt; keyword to allow a variable to be mutable. Constants are also available, providing values that cannot be changed and must have their types annotated.&lt;&#x2F;p&gt;
&lt;p&gt;We encourage you to explore the Rust documentation and practice further exercises to strengthen your understanding of these concepts. Happy coding!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Hello (again) Rustlings: Index</title>
          <pubDate>Tue, 11 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/hello-rustlings/</link>
          <guid>https://desmodrone.github.io/posts/hello-rustlings/</guid>
          <description>&lt;h2 id=&quot;rustling-s-index&quot;&gt;Rustling&#x27;s Index&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;01-rustlings-variables&#x2F;&quot;&gt;01_rustlings_variables&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;02-rustlings-functions&#x2F;&quot;&gt;02_rustlings_functions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;03-rustlings-if&#x2F;&quot;&gt;03_rustlings_functions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;04-rustlings-quiz1&#x2F;&quot;&gt;04_rustlings_quiz1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;05-rustlings-primitive-types&#x2F;&quot;&gt;05_rustlings_primitive_types&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;06-rustlings-vecs&#x2F;&quot;&gt;06_rustlings_vecs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;07-rustlings-move-semantics1&#x2F;&quot;&gt;07_rustlings_move_semantics_part_1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;07-rustlings-move-semantics2&#x2F;&quot;&gt;07_rustlings_move_semantics_part_2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;08-rustlings-structs&#x2F;&quot;&gt;08_rustlings_structs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;09-rustlings-enums&#x2F;&quot;&gt;09_rustlings_enums&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;10-rustlings-strings&quot;&gt;10_rustlings_strings&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;11-rustlings-modules&quot;&gt;11_rustlings_modules&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;12-rustlings-hashmaps&quot;&gt;12_rustlings_hashmaps&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Inspired by Tris Oaten&#x27;s recent video &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;2hXNd6x9sZs&quot;&gt;How to Learn Rust&lt;&#x2F;a&gt; on his excellent YouTube channel &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;@NoBoilerplate&quot;&gt;No Boilerplate&lt;&#x2F;a&gt;, I&#x27;ve decided to refocusa my journey with the Rust programming language. In hopes of effectively learning Rust, I&#x27;ll be following the holy trinity of Rust learning resources as recommended by Tris:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;&quot;&gt;The Rust Programming Language&lt;&#x2F;a&gt; aka &amp;quot;The Book&amp;quot; (read it twice, first quickly)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rustlings&quot;&gt;Rustlings&lt;&#x2F;a&gt; (do it and then continue to practice your favorites)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;&quot;&gt;Rust by Example&lt;&#x2F;a&gt; (supplement where needed)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;While I&#x27;ve been studying Rust for a few months now, I&#x27;ve been mostly focused on &amp;quot;The Book&amp;quot; and doing random tutorials on YouTube, and small personal projects, etc.&lt;&#x2F;p&gt;
&lt;p&gt;Tris&#x27;s video was a timely reminder that Rustlings is a fantastic resource. Although it starts off easy, it gradually becomes more challenging. For some reason, I stopped doing these exercises in the past, but now that I started a blog, I thought it would be a good idea to share my learnings and document my progress as I go.&lt;&#x2F;p&gt;
&lt;p&gt;As I embark on this journey, I&#x27;ll start with the basics, following the structure of The Rust Book and practicing Rustlings exercises as Tris suggests.&lt;&#x2F;p&gt;
&lt;p&gt;By sharing my experiences, I hope to inspire others to explore Rust and motivate myself to stay committed to mastering this powerful language. Stay tuned for updates on my progress and insights into the world of Rust!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Notes on Traits and You: A Deep Dive Part 3</title>
          <pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/traits-301/</link>
          <guid>https://desmodrone.github.io/posts/traits-301/</guid>
          <description>&lt;h4 id=&quot;original-content-by-nell-shamrell-harrington&quot;&gt;Original content by Nell Shamrell-Harrington&lt;&#x2F;h4&gt;
&lt;p&gt;When looking for resources to help me better understand Rust Traits, I found &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;grU-4u0Okto&quot;&gt;this video&lt;&#x2F;a&gt;from &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;nellshamrell?s=21&amp;amp;t=EhxGdIZ2VJ9HIqIS1LXcpw&quot;&gt;Nell Shamrell-Harrington&lt;&#x2F;a&gt;. It&#x27;s a great intro and overview into using Traits, which can be a little confusing when you first start learning Rust.&lt;&#x2F;p&gt;
&lt;p&gt;So these are my notes on this talk, if you haven&#x27;t watched it and are struggling with learning Traits, I strongly suggest that you watch the video above before you do anything else. But if you&#x27;re short on time and just want to reference my notes -- here they are. Disclaimer: these notes are my own interpretation of the talk and may not necessarily reflect the views of the original speaker. These note are primarily for me to learn these concepts, and I publish them for others to see and maybe benefit from. Feel free to let me know if I have errors or have misrepresentations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;The talk covers 3 different ways that we can use Traits, I have already published the first two parts of these notes, you can see those linked below. So today we&#x27;ll cover the final note with Trait Objects.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-101&#x2F;&quot;&gt;Traits 101 Introduction&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-201&#x2F;&quot;&gt;Traits 201 Trait Bounds&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Traits 301 Trait Objects&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Nell brilliantly uses D&amp;amp;D as a metaphor to help explain Traits. It should be clear that the use of D&amp;amp;D is just to help grasp some concepts, and the D&amp;amp;D rules do not strictly apply in these concepts, so now that we have that out of the way let&#x27;s begin.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits-301-trait-objects&quot;&gt;Traits 301: Trait Objects&lt;&#x2F;h2&gt;
&lt;p&gt;This is where the magic really starts to happen and it might take a little to wrap your head around this concept but let&#x27;s take a look at how traditional object oriented programming languages hand this.&lt;&#x2F;p&gt;
&lt;p&gt;In traditional Object Oriented Programming we have Data &amp;amp; Behavior in one &amp;quot;place&amp;quot;. With Rust we can say that we use &lt;code&gt;enums&lt;&#x2F;code&gt; and &lt;code&gt;structs&lt;&#x2F;code&gt; for data, and &lt;code&gt;traits&lt;&#x2F;code&gt; for behavior, this actually gives us more flexibility and control&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Object Oriented Programming = (data and behaviour together)&lt;&#x2F;li&gt;
&lt;li&gt;Rust = enums&#x2F;structs (data), traits (behavior)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This is actually one of the powers that Rust has as we can mix and match behaviours as we need it in our code.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note:
Trait Objects allow us to work with types that implement a specific trait without knowing their exact type. They enable a more dynamic approach similar to traditional object-oriented programming languages but maintain Rust&#x27;s separation of data and behavior.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;So how does a Trait Object store it&#x27;s data? Well, a Trait Object contains the data in a trait pointer to a value on the heap.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Trait Object: Pointer(Data) -&amp;gt; Value(Heap)&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;
The advantage of doing this is that even if the size of the value on the heap varies, the size of the pointer will always be the same and it&#x27;s more predictable as well.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Trait Object: Trait(Behavior)&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;
Although the Data is located on the heap, one thing to note is you cannot add data to a trait object, this is key to understanding trait objects and how to use them. We point to the data at one specific point in time.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;back-to-d-d&quot;&gt;Back to D&amp;amp;D&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s go back our D&amp;amp;D analogy and this time we&#x27;ll look at different spells that can be cast in the game. Let&#x27;s say we have a wizard that needs to cast a bunch of different spells.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Cantrip&lt;&#x2F;li&gt;
&lt;li&gt;Transmutation&lt;&#x2F;li&gt;
&lt;li&gt;Enchantment&lt;&#x2F;li&gt;
&lt;li&gt;Necromancy&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Let&#x27;s start by creating these spells as structs&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; let&amp;#x27;s create these structs
struct Cantrip {

}

struct Enchantment {

}

struct Transmutation {

}

struct Necromancy {

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Although these are 4 different kinds of spells, the thing that they all have in common is that they all need to be cast, even if they specific way that they are cast is different from spell to spell.&lt;&#x2F;p&gt;
&lt;p&gt;So with this information let&#x27;s make a &lt;code&gt;Cast&lt;&#x2F;code&gt; trait&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; let&amp;#x27;s make a trait, for now we won&amp;#x27;t define a default behaviour
pub trait Cast {
	fn cast(&amp;amp;self);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now let&#x27;s implement the &lt;code&gt;Cast&lt;&#x2F;code&gt; trait on one our spells, let&#x27;s use &lt;code&gt;Cantrip&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; now we implement this trait for the Cantrip struct
impl Cast for Cantrip{
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Cantrip spell here
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s do the same for the &lt;code&gt;Transmutation&lt;&#x2F;code&gt; spell&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; we do the same for the transmutation struct
impl Cast for Transmutation
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Transmutation spell here
	}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can do the same for our &lt;code&gt;Enchament&lt;&#x2F;code&gt; and &lt;code&gt;Necromancy&lt;&#x2F;code&gt; spells, so each of the spells can now be cast, although each spell is defined differently, below is the full list of spells with &lt;code&gt;Cast&lt;&#x2F;code&gt; implemented on them.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; now we implement this trait for the Cantrip struct
impl Cast for Cantrip{
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Cantrip spell here
	}
}

&amp;#x2F;&amp;#x2F; we do the same for the transmutation struct
impl Cast for Transmutation
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Transmutation spell here
	}


&amp;#x2F;&amp;#x2F; we do the same for the Enchantment struct
impl Cast for Enchantment
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Enchantment spell here
	}

&amp;#x2F;&amp;#x2F; we do the same for the Necromancy struct
impl Cast for Necromancy
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Necromancy spell here
	}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Cool, we&#x27;re building up a little library of spells, so how do we organize these spells, where do we keep them? In a spell book of course! We&#x27;ll represent our spell book as a struct&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct Spellbook {
	pub spells: Vec&amp;lt;Box&amp;gt;&amp;lt;Cast&amp;gt;&amp;gt;, &amp;#x2F;&amp;#x2F; here is where we define the spell field
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s break this line of code a little bit. As you can see we define &lt;code&gt;spells&lt;&#x2F;code&gt; as a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;, (we don&#x27;t go into generics in this blog but that&#x27;s what the T represent, a generic type), a Vector that contains an object of a type, the Type that we are grouping in our vector for spells is a &lt;code&gt;&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt;. A &lt;code&gt;Box&lt;&#x2F;code&gt; in Rust is a pointer to a value on the heap (remember we talked about that earlier?).
The reason we choose to use &lt;code&gt;Box&lt;&#x2F;code&gt; in &lt;code&gt;Vec&amp;lt;Box&amp;gt;&amp;lt;&amp;lt;Cast&amp;gt;&amp;gt;&lt;&#x2F;code&gt; is because it allows us to store the trait object in a dynamically sized container, such as a vector, since trait objects have an unknown size at compile time.&lt;&#x2F;p&gt;
&lt;p&gt;With a &lt;code&gt;Vec&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; we can only point to a value of a certain type (T) as we see here, in our case we say that we can contain any type that implements the &lt;code&gt;Cast&lt;&#x2F;code&gt; trait: &lt;code&gt;Vec&amp;lt;Box&amp;lt;Cast&amp;gt;&amp;gt;&lt;&#x2F;code&gt; so &lt;code&gt;Box&lt;&#x2F;code&gt; must point to a value that implements the &lt;code&gt;Cast&lt;&#x2F;code&gt; trait. It doesn&#x27;t matter what type as long as it implements that particular trait.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s review: The &lt;code&gt;pub spells&lt;&#x2F;code&gt; field is a vector &lt;code&gt;Vec&lt;&#x2F;code&gt;, that vector contains &lt;code&gt;Boxes&lt;&#x2F;code&gt; and those boxes point to values that implement the &lt;code&gt;Cast&lt;&#x2F;code&gt; trait represented as: &lt;code&gt;pub spells: Vec&amp;lt;Box&amp;gt;&amp;lt;Cast&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;What this means is that our Wizard can now cast ALL of these spells, one right after the other and we can do this in Rust by defining the behavior in our &lt;code&gt;Spellbook&lt;&#x2F;code&gt; struct.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl Spellbook {
	pub fn run(&amp;amp;self) { &amp;#x2F;&amp;#x2F; implementing a function called run
		for spell in self.spells.iter(){ &amp;#x2F;&amp;#x2F; this will iterate through the spells
			spell.cast(); &amp;#x2F;&amp;#x2F; and casting spells one after the other
		}
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a function that &amp;quot;runs&amp;quot; the spells essentially iterating through them and casting them one after the other.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s see a visual representation of our Wizard in action.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;wizard.png&quot; alt=&quot;wizard&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Now let&#x27;s look at how this code would look like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let spell_book = Spellbook {
	spells: vec![
	&amp;#x2F;&amp;#x2F; different types of spells, each implement the `cast`trait
		Box::new(Cantrip{}),
		Box::new(Transmutation{}),
		Box::new(Enchantment{}),
		Box::new(Necromancy{}),
	],
};
spell_book.run(); &amp;#x2F;&amp;#x2F; this casts each spell, in which ever way they need to be cast
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What this highlights is that Trait Object are great for heterogeneous collections or diverse and mixed collections. Where we can have objects of different types stored in the same place &lt;em&gt;It doesn&#x27;t matter what type something is&lt;&#x2F;em&gt; as long as it &lt;em&gt;implements a certain trait&lt;&#x2F;em&gt;, this gives us a ton of flexibility when using Rust.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;recap&quot;&gt;Recap&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we explored Rust Traits, focusing on Trait Objects. By diving into a D&amp;amp;D-themed example, we demonstrated the power and flexibility of Traits in Rust. Here are the key takeaways:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Rust separates data (enums&#x2F;structs) and behavior (traits), which allows for greater flexibility and control compared to traditional object-oriented programming languages.&lt;&#x2F;li&gt;
&lt;li&gt;Trait Objects enable us to work with types that implement a specific trait without knowing their exact type. This approach is similar to traditional object-oriented programming languages but maintains Rust&#x27;s separation of data and behavior.&lt;&#x2F;li&gt;
&lt;li&gt;Trait Objects are particularly useful for heterogeneous collections or diverse and mixed collections. They allow us to store objects of different types in the same place as long as they implement a certain trait.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;Box&lt;&#x2F;code&gt; pointer is utilized for storing trait objects in dynamically sized containers, such as vectors, since trait objects have an unknown size at compile time.&lt;&#x2F;li&gt;
&lt;li&gt;The D&amp;amp;D example illustrated how to create structs, implement traits, and use Trait Objects to organize and execute a collection of diverse spells.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;By understanding and leveraging Rust Traits and Trait Objects, you can harness the flexibility and power of the Rust programming language to build efficient and maintainable code. With practice and review of &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;grU-4u0Okto&quot;&gt;Nell&#x27;s excellent video&lt;&#x2F;a&gt;, you&#x27;ll be mastering Traits in no time.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Notes on Traits and You: A Deep Dive Part 2</title>
          <pubDate>Thu, 23 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/traits-201/</link>
          <guid>https://desmodrone.github.io/posts/traits-201/</guid>
          <description>&lt;h4 id=&quot;original-content-by-nell-shamrell-harrington&quot;&gt;Original content by Nell Shamrell-Harrington&lt;&#x2F;h4&gt;
&lt;p&gt;When looking for resources to help me better understand Rust Traits, I found &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;grU-4u0Okto&quot;&gt;this video&lt;&#x2F;a&gt;from &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;nellshamrell?s=21&amp;amp;t=EhxGdIZ2VJ9HIqIS1LXcpw&quot;&gt;Nell Shamrell-Harrington&lt;&#x2F;a&gt;. It&#x27;s a great intro and overview into using Traits, which can be a little confusing when you first start learning Rust.&lt;&#x2F;p&gt;
&lt;p&gt;So these are my notes on this talk, if you haven&#x27;t watched it and are struggling with learning Traits, I strongly suggest that you watch the video above before you do anything else. But if you&#x27;re short on time and just want to reference my notes -- here they are. Disclaimer: these notes are my own interpretation of the talk and may not necessarily reflect the views of the original speaker. These note are primarily for me to learn these concepts, and I publish them for others to see and maybe benefit from. Feel free to let me know if I have errors or have misrepresentations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;The talk covers 3 different ways that we can use Traits, I have already written my first part of these notes, you can see those linked below.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-101&#x2F;&quot;&gt;Traits 101 Introduction&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Traits 201 Trait Bounds&lt;&#x2F;li&gt;
&lt;li&gt;Traits 301 Trait Objects&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Nell brilliantly uses D&amp;amp;D as a metaphor to help explain Traits. It should be clear that the use of D&amp;amp;D is just to help grasp some concepts, and the D&amp;amp;D rules do not strictly apply in these concepts, so now that we have that out of the way let&#x27;s begin.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits-201-trait-bounds&quot;&gt;Traits 201: Trait Bounds&lt;&#x2F;h2&gt;
&lt;p&gt;Today we cover Traits Bounds. In my previous notes we used 4 different races to explain how traits can be used with those races.
Now, we&#x27;re going to add a 5th race: the &lt;em&gt;Half-Elf&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s our full list:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Dwarves&lt;&#x2F;li&gt;
&lt;li&gt;Elf&lt;&#x2F;li&gt;
&lt;li&gt;HalfOrc&lt;&#x2F;li&gt;
&lt;li&gt;Human&lt;&#x2F;li&gt;
&lt;li&gt;Half-Elf&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;traits-101&quot;&gt;Traits 101&lt;&#x2F;h2&gt;
&lt;p&gt;In our &lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-101&#x2F;&quot;&gt;previous note&lt;&#x2F;a&gt; we went through the process of how to define a Trait, we used &lt;code&gt;Constitution&lt;&#x2F;code&gt; as the trait we wanted to apply to the 4 different races in a couple of different ways. If you haven&#x27;t read that note, it might help to do so first to help better understand the basics of creating our characters, creating a Trait, defining race specific values as well as default values.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;trait-bounds&quot;&gt;Trait Bounds&lt;&#x2F;h2&gt;
&lt;p&gt;To help us understand Trait bounds, let&#x27;s look at how these races communicate. Each race has core languages that they speak, for example.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Dwarves: Common, Dwarvish&lt;&#x2F;li&gt;
&lt;li&gt;Elf: Common, Elvish&lt;&#x2F;li&gt;
&lt;li&gt;Half-Elf: Common, Elvish&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;defining-the-elvish-language-trait&quot;&gt;Defining the  &lt;code&gt;Elvish&lt;&#x2F;code&gt; language Trait&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s focus on the Elvish language first and define a trait for the language and define a &lt;code&gt;impl&lt;&#x2F;code&gt; for the &lt;code&gt;Elf&lt;&#x2F;code&gt; and &lt;code&gt;HalfElf&lt;&#x2F;code&gt; races.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Define the Elvish trait
pub trait Elvish {

}

&amp;#x2F;&amp;#x2F; Implement the Elvish trait for the Elf struct
impl Elvish for Elf {

}

&amp;#x2F;&amp;#x2F; Implement the Elvish trait for the HalfElf struct
impl Elvish for HalfElf {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This should be pretty straight-forward so far as it&#x27;s just like we started Traits 101.&lt;&#x2F;p&gt;
&lt;p&gt;Now let&#x27;s make a function to allow our characters to actually speak &lt;code&gt;Elvish&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn speak_elvish(character: T) -&amp;gt; String{
	String::from(&amp;quot;yes&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Right now this function can be called on anything with no arguments, so we add an argument called character, but this character doesn&#x27;t need to be a specific type it can be any of the structs we&#x27;ve already created.&lt;&#x2F;p&gt;
&lt;p&gt;But if we add the &lt;code&gt;&amp;lt;T: Elvish&amp;gt;&lt;&#x2F;code&gt; this means we will only accept the &lt;code&gt;Elvish&lt;&#x2F;code&gt; trait.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn speak_elvish&amp;lt;T: Elvish&amp;gt;(character: T) -&amp;gt; String {
	String::from(&amp;quot;yes&amp;quot;)
}

let my_elf = Elf { name: String::from(&amp;quot;ElleElf&amp;quot;)};

&amp;#x2F;&amp;#x2F; we use our previously defined variable with the `speak_elvish` function
speak_elvish(my_elf)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So now if we call our &lt;code&gt;Elf&lt;&#x2F;code&gt; (&lt;code&gt;my_elf&lt;&#x2F;code&gt;) with &lt;code&gt;speak_elvish(my_elf)&lt;&#x2F;code&gt; it would return a &lt;code&gt;yes&lt;&#x2F;code&gt; because we have implemented &lt;code&gt;Elvish&lt;&#x2F;code&gt; for &lt;code&gt;Elf&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look at our &lt;code&gt;HalfElf&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; This is the same function that we defined before
pub fn speak_elvish&amp;lt;T: Elvish&amp;gt;(character: T) -&amp;gt; String {
	String::from(&amp;quot;yes&amp;quot;)
}
&amp;#x2F;&amp;#x2F; here we bind our HalfElf to `my_half_elf`
let my_half_elf = HalfElf { name: String::from(&amp;quot;HarryHalfElf&amp;quot;)};

speak_elvish(my_half_elf) &amp;#x2F;&amp;#x2F; again this returns &amp;#x27;yes&amp;#x27; since we&amp;#x27;ve implemented `Elvish` for `HalfElf`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So far so good right, I hope it&#x27;s pretty easy to see why both the &lt;code&gt;my_elf&lt;&#x2F;code&gt; and &lt;code&gt;my_half_elf&lt;&#x2F;code&gt; both return &lt;code&gt;yes&lt;&#x2F;code&gt; when we call them using the &lt;code&gt;speak_elvish&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;halforcs-incoming&quot;&gt;HalfOrcs Incoming&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;ve successfully implemented our &lt;code&gt;speak_elvish&lt;&#x2F;code&gt; trait on both our &lt;code&gt;Elf&lt;&#x2F;code&gt; type races, but let&#x27;s see what happens when we try to call our HalfOrc.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn speak_elvish&amp;lt;T: Elvish&amp;gt;(character: T) -&amp;gt; String {
	String::from(&amp;quot;yes&amp;quot;)
}

let my_half_orc = HalfOrc { name: String::from(&amp;quot;OscarOrc&amp;quot;)};

speak_elvish(my_half_orc)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So what happens if wet try to call &lt;code&gt;my_half_orc&lt;&#x2F;code&gt; with &lt;code&gt;speaks_elvish&lt;&#x2F;code&gt;? Well in this case our code would not compile because we have not implemented &lt;code&gt;Evlish&lt;&#x2F;code&gt; for &lt;code&gt;HalfOrc&lt;&#x2F;code&gt;. Of course, Orcs tend to break everything 😉.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;recap&quot;&gt;Recap&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Trait bounds&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt; allow a function to &lt;em&gt;&lt;strong&gt;only&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt; accept types that implement a certain trait or combination of traits. This provides a powerful way to enforce specific behaviors and characteristics for the types used in your functions. Furthermore, you can combine multiple traits as criteria for a function, allowing for even greater flexibility and control.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s walk through each step like we did in Traits 101 on how we define Trait bounds:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Define our Trait in our case it was the language trait &lt;code&gt;Elvish&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Implement &lt;code&gt;Elvish&lt;&#x2F;code&gt; for the races that speak it, in our case &lt;code&gt;Elf&lt;&#x2F;code&gt; and &lt;code&gt;HelfElf&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Define a function &lt;code&gt;speak_elvish&lt;&#x2F;code&gt; that only accepts the race we define within  the function. In our case we did it for both &lt;code&gt;Elf&lt;&#x2F;code&gt; and &lt;code&gt;HalfElf&lt;&#x2F;code&gt;. This function returns a &lt;code&gt;yes&lt;&#x2F;code&gt; if we call a race that has &lt;code&gt;Elvish&lt;&#x2F;code&gt; implemented, for example: &lt;code&gt;speak_elvish(my_half_elf) &lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;If we try to do the same with our &lt;code&gt;HalfOrc&lt;&#x2F;code&gt;: &lt;code&gt;speak_elvish(my_half_orc)&lt;&#x2F;code&gt;, our code won&#x27;t compile.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This was a short and straightforward introduction to Trait Bounds, and we&#x27;ll dive deeper into Rust Traits in the upcoming post on Traits 301: Trait Objects, where the real magic happens&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Notes on Traits and You: A Deep Dive Part 1</title>
          <pubDate>Tue, 14 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/traits-101/</link>
          <guid>https://desmodrone.github.io/posts/traits-101/</guid>
          <description>&lt;h4 id=&quot;original-content-by-nell-shamrell-harrington&quot;&gt;Original content by Nell Shamrell-Harrington&lt;&#x2F;h4&gt;
&lt;p&gt;When looking for resources to help me better understand Rust Traits, I found &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;grU-4u0Okto&quot;&gt;this video&lt;&#x2F;a&gt;from &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;nellshamrell?s=21&amp;amp;t=EhxGdIZ2VJ9HIqIS1LXcpw&quot;&gt;Nell Shamrell-Harrington&lt;&#x2F;a&gt;. It&#x27;s a great intro and overview into using Traits, which can be a little confusing when you first start learning Rust.&lt;&#x2F;p&gt;
&lt;p&gt;So these are my notes on this talk, if you haven&#x27;t watched it and are struggling with learning Traits, I strongly suggest that you watch the video above before you do anything else. But if you&#x27;re short on time and just want to reference my notes -- here they are. Disclaimer: these notes are my own interpretation of the talk and may not necessarily reflect the views of the original speaker. These note are primarily for me to learn these concepts, and I publish them for others to see and maybe benefit from. Feel free to let me know if I have errors or have misrepresentations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;The talk covers 3 different ways that we can use Traits&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Traits 101 Introduction&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-201&#x2F;&quot;&gt;Traits 201 Trait Bounds&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Traits 301 Trait Objects&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Nell brilliantly uses D&amp;amp;D as a metaphor to help explain Traits. It should be clear that the use of D&amp;amp;D is just to help grasp some concepts, and the D&amp;amp;D rules do not strictly apply in these concepts, so now that we have that out of the way let&#x27;s begin.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits-101&quot;&gt;Traits: 101&lt;&#x2F;h2&gt;
&lt;p&gt;On this post we will cover Traits 101, this will keep each post shorter and easier to digest.&lt;&#x2F;p&gt;
&lt;p&gt;In D&amp;amp;D there are many different races, but we&#x27;ll start by using these 4 different races:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Dwarves&lt;&#x2F;li&gt;
&lt;li&gt;Elf&lt;&#x2F;li&gt;
&lt;li&gt;HalfOrc&lt;&#x2F;li&gt;
&lt;li&gt;Human&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;creating-our-structs&quot;&gt;Creating our Structs&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s create these races as structs in Rust&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct Dwarf {
	name:String
}

struct Elf {
	name:String
}

struct HalfOrc {
	name:String
}

struct Human {
	name:String
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see this is pretty straight forward code where we define the struct name (&lt;code&gt;Dwarf&lt;&#x2F;code&gt;, &lt;code&gt;Elf&lt;&#x2F;code&gt; etc.) and then add the &lt;code&gt;name:String&lt;&#x2F;code&gt; to allow our characters to be named.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-our-dwarf&quot;&gt;Creating our Dwarf&lt;&#x2F;h2&gt;
&lt;p&gt;First, let&#x27;s create a Dwarf character.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_dwarf = Dwarf {
	name: String::from(&amp;quot;DanDwarf&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A variable &lt;code&gt;my_dwarf&lt;&#x2F;code&gt; that stores our &lt;code&gt;Dwarf&lt;&#x2F;code&gt; type and we name him &lt;code&gt;DanDwarf&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;d-d-core-traits&quot;&gt;D&amp;amp;D Core Traits&lt;&#x2F;h2&gt;
&lt;p&gt;In D&amp;amp;D each character has core traits:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Strength&lt;&#x2F;li&gt;
&lt;li&gt;Dexterity&lt;&#x2F;li&gt;
&lt;li&gt;Constitution&lt;&#x2F;li&gt;
&lt;li&gt;Intelligence&lt;&#x2F;li&gt;
&lt;li&gt;Wisdom&lt;&#x2F;li&gt;
&lt;li&gt;Charisma&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;If you are not familiar in D&amp;amp;D, character&#x27;s core traits are defined in numbers, so an example would be that a character could have a Strength of: 8, a Dexterity of: 4, and a Constitution of 2, etc. as a base and depending on equipment or spells cast these traits could be boosted (or lowered).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;defining-a-trait&quot;&gt;Defining a Trait&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s first define a &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait that we can use on our soon to be defined Characters&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Let&amp;#x27;s make a constitution trait
&amp;#x2F;&amp;#x2F; where we define one function `constitution_bonus`
pub triat Constitution {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;implementing-constitution-for-dwarf&quot;&gt;Implementing &lt;code&gt;Constitution&lt;&#x2F;code&gt; for &lt;code&gt;Dwarf&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;So let&#x27;s take one of these traits, in our case Constitution and define it in Rust for our Dwarf.  We&#x27;ll say that Dwarves have a Constitution bonus of 2.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F;implemeting the trait
impl Constitution for Dwarf {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	2 &amp;#x2F;&amp;#x2F; this returns 2, anytime the instance of a dwarf is called.
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now that we&#x27;ve defined our trait we go back to our Dwarf, using our just defined  &lt;code&gt;constitution_bounus&lt;&#x2F;code&gt; that we can call on &lt;code&gt;my_dwarf&lt;&#x2F;code&gt; as shown below.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; back to making the character
let my_dwarf = Dwarf {
	name: String::from(&amp;quot;DanDwarf&amp;quot;)
};

my_dwarf.constitution_bonus(); &amp;#x2F;&amp;#x2F; Returns 2
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this way no matter how many Dwarves we create, every single one of them will have the &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; of &lt;code&gt;2&lt;&#x2F;code&gt; attached.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-a-halforc&quot;&gt;Creating a HalfOrc&lt;&#x2F;h2&gt;
&lt;p&gt;Now, let&#x27;s create a &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; and we&#x27;ll start by implementing the &lt;code&gt;constituion_bonus&lt;&#x2F;code&gt;, the Constitution bonus for a HalfOrc is &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl Constitution for HalfOrc {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	1
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the same as our Dwarf &lt;code&gt;impl&lt;&#x2F;code&gt; but instead returning a 2, it returns 1&lt;&#x2F;p&gt;
&lt;p&gt;Now we create the HalfOrc with:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_half_orc = HalfOrc {
	name: String::from(&amp;quot;OscarOrc&amp;quot;)
}

my_half_orc.constitution_bonus();&amp;#x2F;&amp;#x2F; Returns 1
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Pretty straightforward right? We bind &lt;code&gt;my_half_orc&lt;&#x2F;code&gt; to our &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; and name him &lt;code&gt;OscarOrc&lt;&#x2F;code&gt; and when we call the &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; and we know that it will return &lt;code&gt;1&lt;&#x2F;code&gt;, as we have defined in the &lt;code&gt;impl&lt;&#x2F;code&gt; block above.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;humans-and-elves&quot;&gt;Humans and Elves&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s define our last 2 races of Humans and Elves, but let&#x27;s say that both of these races have a constitution bonus of &lt;code&gt;0&lt;&#x2F;code&gt;.
Our first instinct might be to do the same as we did above and do this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; we can implement like this but this is repetitive
impl Constitution for Elf {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	0
	}
}

impl Constitution for Human {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	0
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is clearly repetitive and not ideal. Another thing to note is that most races actually have a constitution bonus of &lt;code&gt;0&lt;&#x2F;code&gt;
So how do we deal with this?&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s add a default value the &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait we first created.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; making `0` the default
pub triat Constitution {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	0
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this way unless we have a struct that implements this trait and overrides this default value it will always return &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We still have to implement the traits on the struct, but we don&#x27;t have to define how the constitution bonus works since it&#x27;s default value is &lt;code&gt;0&lt;&#x2F;code&gt; and Humans and Elves&#x27; &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; matches the default value.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
impl Constitution for Elf{
}

impl Constitution for Human{
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;creating-our-elf-and-human&quot;&gt;Creating our Elf and Human&lt;&#x2F;h2&gt;
&lt;p&gt;We know the drill here, we define both of these in the same way that we did for our &lt;code&gt;my_dwarf&lt;&#x2F;code&gt; and &lt;code&gt;my_half_orc&lt;&#x2F;code&gt;, the only difference is that since we have defined a default value on the &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait we have access to it automatically unless we further define the &lt;code&gt;consitution_bonus&lt;&#x2F;code&gt; like we did previously.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_elf = Elf{
	name:String::from(&amp;quot;ElleElf&amp;quot;)
};

my_elf.constituion_bonus(); &amp;#x2F;&amp;#x2F; Retuns 0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_human = Human {
	name:String::from(&amp;quot;HarryHuman&amp;quot;)
};

my_human.constitution_bonus(); &amp;#x2F;&amp;#x2F; Returns 0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There it is, we have created 4 D&amp;amp;D characters and defined their &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; in a couple of different ways using Triats.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s summarize what we did here, in a quick step-by-step so we can see how easy it actually is to use traits in this way.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Create a &lt;code&gt;struct&lt;&#x2F;code&gt; for each of the races.&lt;&#x2F;li&gt;
&lt;li&gt;Create a character with a variable &lt;code&gt;my_&amp;lt;race&amp;gt;&lt;&#x2F;code&gt;  and defined it&#x27;s type and name.&lt;&#x2F;li&gt;
&lt;li&gt;Create a &lt;code&gt;trait&lt;&#x2F;code&gt;, in our case &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Implement the &lt;code&gt;triat&lt;&#x2F;code&gt; on the &lt;code&gt;Dwarf&lt;&#x2F;code&gt; struct
&lt;ul&gt;
&lt;li&gt;define constitution bonus as &lt;code&gt;2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;calling &lt;code&gt;constitution_bonus()&lt;&#x2F;code&gt; on our character it returns &lt;code&gt;2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;if we create more &lt;code&gt;Dwarf&lt;&#x2F;code&gt; characters they&#x27;d all have a constitution bonus of &lt;code&gt;2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Implement the &lt;code&gt;trait&lt;&#x2F;code&gt; on the &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; struct
&lt;ul&gt;
&lt;li&gt;define constitution bonus as &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;calling &lt;code&gt;constitution_bonus()&lt;&#x2F;code&gt; on our character returns &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;if we create more &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; characters they&#x27;d all have a constitution bonus of &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Add a default value to our &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait&lt;&#x2F;li&gt;
&lt;li&gt;Implement the &lt;code&gt;trait&lt;&#x2F;code&gt; on &lt;code&gt;Elves&lt;&#x2F;code&gt; and &lt;code&gt;Humans&lt;&#x2F;code&gt;(with no additional definition)&lt;&#x2F;li&gt;
&lt;li&gt;Created our &lt;code&gt;Elves&lt;&#x2F;code&gt; and &lt;code&gt;Humans&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;calling &lt;code&gt;constitution_bonus()&lt;&#x2F;code&gt; on our elf and human characters returns &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;creating other races with no function definition in their implementation will always return &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Alright, as you can see there&#x27;s not a lot of tricky parts here, it&#x27;s all pretty straight forward, especially when laid out in this way where we can see how easy it is, in a few easy steps start using Traits in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Next we&#x27;ll dive into Traits 201, it will build on what we&#x27;ve learned here with Trait bounds. See you next time.&lt;&#x2F;p&gt;
&lt;p&gt;Update 2023-03-14:If you&#x27;re ready for &lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-201&#x2F;&quot;&gt;Part 2&lt;&#x2F;a&gt;, it&#x27;s ready for you.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Rust Closures</title>
          <pubDate>Wed, 08 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/rust-closures/</link>
          <guid>https://desmodrone.github.io/posts/rust-closures/</guid>
          <description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;&#x2F;h2&gt;
&lt;p&gt;I&#x27;m new to Rust and programming in general, and while I&#x27;ve dabbled in different languages and technologies, I&#x27;ve never gone headfirst into any language to become proficient. I&#x27;m trying to change that now with Rust. Please forgive my inaccuracies or lack of understanding of more complex topics, but I&#x27;ll get there eventually. For now, I thought closures were an interesting topic, so I decided to write about this this topic first.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-are-closures&quot;&gt;What are closures?&lt;&#x2F;h2&gt;
&lt;p&gt;A closure can be thought of as a quick function that doesn&#x27;t need a name, or an anonymous function that can be saved in a variable or passed into other functions as arguments. A unique thing about closures is that they can capture their environment and this makes them a versatile tool that can be fun and efficient to use.&lt;&#x2F;p&gt;
&lt;p&gt;Closures are easy to identify because they use pipes &lt;code&gt;||&lt;&#x2F;code&gt; instead of the typical parentheses &lt;code&gt;()&lt;&#x2F;code&gt; that functions use. There are a few different ways you can use closures in Rust, but first, let&#x27;s look at how a closure is created.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;how-are-closures-created-in-rust&quot;&gt;How are closures created in Rust?&lt;&#x2F;h2&gt;
&lt;p&gt;Before we look at closures let us take a quick look at the syntax of how a function is defined in Rust. Below is a simple function definition that adds 1 to its parameter.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; function definition syntax
fn plus_one_v1 (x: u32) -&amp;gt; u32 { x + 1 }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you&#x27;re familiar with Rust&#x27;s functions this should be pretty easy to understand, so we won&#x27;t go through the details, if you&#x27;re not familiar with creating a function in Rust here&#x27;s a &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;2V0JaMVjzws?t=465&quot;&gt;Let&#x27;s Get Rusty&lt;&#x2F;a&gt; tutorial on functions that will bring you up to speed.  Now let&#x27;s look at how we&#x27;d create a closure using similar syntax to a function. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F;closure definition syntax
let plus_one_v2 = | x: u32| -&amp;gt; u32 { x + 1 };
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see the syntax is very similar to a function other than we use the &lt;code&gt;let&lt;&#x2F;code&gt;  keyword to bind the closure to &lt;code&gt;plus_one_v2&lt;&#x2F;code&gt; , and use the equal sign before the pipes &lt;code&gt;||&lt;&#x2F;code&gt;.  One thing to note is that a lot of this syntax is optional for closure definitions, the Rust compiler is usually able to infer the types in closures. Keep in mind that when the Rust compiler infers the type, it will take the first type we pass through as the type it uses. So you can&#x27;t change the type later in your code and expect it to work. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;simplifying-syntax&quot;&gt;Simplifying Syntax&lt;&#x2F;h2&gt;
&lt;p&gt;Since the Rust compiler can infer the types, to declare this closure in the most succinct manner you could do so like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; closure definition stripped down
let plus_one_v2 = |x| x + 1;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s go step by step and see what we removed.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; closure syntax defined
let plus_one_v2 = | x: u32| -&amp;gt; u32 { x + 1 };

&amp;#x2F;&amp;#x2F; removing the return type and curly braces
let plus_one_v2 = | x: u32| -&amp;gt; x + 1;

&amp;#x2F;&amp;#x2F; removing the u32 type in closure
let plus_one_v2 = |x| x + 1;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again because the rust compiler can infer the type we can make this line of code much cleaner.&lt;&#x2F;p&gt;
&lt;p&gt;Just like in functions where the parentheses &lt;code&gt;()&lt;&#x2F;code&gt;  can be empty, we can leave the &lt;code&gt;||&lt;&#x2F;code&gt; empty or add variables and types.  Let&#x27;s look at another example.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; empty `||`
fn main() {
	let simple_closure = || println!(&amp;quot;A simple closure&amp;quot;);
	simple_closure();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we define a closure to the variable &lt;code&gt;simple_closure&lt;&#x2F;code&gt; and this has nothing in between &lt;code&gt;||&lt;&#x2F;code&gt;.  If we run this code it prints: &lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;A simple closure.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;passing-in-parameters&quot;&gt;Passing in Parameters&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at what happens when we add something in between the pipes &lt;code&gt;||&lt;&#x2F;code&gt; similar to how we would to the parenthesis &lt;code&gt;()&lt;&#x2F;code&gt; of a function. We define &lt;code&gt;x&lt;&#x2F;code&gt; as and &lt;code&gt;i32&lt;&#x2F;code&gt; which means that when we call &lt;code&gt;simple_closure&lt;&#x2F;code&gt; we can pass in an &lt;code&gt;i32&lt;&#x2F;code&gt; into it.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; pipes with an i32
fn main() {
	let simple_closure = |x: i32| println!(&amp;quot;{}&amp;quot;, x);

	simple_closure(3);
	simple_closure(3+16);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;3
19
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So far so good, I hope. This behavior here is just like a function, we&#x27;re not doing anything too different. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;capturing-the-environment&quot;&gt;Capturing the Environment&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at what makes closures special, &amp;quot;capture their environment&amp;quot;, meaning they can take variables that are outside of the closure.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Capturing the environment
fn main() {
	let first = 12
	let second = 3

	let capture_closure = || println!(&amp;quot;{}&amp;quot;, first + second);
	capture_closure();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;15
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So what is going on here? We didn&#x27;t put anything in between the &lt;code&gt;||&lt;&#x2F;code&gt; but closures can just &#x27;take&#x27; the variables &lt;code&gt;first&lt;&#x2F;code&gt; and &lt;code&gt;second&lt;&#x2F;code&gt; and add them because closures can capture their environment -- pretty cool huh?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-3-closure-traits-fn-fnmut-and-fnonce&quot;&gt;The 3 closure traits (Fn, FnMut,  and FnOnce)&lt;&#x2F;h2&gt;
&lt;p&gt;Now, let&#x27;s dive a little deeper and take a look at the &lt;code&gt;Fn&lt;&#x2F;code&gt;, &lt;code&gt;FnMut&lt;&#x2F;code&gt;, and &lt;code&gt;FnOnce&lt;&#x2F;code&gt; traits and how they work with closures. This happens behind the scenes when using closures with variables but in order to understand closures and be able to use them to their full potential we must understand what is happening with these 3 traits.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fn&lt;&#x2F;code&gt;: using this with an upper case &lt;code&gt;F&lt;&#x2F;code&gt; means we are not mutating the captured variables and they are read-only.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;FnMut&lt;&#x2F;code&gt;: allows us to change captured variables, creating a mutable borrow of these captured variables.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;FnOnce&lt;&#x2F;code&gt;: this lets us move ownership into the closure. In essence, consuming the variable. &lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Again, Rust infers these traits when using closures with variables, different than when they&#x27;re being used with functions where they have to be explicitly defined, but we&#x27;ll look at that later. &lt;&#x2F;p&gt;
&lt;h3 id=&quot;fn-trait&quot;&gt;&lt;code&gt;Fn&lt;&#x2F;code&gt; Trait&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s take a quick look at what each of these looks like in code.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; using `Fn` trait
fn main() {
	let str1 = &amp;quot;Hello&amp;quot;.to_string();
	let closure = |x| println!(&amp;quot;{} {}&amp;quot;, str1, x);
	closure(&amp;quot;rustaceans!&amp;quot;)

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we capturing the variable and printing it with the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait because we are immutably borrowing that variable and printing it to screen. which prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Hello rustaceans!
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can tell we didn&#x27;t actually have to define the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait it was implied by how it the code is constructed. &lt;&#x2F;p&gt;
&lt;h3 id=&quot;fnmut-trait&quot;&gt;&lt;code&gt;FnMut&lt;&#x2F;code&gt; Trait&lt;&#x2F;h3&gt;
&lt;p&gt;Here in the 2nd block of code with &lt;code&gt;clsr2&lt;&#x2F;code&gt; we are declaring a closure that actually mutates the &lt;code&gt;str1&lt;&#x2F;code&gt; variable, so here we are using the &lt;code&gt;FnMut&lt;&#x2F;code&gt; trait because we are mutating our variable. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {
	&amp;#x2F;&amp;#x2F; using Fn trait
	let mut str1 = &amp;quot;Hello&amp;quot;.to_string();
	let closure = |x| println!(&amp;quot;{} {}&amp;quot;, str1, x);
	closure(&amp;quot;rustaceans!&amp;quot;);

	&amp;#x2F;&amp;#x2F; using FnMut trait
	let mut closure2 = |x| str1.push_str(x);
	closure2(&amp;quot; welcome back, rustaceans!&amp;quot;); 
	println!(&amp;quot;{}&amp;quot;, str1);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This now prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Hello rustaceans!
Hello welcome back, rustaceans!
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;fnonce-trait&quot;&gt;&lt;code&gt;FnOnce&lt;&#x2F;code&gt; Trait&lt;&#x2F;h3&gt;
&lt;p&gt;In this last example, we take a look at the &lt;code&gt;FnOnce&lt;&#x2F;code&gt; trait&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {
	&amp;#x2F;&amp;#x2F; using Fn trait
	let mut str1 = &amp;quot;Hello&amp;quot;.to_string();
	let closure = |x| println!(&amp;quot;{} {}&amp;quot;, str1, x);
	closure(&amp;quot;rustaceans!&amp;quot;);

	&amp;#x2F;&amp;#x2F; using FnMut trait
	let mut closure2 = |x| str1.push_str(x);
	closure2(&amp;quot; welcome back, rustaceans!&amp;quot;);
	println!(&amp;quot;{}&amp;quot;, str1);

	&amp;#x2F;&amp;#x2F; using FnOnce trait
	let closure3 = || drop(str1);
    println!(&amp;quot;before dropping str1&amp;quot;);
    closure3();
    println!(&amp;quot;str1 has been dropped&amp;quot;);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see the &lt;code&gt;FnOnce&lt;&#x2F;code&gt; trait in action here when using  &lt;code&gt;drop(str1)&lt;&#x2F;code&gt;.  However, if we try to call &lt;code&gt;str1&lt;&#x2F;code&gt; again, our code would not compile and give us an error message, so we don&#x27;t call it in this instance.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-move-keyword&quot;&gt;&lt;strong&gt;The &lt;code&gt;move&lt;&#x2F;code&gt; keyword&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;move&lt;&#x2F;code&gt; keyword comes in handy when you want to force a closure to take ownership of the values it captures, even though the closure doesn&#x27;t need it. &lt;code&gt;move&lt;&#x2F;code&gt; can specifically come into action when passing a closure into a new thread and thus moving the data so it&#x27;s owned by this new thread. Threads are something we can cover at a different time, but let&#x27;s look at this example on how to use the &lt;code&gt;move&lt;&#x2F;code&gt; keyword with closures:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!(&amp;quot;Before defining closure: {:?}&amp;quot;, list);

    thread::spawn(move || println!(&amp;quot;From thread: {:?}&amp;quot;, list))
        .join()
        .unwrap();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A new thread is spawned and we force the closure to take ownership of the &lt;code&gt;list&lt;&#x2F;code&gt; by using the &lt;code&gt;move&lt;&#x2F;code&gt;  keyword.  In this way even if we implement the &lt;code&gt;Fn&lt;&#x2F;code&gt; or &lt;code&gt;FnMut&lt;&#x2F;code&gt; traits, ownership is moved to the closure allowing more flexibility in the closure. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;passing-closures-or-other-functions-as-inputs-to-functions&quot;&gt;&lt;strong&gt;Passing closures(or other functions) as inputs to functions&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at a couple of different ways we can use closures as inputs to functions, building on what we saw above with the &lt;code&gt;Fn&lt;&#x2F;code&gt;, &lt;code&gt;FnMut&lt;&#x2F;code&gt;. &lt;&#x2F;p&gt;
&lt;p&gt;As mentioned outside of a function, a closure can decide by itself which trait to use, but inside of a function, you have to be explicit and define one of these traits. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; using `Fn`
fn add_num&amp;lt;F&amp;gt;(func: F)
	where F: Fn(i32){
		func(7)
	}

fn main(){
	let num = 6;
	add_num(|x|println!(&amp;quot;{}&amp;quot;, num + x));
	
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;13
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we are defining the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait to add two numbers and since we are not changing the number in the &lt;code&gt;add_num&lt;&#x2F;code&gt;  function and simply passing it through we can define the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait without major fuss. &lt;&#x2F;p&gt;
&lt;p&gt;However, if we try to make our &lt;code&gt;num&lt;&#x2F;code&gt; mutable by incrementing it, we might run into some problems. Let&#x27;s see what happens.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn add_num&amp;lt;F&amp;gt;(func: F)
	where F: Fn(i32){
		func(7)
	}

fn main(){
	let mut num = 6; &amp;#x2F;&amp;#x2F; mutable to allow incrementation
	add_num(|x|{num +=x; println!(&amp;quot;{}&amp;quot;, num + x)}); 
	
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As expected we get an error message:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;error[E0594]: cannot assign to `num`, as it is a captured variable in a `Fn` closure
 --&amp;gt; src&amp;#x2F;main.rs:8:14
  |
1 | fn add_num&amp;lt;F&amp;gt;(func: F)
  |                     - change this to accept `FnMut` instead of `Fn`
...
8 |     add_num(|x|{num +=x; println!(&amp;quot;{}&amp;quot;, num + x)});
  |     ------- --- ^^^^^^^ cannot assign
  |     |       |
  |     |       in this closure
  |     expects `Fn` instead of `FnMut`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler actually tells us what we should be doing here (very nice), changing the &lt;code&gt;Fn&lt;&#x2F;code&gt; to &lt;code&gt;FnMut&lt;&#x2F;code&gt; .&lt;&#x2F;p&gt;
&lt;p&gt;If we update our code to in the &lt;code&gt;add_num&lt;&#x2F;code&gt; function to what is shown below, our problems will be solved:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn add_num&amp;lt;F&amp;gt;(mut func: F) &amp;#x2F;&amp;#x2F; add mut here
	where F: FnMut(i32){ &amp;#x2F;&amp;#x2F; change Fn to FnMut here
		func(7) 
	}

fn main(){
	let mut num = 6;
	add_num(|x|{num +=x; println!(&amp;quot;{}&amp;quot;, num + x)}); 	
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This now compiles and prints:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;20
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Phew, we covered a lot but there&#x27;s still more we can do with closures, like storing them in structs and using them in conjunction with iterators, but we&#x27;ll leave that for another time. For now, I hope I have been able to explain what a closure is, how to create a closure, and how to use its traits. This should help you get started with getting familiar with closures and understanding how to use them in your own code. &lt;&#x2F;p&gt;
&lt;p&gt;Please let me know if I got something wrong or was unclear on anything, I&#x27;m doing this to help me better learn these concepts, so any feedback is appreciated. &lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Hello World</title>
          <pubDate>Tue, 07 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/hello-world/</link>
          <guid>https://desmodrone.github.io/posts/hello-world/</guid>
          <description>&lt;p&gt;Yes, the obligatory Hello World post...and code.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main(){
    println!(&amp;quot;hello world!&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
      </item>
    </channel>
</rss>
