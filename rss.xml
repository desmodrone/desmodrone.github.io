<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>desmo</title>
      <link>https://desmodrone.github.io</link>
      <description>Random Ideas</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://desmodrone.github.io/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Wed, 26 Apr 2023 00:00:00 +0000</lastBuildDate>
      <item>
          <title>04 Rustlings quiz1</title>
          <pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/04-rustlings-quiz1/</link>
          <guid>https://desmodrone.github.io/posts/04-rustlings-quiz1/</guid>
          <description>&lt;p&gt;Now we have our first quiz building on what we&#x27;ve learned so far. Here is the code and instructions written in the comments.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;quiz1-rs&quot;&gt;&lt;code&gt;quiz1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; quiz1.rs
&amp;#x2F;&amp;#x2F; This is a quiz for the following sections:
&amp;#x2F;&amp;#x2F; - Variables
&amp;#x2F;&amp;#x2F; - Functions
&amp;#x2F;&amp;#x2F; - If

&amp;#x2F;&amp;#x2F; Mary is buying apples. The price of an apple is calculated as follows:
&amp;#x2F;&amp;#x2F; - An apple costs 2 rustbucks.
&amp;#x2F;&amp;#x2F; - If Mary buys more than 40 apples, each apple only costs 1 rustbuck!
&amp;#x2F;&amp;#x2F; Write a function that calculates the price of an order of apples given
&amp;#x2F;&amp;#x2F; the quantity bought. No hints this time!

&amp;#x2F;&amp;#x2F; I AM NOT DONE

&amp;#x2F;&amp;#x2F; Put your function here!
&amp;#x2F;&amp;#x2F; fn calculate_price_of_apples {

&amp;#x2F;&amp;#x2F; Don&amp;#x27;t modify this function!
#[test]
fn verify_test() {
    let price1 = calculate_price_of_apples(35);
    let price2 = calculate_price_of_apples(40);
    let price3 = calculate_price_of_apples(41);
    let price4 = calculate_price_of_apples(65);

    assert_eq!(70, price1);
    assert_eq!(80, price2);
    assert_eq!(41, price3);
    assert_eq!(65, price4);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is pretty straight forward, it&#x27;s clear we have to write a little bit of code, let&#x27;s recap what we know.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Mary is buying apples.&lt;&#x2F;li&gt;
&lt;li&gt;each apple is worth 2 rustbucks.&lt;&#x2F;li&gt;
&lt;li&gt;If Mary purchases more than 40 apples, the apple price for each goes down to 1 rust buck for each apple.&lt;&#x2F;li&gt;
&lt;li&gt;We need to create a function that calculates the correct price given the amount of apples purchased&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;quiz1-rs-errors&quot;&gt;&lt;code&gt;quiz1.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;quiz1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0425]: cannot find function `calculate_price_of_apples` in this scope
  --&amp;gt; exercises&amp;#x2F;quiz1.rs:21:18
   |
21 |     let price1 = calculate_price_of_apples(35);
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `calculate_price_of_apples` in this scope
  --&amp;gt; exercises&amp;#x2F;quiz1.rs:22:18
   |
22 |     let price2 = calculate_price_of_apples(40);
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `calculate_price_of_apples` in this scope
  --&amp;gt; exercises&amp;#x2F;quiz1.rs:23:18
   |
23 |     let price3 = calculate_price_of_apples(41);
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `calculate_price_of_apples` in this scope
  --&amp;gt; exercises&amp;#x2F;quiz1.rs:24:18
   |
24 |     let price4 = calculate_price_of_apples(65);
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope

error: aborting due to 4 previous errors
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We are getting are getting 4 errors all related to the &lt;code&gt;calculate_price_of_apples&lt;&#x2F;code&gt; function being out of scope. Well, that should be pretty obvious as to why, it&#x27;s not there...or in this case commented out.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;working-on-a-solution&quot;&gt;Working on a Solution&lt;&#x2F;h2&gt;
&lt;p&gt;As noted in the errors, we need to implement the function &lt;code&gt;fn_calculate_price_of_apples&lt;&#x2F;code&gt; so let&#x27;s start there, by removing the comment forward slashes. We&#x27;ll just add the code here without the additional comments.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Put your function here!
   fn calculate_price_of_apples {

&amp;#x2F;&amp;#x2F; Don&amp;#x27;t modify this function!
#[test]
fn verify_test() {
    let price1 = calculate_price_of_apples(35);
    let price2 = calculate_price_of_apples(40);
    let price3 = calculate_price_of_apples(41);
    let price4 = calculate_price_of_apples(65);

    assert_eq!(70, price1);
    assert_eq!(80, price2);
    assert_eq!(41, price3);
    assert_eq!(65, price4);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we think of what we&#x27;ve learned so far: &lt;code&gt;variables&lt;&#x2F;code&gt;, &lt;code&gt;if&lt;&#x2F;code&gt; statements and &lt;code&gt;functions&lt;&#x2F;code&gt; we should be able to use these and apply them to our quiz here, let&#x27;s start the function signature, we need to be explicit when defining our function signatures in Rust, so our function signature is missing a whole lot of information.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;completing-our-function-signature&quot;&gt;Completing our Function Signature&lt;&#x2F;h2&gt;
&lt;p&gt;If we need any hints we can go back to our &lt;code&gt;function&lt;&#x2F;code&gt; lesson and see how this current function looks incomplete, we should quickly notice that our current function signature looks incomplete compared to our previous exercises, so let&#x27;s fix that, by defining a variable that gets passed through the function as an &lt;code&gt;i32&lt;&#x2F;code&gt;, as well as adding a return value of &lt;code&gt;i32&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; how it&amp;#x27;s currently defined
fn calculate_price_of_apples {


&amp;#x2F;&amp;#x2F; by adding `apples:i32` we allow the function to pass through an `i32` that we define as apples
&amp;#x2F;&amp;#x2F; we also add the ` -&amp;gt; i32` to show that we&amp;#x27;ll also return an `i32` for our final price
fn calculate_price_of_apples(apples:i32) -&amp;gt; i32 {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;adding-variables&quot;&gt;Adding Variables&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at variables we have to create inside of our function to complete the calculation of our price.
I guess the most logical variables would be the price right, we have the regular price and the discount price.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn calculate_price_of_apples(apples: i32) -&amp;gt; i32 {
	let regular_price: i32 = 2; &amp;#x2F;&amp;#x2F; defining a regular price
	let discount_price: i32 = 1; &amp;#x2F;&amp;#x2F; defining a dicount price
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Easy enough right? We have defined a &lt;code&gt;regular_price&lt;&#x2F;code&gt; and a &lt;code&gt;discount_price&lt;&#x2F;code&gt; is based on the information we were given. Now let&#x27;s go to the next step in our function defining our &lt;code&gt;if&lt;&#x2F;code&gt; expression.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;controlling-our-conditions-with-if&quot;&gt;Controlling our Conditions with &lt;code&gt;if&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s quickly recap what we tools we have made so far:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We&#x27;ve defined our function signature so it takes and returns and &lt;code&gt;i32&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;We&#x27;ve created two different variables that define a &lt;code&gt;regular_price&lt;&#x2F;code&gt; or a &lt;code&gt;discounted_price&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Now we need a way to let our function choose a branch of code depending the quantity of apples. The &lt;code&gt;if&lt;&#x2F;code&gt; keyword let&#x27;s us do this as we previously learned in lesson 3 so let&#x27;s implement this within our function.&lt;&#x2F;p&gt;
&lt;p&gt;First let&#x27;s think about this in plain English, remembering that Mary get&#x27;s a price break &lt;em&gt;after&lt;&#x2F;em&gt; apple number 40, we can say that &amp;quot;if Mary buys 40 or less apples&amp;quot; it&#x27;s regular price, &amp;quot;if Mary buys 41 or more apples&amp;quot; it&#x27;s a discount price. Of course in code it&#x27;s a little different and we can always reference the &lt;code&gt;if&lt;&#x2F;code&gt; lesson for the syntax.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn calculate_price_of_apples(apples: i32) -&amp;gt; i32 {
	let regular_price: i32 = 2;
	let discount_price: i32 = 1;
		if apples &amp;lt;= 40 { &amp;#x2F;&amp;#x2F; defining if the quantity of `apples` purchased are 40 or less
			apples * regular_price &amp;#x2F;&amp;#x2F; here&amp;#x27;s the simple math to calculate the result
		} else { &amp;#x2F;&amp;#x2F; `else` let&amp;#x27;s us add the other part of the expression
			apples * discount_price &amp;#x2F;&amp;#x2F; this multiples the number of apples which are above 40 at the discount
		}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And that&#x27;s it, our code compiles and passes all tests, so we&#x27;ve finished our first quiz. This is what the final full code will look like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn calculate_price_of_apples(apples: i32) -&amp;gt; i32 {
    let regular_price: i32 = 2;
    let discount_price: i32 = 1;

    if apples &amp;lt;= 40 {
        &amp;#x2F;&amp;#x2F; less than or equal to
        apples * regular_price
    } else {
        apples * discount_price
    }
}
&amp;#x2F;&amp;#x2F; Don&amp;#x27;t modify this function!
#[test]
fn verify_test() {
    let price1 = calculate_price_of_apples(35);
    let price2 = calculate_price_of_apples(40);
    let price3 = calculate_price_of_apples(41);
    let price4 = calculate_price_of_apples(65);

    assert_eq!(70, price1);
    assert_eq!(80, price2);
    assert_eq!(41, price3);
    assert_eq!(65, price4);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we reviewed a Rust quiz about variables, functions, and if statements. We worked through the errors provided by the compiler and wrote a solution to calculate the price of apples based on the quantity bought. We first defined the function signature, which was incomplete, and added the appropriate information to pass and return an &lt;code&gt;i32&lt;&#x2F;code&gt;. We then created variables for the regular and discounted prices of the apples. Finally, we used an &lt;code&gt;if&lt;&#x2F;code&gt; expression to control the calculation of the price based on the quantity of apples bought, with a break for the discounted price starting at 40 apples.&lt;&#x2F;p&gt;
&lt;p&gt;By working through this quiz, we demonstrated how to apply the concepts of variables, functions, and if statements in Rust to solve a problem. We hope this blog post provides a clear and helpful review of these concepts and helps you better understand how to use them in your own Rust programming.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>03 Rustlings if</title>
          <pubDate>Fri, 21 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/03-rustlings-if/</link>
          <guid>https://desmodrone.github.io/posts/03-rustlings-if/</guid>
          <description>&lt;p&gt;&lt;code&gt;if&lt;&#x2F;code&gt;, is the most basic but still very versatile type of control flow, these next couple of exercises will go through this little word.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;additional-reading&quot;&gt;Additional Reading&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch03-05-control-flow.html#if-expressions&quot;&gt;Control Flow - if expressions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;if1-rs&quot;&gt;&lt;code&gt;if1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; if1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub fn bigger(a: i32, b: i32) -&amp;gt; i32 {
    &amp;#x2F;&amp;#x2F; Complete this function to return the bigger number!
    &amp;#x2F;&amp;#x2F; Do not use:
    &amp;#x2F;&amp;#x2F; - another function call
    &amp;#x2F;&amp;#x2F; - additional variables
}

&amp;#x2F;&amp;#x2F; Don&amp;#x27;t mind this for now :)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ten_is_bigger_than_eight() {
        assert_eq!(10, bigger(10, 8));
    }

    #[test]
    fn fortytwo_is_bigger_than_thirtytwo() {
        assert_eq!(42, bigger(32, 42));
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright looks like we have our first real writing of some basic code -- we need to create an &lt;code&gt;if&lt;&#x2F;code&gt; statement that will compare 2 numbers or variables &lt;code&gt;a&lt;&#x2F;code&gt; or &lt;code&gt;b&lt;&#x2F;code&gt; and return which one is bigger.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;if1-rs-errors&quot;&gt;&lt;code&gt;if1.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;if&amp;#x2F;if1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
 --&amp;gt; exercises&amp;#x2F;if&amp;#x2F;if1.rs:6:34
  |
6 | pub fn bigger(a: i32, b: i32) -&amp;gt; i32 {
  |        ------                    ^^^ expected `i32`, found `()`
  |        |
  |        implicitly returns `()` as its body has no tail or `return` expression
  |
note: consider returning one of these bindings
 --&amp;gt; exercises&amp;#x2F;if&amp;#x2F;if1.rs:6:15
  |
6 | pub fn bigger(a: i32, b: i32) -&amp;gt; i32 {
  |               ^       ^

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s look at what the &lt;code&gt;rust_errors&lt;&#x2F;code&gt; are telling us here.&lt;&#x2F;p&gt;
&lt;p&gt;The line &lt;code&gt;^^^ expected&lt;&#x2F;code&gt;i32&lt;code&gt;, found &lt;&#x2F;code&gt;()`` is essentially telling us that there is no return expression because there is nothing in the body of the function &lt;code&gt;bigger&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The solution is pretty simple, it&#x27;s  to add an &lt;code&gt;if&lt;&#x2F;code&gt; &lt;code&gt;a &amp;lt; b&lt;&#x2F;code&gt; expression.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;if1-rs-solution&quot;&gt;&lt;code&gt;if1.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn bigger(a: i32, b: i32) -&amp;gt; i32 {
    if a &amp;lt; b {
        b
    } else {
        a
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This compiles but the hint reminds me that it can also be done in one line, let&#x27;s try that, it works just fine and looks like this&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn bigger(a: i32, b:i32) -&amp;gt; i32 {
	if a &amp;lt; b { b } else { a }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I&#x27;m also reminded that :&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;in Rust the &lt;code&gt;if&lt;&#x2F;code&gt; condition doesn&#x27;t need to be surrounded by parentheses&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;if&#x2F;else&lt;&#x2F;code&gt; conditionals are expressions&lt;&#x2F;li&gt;
&lt;li&gt;Each condition is followed by a &lt;code&gt;{}&lt;&#x2F;code&gt; block&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Okay, let&#x27;s move on to the next exercise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;if2-rs&quot;&gt;&lt;code&gt;if2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; if2.rs

&amp;#x2F;&amp;#x2F; Step 1: Make me compile!
&amp;#x2F;&amp;#x2F; Step 2: Get the bar_for_fuzz and default_to_baz tests passing!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub fn foo_if_fizz(fizzish: &amp;amp;str) -&amp;gt; &amp;amp;str {
    if fizzish == &amp;quot;fizz&amp;quot; {
        &amp;quot;foo&amp;quot;
    } else {
        1
    }
}

&amp;#x2F;&amp;#x2F; No test changes needed!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn foo_for_fizz() {
        assert_eq!(foo_if_fizz(&amp;quot;fizz&amp;quot;), &amp;quot;foo&amp;quot;)
    }

    #[test]
    fn bar_for_fuzz() {
        assert_eq!(foo_if_fizz(&amp;quot;fuzz&amp;quot;), &amp;quot;bar&amp;quot;)
    }

    #[test]
    fn default_to_baz() {
        assert_eq!(foo_if_fizz(&amp;quot;literally anything&amp;quot;), &amp;quot;baz&amp;quot;)
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;if2-rs-errors&quot;&gt;&lt;code&gt;if2.rs&lt;&#x2F;code&gt; errors&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;if&amp;#x2F;if2.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;if&amp;#x2F;if2.rs:13:9
   |
9  | pub fn foo_if_fizz(fizzish: &amp;amp;str) -&amp;gt; &amp;amp;str {
   |                                      ---- expected `&amp;amp;str` because of return type
...
13 |         1
   |         ^ expected `&amp;amp;str`, found integer

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first comments state that we first have to make the code compile, so the first thing to do in this case is to add the &lt;code&gt;bar&lt;&#x2F;code&gt; by replacing the &lt;code&gt;1&lt;&#x2F;code&gt; which the Rust compile clearly states that it expected an &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; and this is an integer.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; if2.rs

&amp;#x2F;&amp;#x2F; Step 1: Make me compile!
&amp;#x2F;&amp;#x2F; Step 2: Get the bar_for_fuzz and default_to_baz tests passing!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

pub fn foo_if_fizz(fizzish: &amp;amp;str) -&amp;gt; &amp;amp;str {
    if fizzish == &amp;quot;fizz&amp;quot; {
        &amp;quot;foo&amp;quot;
    } else {
        &amp;quot;bar&amp;quot; &amp;#x2F;&amp;#x2F; add bar to get it to compile
    }
}

&amp;#x2F;&amp;#x2F; No test changes needed!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn foo_for_fizz() {
        assert_eq!(foo_if_fizz(&amp;quot;fizz&amp;quot;), &amp;quot;foo&amp;quot;)
    }

    #[test]
    fn bar_for_fuzz() {
        assert_eq!(foo_if_fizz(&amp;quot;fuzz&amp;quot;), &amp;quot;bar&amp;quot;)
    }

    #[test]
    fn default_to_baz() {
        assert_eq!(foo_if_fizz(&amp;quot;literally anything&amp;quot;), &amp;quot;baz&amp;quot;)
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once we replace this with &lt;code&gt;bar&lt;&#x2F;code&gt; it compiles, but it still doesn&#x27;t pass the test, which is our step 2. in the comments.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Testing of exercises&amp;#x2F;if&amp;#x2F;if2.rs failed! Please try again. Here&amp;#x27;s the output:

running 3 tests
test tests::bar_for_fuzz ... ok
test tests::foo_for_fizz ... ok
test tests::default_to_baz ... FAILED

successes:

successes:
    tests::bar_for_fuzz
    tests::foo_for_fizz

failures:

---- tests::default_to_baz stdout ----
thread &amp;#x27;tests::default_to_baz&amp;#x27; panicked at &amp;#x27;assertion failed: `(left == right)`
  left: `&amp;quot;bar&amp;quot;`,
 right: `&amp;quot;baz&amp;quot;`&amp;#x27;, exercises&amp;#x2F;if&amp;#x2F;if2.rs:34:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::default_to_baz

test result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So here we see that the first two test are passing &lt;code&gt;bar_for_fuzz&lt;&#x2F;code&gt; and &lt;code&gt;foo_for_fizz&lt;&#x2F;code&gt; but &lt;code&gt;default_to_baz&lt;&#x2F;code&gt; is not. So let&#x27;s take a closer look at the tests and see why this is happening.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;foo-for-fizz-test&quot;&gt;&lt;code&gt;foo_for_fizz&lt;&#x2F;code&gt; test&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    #[test]
    fn foo_for_fizz() {
        assert_eq!(foo_if_fizz(&amp;quot;fizz&amp;quot;), &amp;quot;foo&amp;quot;) &amp;#x2F;&amp;#x2F; first test clearly defined in our `if` statement
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which is in our code with&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;if fizzish == &amp;quot;fizz&amp;quot; {
	&amp;quot;foo&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;bar-for-fuzz-test&quot;&gt;&lt;code&gt;bar_for_fuzz&lt;&#x2F;code&gt; test&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;    #[test]
    fn bar_for_fuzz() {
        assert_eq!(foo_if_fizz(&amp;quot;fuzz&amp;quot;), &amp;quot;bar&amp;quot;) &amp;#x2F;&amp;#x2F; if we have &amp;quot;fuzz&amp;quot; we should get &amp;quot;bar&amp;quot;
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This tells us that if have &lt;code&gt;Fuzz&lt;&#x2F;code&gt; then we get bar, but this is working only because we have &lt;code&gt;&amp;quot;bar&amp;quot;&lt;&#x2F;code&gt; as our &lt;code&gt;else&lt;&#x2F;code&gt; not because we have &lt;code&gt;&amp;quot;fuzz&amp;quot;&lt;&#x2F;code&gt; defined.&lt;&#x2F;p&gt;
&lt;p&gt;We do so by adding an &lt;code&gt;else if&lt;&#x2F;code&gt; statement like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;else if fizzish == &amp;quot;fuzz&amp;quot; {
	&amp;quot;bar&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This will meet the conditions of our second test&lt;&#x2F;p&gt;
&lt;h2 id=&quot;default-to-baz-test&quot;&gt;&lt;code&gt;default_to_baz&lt;&#x2F;code&gt; test&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[test]
    fn default_to_baz() {
        assert_eq!(foo_if_fizz(&amp;quot;literally anything&amp;quot;), &amp;quot;baz&amp;quot;)
    }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In our final test we see that it&#x27;s saying whatever else, doesn&#x27;t matter what it is, just give me &lt;code&gt;&amp;quot;baz&amp;quot;&lt;&#x2F;code&gt; so we can easily do that by adding our final &lt;code&gt;else&lt;&#x2F;code&gt; condition to our &lt;code&gt;foo_if_fizz&lt;&#x2F;code&gt; function, that would look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn foo_if_fizz(fizzish: &amp;amp;str) -&amp;gt; &amp;amp;str {
    if fizzish == &amp;quot;fizz&amp;quot; {
        &amp;quot;foo&amp;quot;
    } else if fizzish == &amp;quot;fuzz&amp;quot; {
        &amp;quot;bar&amp;quot;
    } else { &amp;#x2F;&amp;#x2F; whatever else it is, just make it `&amp;quot;baz&amp;quot;`
        &amp;quot;baz&amp;quot;
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This gets our code to compile and pass it&#x27;s tests successfully.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Progress: [########&amp;gt;---------------------------------------------------] 14&amp;#x2F;94
✅ Successfully tested exercises&amp;#x2F;if&amp;#x2F;if2.rs!

🎉 🎉  The code is compiling, and the tests pass! 🎉 🎉
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright, I guess we get our first quiz after this 😧.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we delved into Rust &lt;code&gt;if&lt;&#x2F;code&gt; expressions, which are a fundamental part of the language&#x27;s control flow. We explored how to use &lt;code&gt;if&lt;&#x2F;code&gt;, &lt;code&gt;else if&lt;&#x2F;code&gt;, and &lt;code&gt;else&lt;&#x2F;code&gt; statements to create conditionals and solve problems in Rust. Additionally, we learned about Rust&#x27;s unique features, such as not requiring parentheses around &lt;code&gt;if&lt;&#x2F;code&gt; conditions and the treatment of &lt;code&gt;if&#x2F;else&lt;&#x2F;code&gt; conditionals as expressions. By understanding and mastering Rust &lt;code&gt;if&lt;&#x2F;code&gt; expressions, you&#x27;ll be better equipped to write efficient and clean Rust code for various applications.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>02 Rustlings functions</title>
          <pubDate>Wed, 19 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/02-rustlings-functions/</link>
          <guid>https://desmodrone.github.io/posts/02-rustlings-functions/</guid>
          <description>&lt;p&gt;With function we can learn to write more complex code and lean on the Rust debug errors for help.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-information&quot;&gt;Further information&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch03-03-how-functions-work.html&quot;&gt;How Functions Work&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;functions1-rs&quot;&gt;&lt;code&gt;functions1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    call_me();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;rust-error-for-function1-rs&quot;&gt;Rust Error for &lt;code&gt;function1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s take a look at the compiler output so we can see what it&#x27;s telling us fix.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️ Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions1.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0425]: cannot find function `call_me` in this scope
 --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions1.rs:7:5
  |
7 |     call_me();
  |     ^^^^^^^ not found in this scope

error: aborting due to previous error

For more information about this error, try `rustc --explain E0425`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So what is this telling us? It&#x27;s essentially saying that &lt;code&gt;call me&lt;&#x2F;code&gt; is not defined within &lt;code&gt;fn main()&lt;&#x2F;code&gt; because we&#x27;re trying to call it, but it doesn&#x27;t know what to do with it. So let&#x27;s fix it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function1-rs-solution&quot;&gt;&lt;code&gt;function1.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.

fn main() {
    fn call_me() {  &amp;#x2F;&amp;#x2F; we define a basic function called call_me()
    }
    call_me();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s easy enough we create a functioned called &lt;code&gt;call_me()&lt;&#x2F;code&gt; inside of our &lt;code&gt;fn main()&lt;&#x2F;code&gt; so when we call it, the compiler knows where to look. Of course at this point it&#x27;s not doing much of anything.&lt;&#x2F;p&gt;
&lt;p&gt;We can modify this a little and make the function do something, like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    fn call_me() {
        println!(&amp;quot;Call me please&amp;quot;) &amp;#x2F;&amp;#x2F; add a println! with at string inside the call_me() function
    }
    call_me();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Putting a &lt;code&gt;println!&lt;&#x2F;code&gt; with some text will print out the text when &lt;code&gt;call_me()&lt;&#x2F;code&gt; is called. In this case: &lt;code&gt;Call me please&lt;&#x2F;code&gt; or if we wanted to some math, we could do:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions1.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.

fn main() {
    fn call_me() {
        println!(&amp;quot;{}&amp;quot;, 4+4) &amp;#x2F;&amp;#x2F; here we change the string into a simple addition
    }
    call_me();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This would print: &lt;code&gt;8&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function2-rs&quot;&gt;&lt;code&gt;function2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    call_me(3);
}

fn call_me(num:) {
    for i in 0..num {
        println!(&amp;quot;Ring! Call number {}&amp;quot;, i + 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;rust-errors-for-function2-rs&quot;&gt;Rust Errors for &lt;code&gt;function2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions2.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected type, found `)`
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions2.rs:10:16
   |
10 | fn call_me(num:) {
   |                ^ expected type

error[E0425]: cannot find value `num` in this scope
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions2.rs:11:17
   |
11 |     for i in 0..num {
   |                 ^^^ not found in this scope
   |
help: you might have meant to write `.` instead of `..`
   |
11 -     for i in 0..num {
11 +     for i in 0.num {
   |

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0425`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alright so I&#x27;ve got a couple of errors here:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Line 10, there&#x27;s a type expected, so we fix that by adding &lt;code&gt;i32&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Adding the type solved all of our problems, nothing else do here.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function2-rs-solution&quot;&gt;&lt;code&gt;function2.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.

fn main() {
    call_me(3);
}

fn call_me(num: i32) { &amp;#x2F;&amp;#x2F; added the `i32` type here
    for i in 0..num {
        println!(&amp;quot;Ring! Call number {}&amp;quot;, i + 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This reminds us that Rust&#x27;s function signatures require type annotations. Once we fixed the function&#x27;s signature we get the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Ring! Call number 1
Ring! Call number 2
Ring! Call number 3

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;function3-rs&quot;&gt;&lt;code&gt;function3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions3.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions3` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    call_me();
}

fn call_me(num: u32) {
    for i in 0..num {
        println!(&amp;quot;Ring! Call number {}&amp;quot;, i + 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;rust-errors-for-function3-rs&quot;&gt;Rust errors for &lt;code&gt;function3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions3.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0061]: this function takes 1 argument but 0 arguments were supplied
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions3.rs:7:5
   |
7  |     call_me();
   |     ^^^^^^^-- an argument of type `u32` is missing
   |
note: function defined here
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions3.rs:10:4
   |
10 | fn call_me(num: u32) {
   |    ^^^^^^^ --------
help: provide the argument
   |
7  |     call_me(&amp;#x2F;* u32 *&amp;#x2F;);
   |            ~~~~~~~~~~~

error: aborting due to previous error

For more information about this error, try `rustc --explain E0061`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once again the Rust compiler comes through with a very clear suggestion pointing out that &lt;code&gt;call_me()&lt;&#x2F;code&gt; is missing an argument of type &lt;code&gt;u32&lt;&#x2F;code&gt; it even provides &lt;code&gt;help&lt;&#x2F;code&gt; in the last segment showing us where to put the &lt;code&gt;u32&lt;&#x2F;code&gt;: &lt;code&gt;call_me(&#x2F;* u32 *&#x2F;);&lt;&#x2F;code&gt; How great is that. So what &lt;code&gt;u32&lt;&#x2F;code&gt; should we put in there? Let&#x27;s try &lt;code&gt;6&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;functions3-rs-solution&quot;&gt;&lt;code&gt;functions3.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions3.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions3` or use the `hint` watch subcommand for a hint.

fn main() {
    call_me(6); &amp;#x2F;&amp;#x2F; we&amp;#x27;ve added 6 here
}

fn call_me(num: u32) {
    for i in 0..num {
        println!(&amp;quot;Ring! Call number {}&amp;quot;, i + 1);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And just like that we&#x27;re back in business. Our &lt;code&gt;fn main()&lt;&#x2F;code&gt; runs and calls &lt;code&gt;call_me&lt;&#x2F;code&gt; six times because that&#x27;s the number we&#x27;ve passed in to &lt;code&gt;call_me(6)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Ring! Call number 1
Ring! Call number 2
Ring! Call number 3
Ring! Call number 4
Ring! Call number 5
Ring! Call number 6

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Just to be clear in this case we could put any &lt;code&gt;u32&lt;&#x2F;code&gt; we wanted, including &lt;code&gt;0&lt;&#x2F;code&gt;, but that doesn&#x27;t print anything. We can&#x27;t pass in a negative number in this case either because defined a &lt;code&gt;u32&lt;&#x2F;code&gt; and exceeding the limit of a &lt;code&gt;u32&lt;&#x2F;code&gt; would also fail.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function4-rs&quot;&gt;&lt;code&gt;function4.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions4.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions4` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; This store is having a sale where if the price is an even number, you get
&amp;#x2F;&amp;#x2F; 10 Rustbucks off, but if it&amp;#x27;s an odd number, it&amp;#x27;s 3 Rustbucks off.
&amp;#x2F;&amp;#x2F; (Don&amp;#x27;t worry about the function bodies themselves, we&amp;#x27;re only interested
&amp;#x2F;&amp;#x2F; in the signatures for now. If anything, this is a good way to peek ahead
&amp;#x2F;&amp;#x2F; to future exercises!)

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let original_price = 51;
    println!(&amp;quot;Your sale price is {}&amp;quot;, sale_price(original_price));
}

fn sale_price(price: i32) -&amp;gt; {
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
}

fn is_even(num: i32) -&amp;gt; bool {
    num % 2 == 0
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;re getting a little more instruction here, but as always the key lies in looking at the Rust compiler&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions4.rs failed! Please try again. Here&amp;#x27;s the output:
error: expected type, found `{`
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions4.rs:17:30
   |
17 | fn sale_price(price: i32) -&amp;gt; {
   |                              ^ expected type

error: aborting due to previous error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Looks pretty straight forward, line 17 is missing a type in the function&#x27;s signature, looks like we should expect to return an &lt;code&gt;i32&lt;&#x2F;code&gt;, so let&#x27;s try that.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let original_price = 51;
    println!(&amp;quot;Your sale price is {}&amp;quot;, sale_price(original_price));
}

fn sale_price(price: i32) -&amp;gt; i32 { &amp;#x2F;&amp;#x2F; added return type here: `i32`
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
}

fn is_even(num: i32) -&amp;gt; bool {
    num % 2 == 0
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And it works. Nothing too difficult, if you look at the &lt;code&gt;is_even&lt;&#x2F;code&gt; function there the function is returning a &lt;code&gt;bool&lt;&#x2F;code&gt; instead of an &lt;code&gt;i32&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
Your sale price is 48

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;function5-rs&quot;&gt;&lt;code&gt;function5.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; functions5.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint functions5` or use the `hint` watch subcommand for a hint.

&amp;#x2F;&amp;#x2F; I AM NOT DONE

fn main() {
    let answer = square(3);
    println!(&amp;quot;The square of 3 is {}&amp;quot;, answer);
}

fn square(num: i32) -&amp;gt; i32 {
    num * num;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;function5-rs-errors&quot;&gt;&lt;code&gt;function5.rs&lt;&#x2F;code&gt; Errors&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;⚠️  Compiling of exercises&amp;#x2F;functions&amp;#x2F;functions5.rs failed! Please try again. Here&amp;#x27;s the output:
error[E0308]: mismatched types
  --&amp;gt; exercises&amp;#x2F;functions&amp;#x2F;functions5.rs:11:24
   |
11 | fn square(num: i32) -&amp;gt; i32 {
   |    ------              ^^^ expected `i32`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
12 |     num * num;
   |              - help: remove this semicolon to return this value

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is once again a very helpful explanation from the compiler, if we look at the &lt;code&gt;help: remove this semicolon to return this value&lt;&#x2F;code&gt; note, it tells why we are getting the error on line 11. Because with a &lt;code&gt;;&lt;&#x2F;code&gt; semicolon this function has no return value and this function expects a return value as we have defined in the function signature. So how do we solve this?&lt;&#x2F;p&gt;
&lt;p&gt;The easiest way is to remove the semicolon as the Rust compiler suggests, but just so we have another solution we can also use the &lt;code&gt;return&lt;&#x2F;code&gt; keyword. From my understanding it&#x27;s more idiomatic to just remove the &lt;code&gt;;&lt;&#x2F;code&gt; but I wanted to also bring up the possibility of using &lt;code&gt;return&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The reason this happens in Rust is because the compiler distinguishes between expressions and statements. Expressions return a value based on their operands(s), and statements simply return a &lt;code&gt;()&lt;&#x2F;code&gt; type.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;function5-rs-solution&quot;&gt;&lt;code&gt;function5.rs&lt;&#x2F;code&gt; Solution&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main() {
    let answer = square(3);
    println!(&amp;quot;The square of 3 is {}&amp;quot;, answer);
}

fn square(num: i32) -&amp;gt; i32 {
    num * num
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;zsh&quot; class=&quot;language-zsh &quot;&gt;&lt;code class=&quot;language-zsh&quot; data-lang=&quot;zsh&quot;&gt;Output:
====================
The square of 3 is 9

====================
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we&#x27;ve explored various Rust functions and the importance of function signatures, including specifying the correct types for both input parameters and return values. We have also seen how the Rust compiler provides helpful error messages and suggestions to guide us in fixing issues with our code. Additionally, we&#x27;ve briefly touched upon the differences between expressions and statements in Rust, which determine whether a value is returned or not.&lt;&#x2F;p&gt;
&lt;p&gt;Remember that Rust functions are powerful tools for writing clean, maintainable code. Keep practicing and exploring different function patterns, and you&#x27;ll soon become proficient in writing complex Rust programs.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>01 Rustlings variables</title>
          <pubDate>Mon, 17 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/01-rustlings-variables/</link>
          <guid>https://desmodrone.github.io/posts/01-rustlings-variables/</guid>
          <description>&lt;p&gt;In Rust, variables are immutable by default.
When a variable is immutable, once a value is bound to a name, you can’t change that value.
You can however, make a variable mutable by adding &lt;code&gt;mut&lt;&#x2F;code&gt; in front of the variable name.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-reading&quot;&gt;Further reading:&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch03-01-variables-and-mutability.html&quot;&gt;Variables and Mutability&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;variables1-rs&quot;&gt;&lt;code&gt;variables1.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables1.rs
&amp;#x2F;&amp;#x2F; Make me compile!
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables1` or use the `hint` watch subcommand for a hint.

fn main() {
    let x = 5; &amp;#x2F;&amp;#x2F; very simple excerize that is missing the `let`
    println!(&amp;quot;x has the value {}&amp;quot;, x);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Adding the &lt;code&gt;let&lt;&#x2F;code&gt; to the statement allows &lt;code&gt;x&lt;&#x2F;code&gt; to bind to &lt;code&gt;5&lt;&#x2F;code&gt;, very straight forward solution&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables2-rs&quot;&gt;&lt;code&gt;variables2.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables2.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables2` or use the `hint` watch subcommand for a hint.

fn main() {
    let x: u8 = 5; &amp;#x2F;&amp;#x2F; you could also just write `let x = 5`
    if x == 10 {
        println!(&amp;quot;x is ten!&amp;quot;);
    } else {
        println!(&amp;quot;x is not ten!&amp;quot;);
    }
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is basically the opposite of what we saw before with the variable binding in the &lt;code&gt;variables1.rs&lt;&#x2F;code&gt; example, except in this case we&#x27;re missing the number that &lt;code&gt;x&lt;&#x2F;code&gt; should be bound to.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables3-rs&quot;&gt;&lt;code&gt;variables3.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables3.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.

fn main() {
    let x: i32 = -123; &amp;#x2F;&amp;#x2F; adding `= -123` for the code to compile.
    println!(&amp;quot;Number {}&amp;quot;, x);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since we have &lt;code&gt;x&lt;&#x2F;code&gt; as an &lt;code&gt;i32&lt;&#x2F;code&gt; let&#x27;s have some fun and add a negative number. Again this was missing the second half of the statement.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables4-rs&quot;&gt;&lt;code&gt;variables4.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables4.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables4` or use the `hint` watch subcommand for a hint.

fn main() {
    let mut x = 3; &amp;#x2F;&amp;#x2F; mut is the key here
    println!(&amp;quot;Number {}&amp;quot;, x);
    x = 5; &amp;#x2F;&amp;#x2F; don&amp;#x27;t change this line
    println!(&amp;quot;Number {}&amp;quot;, x);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As the opening text declares variables are immutable by default so this code doesn&#x27;t compile because &lt;code&gt;x&lt;&#x2F;code&gt; is being  bound twice to different numbers without declaring it &lt;code&gt;mut&lt;&#x2F;code&gt;, this code will not compile.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables5-rs&quot;&gt;&lt;code&gt;variables5.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables5.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables5` or use the `hint` watch subcommand for a hint.

fn main() {
    let number = &amp;quot;T-H-R-E-E&amp;quot;; &amp;#x2F;&amp;#x2F; don&amp;#x27;t change this line
    println!(&amp;quot;Spell a Number : {}&amp;quot;, number);
    let number = 3; &amp;#x2F;&amp;#x2F; don&amp;#x27;t rename this variable
    println!(&amp;quot;Number plus two is : {}&amp;quot;, number + 2);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this exercise we don&#x27;t rename the variable &lt;code&gt;number&lt;&#x2F;code&gt; but we shadow it by declaring it again with &lt;code&gt;let&lt;&#x2F;code&gt; this allows us to change the type from a &lt;code&gt;&amp;amp;Str&lt;&#x2F;code&gt; to a integer.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables6-rs&quot;&gt;&lt;code&gt;variables6.rs&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; variables6.rs
&amp;#x2F;&amp;#x2F; Execute `rustlings hint variables6` or use the `hint` watch subcommand for a hint.


const NUMBER: i32 = 3; &amp;#x2F;&amp;#x2F; added `:i32`
fn main() {
    println!(&amp;quot;Number {}&amp;quot;, NUMBER);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Constants are another type of variable that is available, but these are &lt;em&gt;always&lt;&#x2F;em&gt; immutable they&#x27;re declared with &lt;code&gt;const&lt;&#x2F;code&gt; instead of let and types must always be annotated. So we have to add &lt;code&gt;: i32&lt;&#x2F;code&gt; to make the code compile.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Understanding variables and their mutability is an essential aspect of learning Rust. This blog post covered the Rustlings exercises that demonstrated the usage of variables in different scenarios, including how to declare and shadow variables, work with constants, and use the &lt;code&gt;mut&lt;&#x2F;code&gt; keyword to make variables mutable. These fundamental concepts lay the groundwork for grasping more advanced topics in Rust programming.&lt;&#x2F;p&gt;
&lt;p&gt;As you continue your Rust journey, always remember that variables in Rust are immutable by default, providing safety and predictability in your code. When needed, you can use the &lt;code&gt;mut&lt;&#x2F;code&gt; keyword to allow a variable to be mutable. Constants are also available, providing values that cannot be changed and must have their types annotated.&lt;&#x2F;p&gt;
&lt;p&gt;We encourage you to explore the Rust documentation and practice further exercises to strengthen your understanding of these concepts. Happy coding!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Hello (again) Rustlings</title>
          <pubDate>Tue, 11 Apr 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/hello-rustlings/</link>
          <guid>https://desmodrone.github.io/posts/hello-rustlings/</guid>
          <description>&lt;h2 id=&quot;rustling-s-index&quot;&gt;Rustling&#x27;s Index&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;01-rustlings-variables&#x2F;&quot;&gt;01_rustlings_variables&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;02-rustlings-functions&#x2F;&quot;&gt;02_rustlings_functions&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;03-rustlings-if&#x2F;&quot;&gt;03_rustlings_functions&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;04-rustlings-quiz1&#x2F;&quot;&gt;04_rustlings_quiz1&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Inspired by Tris Oaten&#x27;s recent video &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;2hXNd6x9sZs&quot;&gt;How to Learn Rust&lt;&#x2F;a&gt; on his excellent YouTube channel &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;@NoBoilerplate&quot;&gt;No Boilerplate&lt;&#x2F;a&gt;, I&#x27;ve decided to refocus my journey with the Rust programming language. In hopes of effectively learning Rust, I&#x27;ll be following the holy trinity of Rust learning resources as recommended by Tris:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;&quot;&gt;The Rust Programming Language&lt;&#x2F;a&gt; aka &amp;quot;The Book&amp;quot; (read it twice, first quickly)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rustlings&quot;&gt;Rustlings&lt;&#x2F;a&gt; (do it and then continue to practice your favorites)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;&quot;&gt;Rust by Example&lt;&#x2F;a&gt; (supplement where needed)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;While I&#x27;ve been studying Rust for a few months now, I&#x27;ve been mostly focused on &amp;quot;The Book&amp;quot; and doing random tutorials on YouTube, and small personal projects, etc.&lt;&#x2F;p&gt;
&lt;p&gt;Tris&#x27;s video was a timely reminder that Rustlings is a fantastic resource. Although it starts off easy, it gradually becomes more challenging. For some reason, I stopped doing these exercises in the past, but now that I started a blog, I thought it would be a good idea to share my learnings and document my progress as I go.&lt;&#x2F;p&gt;
&lt;p&gt;As I embark on this journey, I&#x27;ll start with the basics, following the structure of The Rust Book and practicing Rustlings exercises as Tris suggests.&lt;&#x2F;p&gt;
&lt;p&gt;By sharing my experiences, I hope to inspire others to explore Rust and motivate myself to stay committed to mastering this powerful language. Stay tuned for updates on my progress and insights into the world of Rust!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Notes on Traits and You: A Deep Dive Part 3</title>
          <pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/traits-301/</link>
          <guid>https://desmodrone.github.io/posts/traits-301/</guid>
          <description>&lt;h4 id=&quot;original-content-by-nell-shamrell-harrington&quot;&gt;Original content by Nell Shamrell-Harrington&lt;&#x2F;h4&gt;
&lt;p&gt;When looking for resources to help me better understand Rust Traits, I found &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;grU-4u0Okto&quot;&gt;this video&lt;&#x2F;a&gt;from &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;nellshamrell?s=21&amp;amp;t=EhxGdIZ2VJ9HIqIS1LXcpw&quot;&gt;Nell Shamrell-Harrington&lt;&#x2F;a&gt;. It&#x27;s a great intro and overview into using Traits, which can be a little confusing when you first start learning Rust.&lt;&#x2F;p&gt;
&lt;p&gt;So these are my notes on this talk, if you haven&#x27;t watched it and are struggling with learning Traits, I strongly suggest that you watch the video above before you do anything else. But if you&#x27;re short on time and just want to reference my notes -- here they are. Disclaimer: these notes are my own interpretation of the talk and may not necessarily reflect the views of the original speaker. These note are primarily for me to learn these concepts, and I publish them for others to see and maybe benefit from. Feel free to let me know if I have errors or have misrepresentations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;The talk covers 3 different ways that we can use Traits, I have already published the first two parts of these notes, you can see those linked below. So today we&#x27;ll cover the final note with Trait Objects.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-101&#x2F;&quot;&gt;Traits 101 Introduction&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-201&#x2F;&quot;&gt;Traits 201 Trait Bounds&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Traits 301 Trait Objects&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Nell brilliantly uses D&amp;amp;D as a metaphor to help explain Traits. It should be clear that the use of D&amp;amp;D is just to help grasp some concepts, and the D&amp;amp;D rules do not strictly apply in these concepts, so now that we have that out of the way let&#x27;s begin.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits-301-trait-objects&quot;&gt;Traits 301: Trait Objects&lt;&#x2F;h2&gt;
&lt;p&gt;This is where the magic really starts to happen and it might take a little to wrap your head around this concept but let&#x27;s take a look at how traditional object oriented programming languages hand this.&lt;&#x2F;p&gt;
&lt;p&gt;In traditional Object Oriented Programming we have Data &amp;amp; Behavior in one &amp;quot;place&amp;quot;. With Rust we can say that we use &lt;code&gt;enums&lt;&#x2F;code&gt; and &lt;code&gt;structs&lt;&#x2F;code&gt; for data, and &lt;code&gt;traits&lt;&#x2F;code&gt; for behavior, this actually gives us more flexibility and control&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Object Oriented Programming = (data and behaviour together)&lt;&#x2F;li&gt;
&lt;li&gt;Rust = enums&#x2F;structs (data), traits (behavior)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This is actually one of the powers that Rust has as we can mix and match behaviours as we need it in our code.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note:
Trait Objects allow us to work with types that implement a specific trait without knowing their exact type. They enable a more dynamic approach similar to traditional object-oriented programming languages but maintain Rust&#x27;s separation of data and behavior.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;So how does a Trait Object store it&#x27;s data? Well, a Trait Object contains the data in a trait pointer to a value on the heap.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Trait Object: Pointer(Data) -&amp;gt; Value(Heap)&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;
The advantage of doing this is that even if the size of the value on the heap varies, the size of the pointer will always be the same and it&#x27;s more predictable as well.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Trait Object: Trait(Behavior)&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;
Although the Data is located on the heap, one thing to note is you cannot add data to a trait object, this is key to understanding trait objects and how to use them. We point to the data at one specific point in time.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;back-to-d-d&quot;&gt;Back to D&amp;amp;D&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s go back our D&amp;amp;D analogy and this time we&#x27;ll look at different spells that can be cast in the game. Let&#x27;s say we have a wizard that needs to cast a bunch of different spells.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Cantrip&lt;&#x2F;li&gt;
&lt;li&gt;Transmutation&lt;&#x2F;li&gt;
&lt;li&gt;Enchantment&lt;&#x2F;li&gt;
&lt;li&gt;Necromancy&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Let&#x27;s start by creating these spells as structs&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; let&amp;#x27;s create these structs
struct Cantrip {

}

struct Enchantment {

}

struct Transmutation {

}

struct Necromancy {

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Although these are 4 different kinds of spells, the thing that they all have in common is that they all need to be cast, even if they specific way that they are cast is different from spell to spell.&lt;&#x2F;p&gt;
&lt;p&gt;So with this information let&#x27;s make a &lt;code&gt;Cast&lt;&#x2F;code&gt; trait&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; let&amp;#x27;s make a trait, for now we won&amp;#x27;t define a default behaviour
pub trait Cast {
	fn cast(&amp;amp;self);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now let&#x27;s implement the &lt;code&gt;Cast&lt;&#x2F;code&gt; trait on one our spells, let&#x27;s use &lt;code&gt;Cantrip&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; now we implement this trait for the Cantrip struct
impl Cast for Cantrip{
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Cantrip spell here
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s do the same for the &lt;code&gt;Transmutation&lt;&#x2F;code&gt; spell&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; we do the same for the transmutation struct
impl Cast for Transmutation
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Transmutation spell here
	}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can do the same for our &lt;code&gt;Enchament&lt;&#x2F;code&gt; and &lt;code&gt;Necromancy&lt;&#x2F;code&gt; spells, so each of the spells can now be cast, although each spell is defined differently, below is the full list of spells with &lt;code&gt;Cast&lt;&#x2F;code&gt; implemented on them.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; now we implement this trait for the Cantrip struct
impl Cast for Cantrip{
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Cantrip spell here
	}
}

&amp;#x2F;&amp;#x2F; we do the same for the transmutation struct
impl Cast for Transmutation
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Transmutation spell here
	}


&amp;#x2F;&amp;#x2F; we do the same for the Enchantment struct
impl Cast for Enchantment
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Enchantment spell here
	}

&amp;#x2F;&amp;#x2F; we do the same for the Necromancy struct
impl Cast for Necromancy
	fn cast(&amp;amp;self){
		&amp;#x2F;&amp;#x2F; We&amp;#x27;d put details of casting a Necromancy spell here
	}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Cool, we&#x27;re building up a little library of spells, so how do we organize these spells, where do we keep them? In a spell book of course! We&#x27;ll represent our spell book as a struct&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct Spellbook {
	pub spells: Vec&amp;lt;Box&amp;gt;&amp;lt;Cast&amp;gt;&amp;gt;, &amp;#x2F;&amp;#x2F; here is where we define the spell field
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s break this line of code a little bit. As you can see we define &lt;code&gt;spells&lt;&#x2F;code&gt; as a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;, (we don&#x27;t go into generics in this blog but that&#x27;s what the T represent, a generic type), a Vector that contains an object of a type, the Type that we are grouping in our vector for spells is a &lt;code&gt;&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt;. A &lt;code&gt;Box&lt;&#x2F;code&gt; in Rust is a pointer to a value on the heap (remember we talked about that earlier?).
The reason we choose to use &lt;code&gt;Box&lt;&#x2F;code&gt; in &lt;code&gt;Vec&amp;lt;Box&amp;gt;&amp;lt;&amp;lt;Cast&amp;gt;&amp;gt;&lt;&#x2F;code&gt; is because it allows us to store the trait object in a dynamically sized container, such as a vector, since trait objects have an unknown size at compile time.&lt;&#x2F;p&gt;
&lt;p&gt;With a &lt;code&gt;Vec&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; we can only point to a value of a certain type (T) as we see here, in our case we say that we can contain any type that implements the &lt;code&gt;Cast&lt;&#x2F;code&gt; trait: &lt;code&gt;Vec&amp;lt;Box&amp;lt;Cast&amp;gt;&amp;gt;&lt;&#x2F;code&gt; so &lt;code&gt;Box&lt;&#x2F;code&gt; must point to a value that implements the &lt;code&gt;Cast&lt;&#x2F;code&gt; trait. It doesn&#x27;t matter what type as long as it implements that particular trait.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s review: The &lt;code&gt;pub spells&lt;&#x2F;code&gt; field is a vector &lt;code&gt;Vec&lt;&#x2F;code&gt;, that vector contains &lt;code&gt;Boxes&lt;&#x2F;code&gt; and those boxes point to values that implement the &lt;code&gt;Cast&lt;&#x2F;code&gt; trait represented as: &lt;code&gt;pub spells: Vec&amp;lt;Box&amp;gt;&amp;lt;Cast&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;What this means is that our Wizard can now cast ALL of these spells, one right after the other and we can do this in Rust by defining the behavior in our &lt;code&gt;Spellbook&lt;&#x2F;code&gt; struct.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl Spellbook {
	pub fn run(&amp;amp;self) { &amp;#x2F;&amp;#x2F; implementing a function called run
		for spell in self.spells.iter(){ &amp;#x2F;&amp;#x2F; this will iterate through the spells
			spell.cast(); &amp;#x2F;&amp;#x2F; and casting spells one after the other
		}
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a function that &amp;quot;runs&amp;quot; the spells essentially iterating through them and casting them one after the other.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s see a visual representation of our Wizard in action.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;wizard.png&quot; alt=&quot;wizard&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Now let&#x27;s look at how this code would look like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let spell_book = Spellbook {
	spells: vec![
	&amp;#x2F;&amp;#x2F; different types of spells, each implement the `cast`trait
		Box::new(Cantrip{}),
		Box::new(Transmutation{}),
		Box::new(Enchantment{}),
		Box::new(Necromancy{}),
	],
};
spell_book.run(); &amp;#x2F;&amp;#x2F; this casts each spell, in which ever way they need to be cast
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What this highlights is that Trait Object are great for heterogeneous collections or diverse and mixed collections. Where we can have objects of different types stored in the same place &lt;em&gt;It doesn&#x27;t matter what type something is&lt;&#x2F;em&gt; as long as it &lt;em&gt;implements a certain trait&lt;&#x2F;em&gt;, this gives us a ton of flexibility when using Rust.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;recap&quot;&gt;Recap&lt;&#x2F;h2&gt;
&lt;p&gt;In this blog post, we explored Rust Traits, focusing on Trait Objects. By diving into a D&amp;amp;D-themed example, we demonstrated the power and flexibility of Traits in Rust. Here are the key takeaways:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Rust separates data (enums&#x2F;structs) and behavior (traits), which allows for greater flexibility and control compared to traditional object-oriented programming languages.&lt;&#x2F;li&gt;
&lt;li&gt;Trait Objects enable us to work with types that implement a specific trait without knowing their exact type. This approach is similar to traditional object-oriented programming languages but maintains Rust&#x27;s separation of data and behavior.&lt;&#x2F;li&gt;
&lt;li&gt;Trait Objects are particularly useful for heterogeneous collections or diverse and mixed collections. They allow us to store objects of different types in the same place as long as they implement a certain trait.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;Box&lt;&#x2F;code&gt; pointer is utilized for storing trait objects in dynamically sized containers, such as vectors, since trait objects have an unknown size at compile time.&lt;&#x2F;li&gt;
&lt;li&gt;The D&amp;amp;D example illustrated how to create structs, implement traits, and use Trait Objects to organize and execute a collection of diverse spells.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;By understanding and leveraging Rust Traits and Trait Objects, you can harness the flexibility and power of the Rust programming language to build efficient and maintainable code. With practice and review of &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;grU-4u0Okto&quot;&gt;Nell&#x27;s excellent video&lt;&#x2F;a&gt;, you&#x27;ll be mastering Traits in no time.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Notes on Traits and You: A Deep Dive Part 2</title>
          <pubDate>Thu, 23 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/traits-201/</link>
          <guid>https://desmodrone.github.io/posts/traits-201/</guid>
          <description>&lt;h4 id=&quot;original-content-by-nell-shamrell-harrington&quot;&gt;Original content by Nell Shamrell-Harrington&lt;&#x2F;h4&gt;
&lt;p&gt;When looking for resources to help me better understand Rust Traits, I found &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;grU-4u0Okto&quot;&gt;this video&lt;&#x2F;a&gt;from &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;nellshamrell?s=21&amp;amp;t=EhxGdIZ2VJ9HIqIS1LXcpw&quot;&gt;Nell Shamrell-Harrington&lt;&#x2F;a&gt;. It&#x27;s a great intro and overview into using Traits, which can be a little confusing when you first start learning Rust.&lt;&#x2F;p&gt;
&lt;p&gt;So these are my notes on this talk, if you haven&#x27;t watched it and are struggling with learning Traits, I strongly suggest that you watch the video above before you do anything else. But if you&#x27;re short on time and just want to reference my notes -- here they are. Disclaimer: these notes are my own interpretation of the talk and may not necessarily reflect the views of the original speaker. These note are primarily for me to learn these concepts, and I publish them for others to see and maybe benefit from. Feel free to let me know if I have errors or have misrepresentations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;The talk covers 3 different ways that we can use Traits, I have already written my first part of these notes, you can see those linked below.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-101&#x2F;&quot;&gt;Traits 101 Introduction&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Traits 201 Trait Bounds&lt;&#x2F;li&gt;
&lt;li&gt;Traits 301 Trait Objects&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Nell brilliantly uses D&amp;amp;D as a metaphor to help explain Traits. It should be clear that the use of D&amp;amp;D is just to help grasp some concepts, and the D&amp;amp;D rules do not strictly apply in these concepts, so now that we have that out of the way let&#x27;s begin.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits-201-trait-bounds&quot;&gt;Traits 201: Trait Bounds&lt;&#x2F;h2&gt;
&lt;p&gt;Today we cover Traits Bounds. In my previous notes we used 4 different races to explain how traits can be used with those races.
Now, we&#x27;re going to add a 5th race: the &lt;em&gt;Half-Elf&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s our full list:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Dwarves&lt;&#x2F;li&gt;
&lt;li&gt;Elf&lt;&#x2F;li&gt;
&lt;li&gt;HalfOrc&lt;&#x2F;li&gt;
&lt;li&gt;Human&lt;&#x2F;li&gt;
&lt;li&gt;Half-Elf&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;traits-101&quot;&gt;Traits 101&lt;&#x2F;h2&gt;
&lt;p&gt;In our &lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-101&#x2F;&quot;&gt;previous note&lt;&#x2F;a&gt; we went through the process of how to define a Trait, we used &lt;code&gt;Constitution&lt;&#x2F;code&gt; as the trait we wanted to apply to the 4 different races in a couple of different ways. If you haven&#x27;t read that note, it might help to do so first to help better understand the basics of creating our characters, creating a Trait, defining race specific values as well as default values.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;trait-bounds&quot;&gt;Trait Bounds&lt;&#x2F;h2&gt;
&lt;p&gt;To help us understand Trait bounds, let&#x27;s look at how these races communicate. Each race has core languages that they speak, for example.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Dwarves: Common, Dwarvish&lt;&#x2F;li&gt;
&lt;li&gt;Elf: Common, Elvish&lt;&#x2F;li&gt;
&lt;li&gt;Half-Elf: Common, Elvish&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;defining-the-elvish-language-trait&quot;&gt;Defining the  &lt;code&gt;Elvish&lt;&#x2F;code&gt; language Trait&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s focus on the Elvish language first and define a trait for the language and define a &lt;code&gt;impl&lt;&#x2F;code&gt; for the &lt;code&gt;Elf&lt;&#x2F;code&gt; and &lt;code&gt;HalfElf&lt;&#x2F;code&gt; races.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Define the Elvish trait
pub trait Elvish {

}

&amp;#x2F;&amp;#x2F; Implement the Elvish trait for the Elf struct
impl Elvish for Elf {

}

&amp;#x2F;&amp;#x2F; Implement the Elvish trait for the HalfElf struct
impl Elvish for HalfElf {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This should be pretty straight-forward so far as it&#x27;s just like we started Traits 101.&lt;&#x2F;p&gt;
&lt;p&gt;Now let&#x27;s make a function to allow our characters to actually speak &lt;code&gt;Elvish&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn speak_elvish(character: T) -&amp;gt; String{
	String::from(&amp;quot;yes&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Right now this function can be called on anything with no arguments, so we add an argument called character, but this character doesn&#x27;t need to be a specific type it can be any of the structs we&#x27;ve already created.&lt;&#x2F;p&gt;
&lt;p&gt;But if we add the &lt;code&gt;&amp;lt;T: Elvish&amp;gt;&lt;&#x2F;code&gt; this means we will only accept the &lt;code&gt;Elvish&lt;&#x2F;code&gt; trait.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn speak_elvish&amp;lt;T: Elvish&amp;gt;(character: T) -&amp;gt; String {
	String::from(&amp;quot;yes&amp;quot;)
}

let my_elf = Elf { name: String::from(&amp;quot;ElleElf&amp;quot;)};

&amp;#x2F;&amp;#x2F; we use our previously defined variable with the `speak_elvish` function
speak_elvish(my_elf)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So now if we call our &lt;code&gt;Elf&lt;&#x2F;code&gt; (&lt;code&gt;my_elf&lt;&#x2F;code&gt;) with &lt;code&gt;speak_elvish(my_elf)&lt;&#x2F;code&gt; it would return a &lt;code&gt;yes&lt;&#x2F;code&gt; because we have implemented &lt;code&gt;Elvish&lt;&#x2F;code&gt; for &lt;code&gt;Elf&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look at our &lt;code&gt;HalfElf&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; This is the same function that we defined before
pub fn speak_elvish&amp;lt;T: Elvish&amp;gt;(character: T) -&amp;gt; String {
	String::from(&amp;quot;yes&amp;quot;)
}
&amp;#x2F;&amp;#x2F; here we bind our HalfElf to `my_half_elf`
let my_half_elf = HalfElf { name: String::from(&amp;quot;HarryHalfElf&amp;quot;)};

speak_elvish(my_half_elf) &amp;#x2F;&amp;#x2F; again this returns &amp;#x27;yes&amp;#x27; since we&amp;#x27;ve implemented `Elvish` for `HalfElf`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So far so good right, I hope it&#x27;s pretty easy to see why both the &lt;code&gt;my_elf&lt;&#x2F;code&gt; and &lt;code&gt;my_half_elf&lt;&#x2F;code&gt; both return &lt;code&gt;yes&lt;&#x2F;code&gt; when we call them using the &lt;code&gt;speak_elvish&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;halforcs-incoming&quot;&gt;HalfOrcs Incoming&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;ve successfully implemented our &lt;code&gt;speak_elvish&lt;&#x2F;code&gt; trait on both our &lt;code&gt;Elf&lt;&#x2F;code&gt; type races, but let&#x27;s see what happens when we try to call our HalfOrc.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;pub fn speak_elvish&amp;lt;T: Elvish&amp;gt;(character: T) -&amp;gt; String {
	String::from(&amp;quot;yes&amp;quot;)
}

let my_half_orc = HalfOrc { name: String::from(&amp;quot;OscarOrc&amp;quot;)};

speak_elvish(my_half_orc)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So what happens if wet try to call &lt;code&gt;my_half_orc&lt;&#x2F;code&gt; with &lt;code&gt;speaks_elvish&lt;&#x2F;code&gt;? Well in this case our code would not compile because we have not implemented &lt;code&gt;Evlish&lt;&#x2F;code&gt; for &lt;code&gt;HalfOrc&lt;&#x2F;code&gt;. Of course, Orcs tend to break everything 😉.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;recap&quot;&gt;Recap&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Trait bounds&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt; allow a function to &lt;em&gt;&lt;strong&gt;only&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt; accept types that implement a certain trait or combination of traits. This provides a powerful way to enforce specific behaviors and characteristics for the types used in your functions. Furthermore, you can combine multiple traits as criteria for a function, allowing for even greater flexibility and control.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s walk through each step like we did in Traits 101 on how we define Trait bounds:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Define our Trait in our case it was the language trait &lt;code&gt;Elvish&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Implement &lt;code&gt;Elvish&lt;&#x2F;code&gt; for the races that speak it, in our case &lt;code&gt;Elf&lt;&#x2F;code&gt; and &lt;code&gt;HelfElf&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Define a function &lt;code&gt;speak_elvish&lt;&#x2F;code&gt; that only accepts the race we define within  the function. In our case we did it for both &lt;code&gt;Elf&lt;&#x2F;code&gt; and &lt;code&gt;HalfElf&lt;&#x2F;code&gt;. This function returns a &lt;code&gt;yes&lt;&#x2F;code&gt; if we call a race that has &lt;code&gt;Elvish&lt;&#x2F;code&gt; implemented, for example: &lt;code&gt;speak_elvish(my_half_elf) &lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;If we try to do the same with our &lt;code&gt;HalfOrc&lt;&#x2F;code&gt;: &lt;code&gt;speak_elvish(my_half_orc)&lt;&#x2F;code&gt;, our code won&#x27;t compile.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This was a short and straightforward introduction to Trait Bounds, and we&#x27;ll dive deeper into Rust Traits in the upcoming post on Traits 301: Trait Objects, where the real magic happens&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Notes on Traits and You: A Deep Dive Part 1</title>
          <pubDate>Tue, 14 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/traits-101/</link>
          <guid>https://desmodrone.github.io/posts/traits-101/</guid>
          <description>&lt;h4 id=&quot;original-content-by-nell-shamrell-harrington&quot;&gt;Original content by Nell Shamrell-Harrington&lt;&#x2F;h4&gt;
&lt;p&gt;When looking for resources to help me better understand Rust Traits, I found &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;grU-4u0Okto&quot;&gt;this video&lt;&#x2F;a&gt;from &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;nellshamrell?s=21&amp;amp;t=EhxGdIZ2VJ9HIqIS1LXcpw&quot;&gt;Nell Shamrell-Harrington&lt;&#x2F;a&gt;. It&#x27;s a great intro and overview into using Traits, which can be a little confusing when you first start learning Rust.&lt;&#x2F;p&gt;
&lt;p&gt;So these are my notes on this talk, if you haven&#x27;t watched it and are struggling with learning Traits, I strongly suggest that you watch the video above before you do anything else. But if you&#x27;re short on time and just want to reference my notes -- here they are. Disclaimer: these notes are my own interpretation of the talk and may not necessarily reflect the views of the original speaker. These note are primarily for me to learn these concepts, and I publish them for others to see and maybe benefit from. Feel free to let me know if I have errors or have misrepresentations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;The talk covers 3 different ways that we can use Traits&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Traits 101 Introduction&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-201&#x2F;&quot;&gt;Traits 201 Trait Bounds&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Traits 301 Trait Objects&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Nell brilliantly uses D&amp;amp;D as a metaphor to help explain Traits. It should be clear that the use of D&amp;amp;D is just to help grasp some concepts, and the D&amp;amp;D rules do not strictly apply in these concepts, so now that we have that out of the way let&#x27;s begin.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;traits-101&quot;&gt;Traits: 101&lt;&#x2F;h2&gt;
&lt;p&gt;On this post we will cover Traits 101, this will keep each post shorter and easier to digest.&lt;&#x2F;p&gt;
&lt;p&gt;In D&amp;amp;D there are many different races, but we&#x27;ll start by using these 4 different races:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Dwarves&lt;&#x2F;li&gt;
&lt;li&gt;Elf&lt;&#x2F;li&gt;
&lt;li&gt;HalfOrc&lt;&#x2F;li&gt;
&lt;li&gt;Human&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;creating-our-structs&quot;&gt;Creating our Structs&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s create these races as structs in Rust&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;struct Dwarf {
	name:String
}

struct Elf {
	name:String
}

struct HalfOrc {
	name:String
}

struct Human {
	name:String
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see this is pretty straight forward code where we define the struct name (&lt;code&gt;Dwarf&lt;&#x2F;code&gt;, &lt;code&gt;Elf&lt;&#x2F;code&gt; etc.) and then add the &lt;code&gt;name:String&lt;&#x2F;code&gt; to allow our characters to be named.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-our-dwarf&quot;&gt;Creating our Dwarf&lt;&#x2F;h2&gt;
&lt;p&gt;First, let&#x27;s create a Dwarf character.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_dwarf = Dwarf {
	name: String::from(&amp;quot;DanDwarf&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A variable &lt;code&gt;my_dwarf&lt;&#x2F;code&gt; that stores our &lt;code&gt;Dwarf&lt;&#x2F;code&gt; type and we name him &lt;code&gt;DanDwarf&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;d-d-core-traits&quot;&gt;D&amp;amp;D Core Traits&lt;&#x2F;h2&gt;
&lt;p&gt;In D&amp;amp;D each character has core traits:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Strength&lt;&#x2F;li&gt;
&lt;li&gt;Dexterity&lt;&#x2F;li&gt;
&lt;li&gt;Constitution&lt;&#x2F;li&gt;
&lt;li&gt;Intelligence&lt;&#x2F;li&gt;
&lt;li&gt;Wisdom&lt;&#x2F;li&gt;
&lt;li&gt;Charisma&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;If you are not familiar in D&amp;amp;D, character&#x27;s core traits are defined in numbers, so an example would be that a character could have a Strength of: 8, a Dexterity of: 4, and a Constitution of 2, etc. as a base and depending on equipment or spells cast these traits could be boosted (or lowered).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;defining-a-trait&quot;&gt;Defining a Trait&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s first define a &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait that we can use on our soon to be defined Characters&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Let&amp;#x27;s make a constitution trait
&amp;#x2F;&amp;#x2F; where we define one function `constitution_bonus`
pub triat Constitution {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;implementing-constitution-for-dwarf&quot;&gt;Implementing &lt;code&gt;Constitution&lt;&#x2F;code&gt; for &lt;code&gt;Dwarf&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;So let&#x27;s take one of these traits, in our case Constitution and define it in Rust for our Dwarf.  We&#x27;ll say that Dwarves have a Constitution bonus of 2.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F;implemeting the trait
impl Constitution for Dwarf {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	2 &amp;#x2F;&amp;#x2F; this returns 2, anytime the instance of a dwarf is called.
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now that we&#x27;ve defined our trait we go back to our Dwarf, using our just defined  &lt;code&gt;constitution_bounus&lt;&#x2F;code&gt; that we can call on &lt;code&gt;my_dwarf&lt;&#x2F;code&gt; as shown below.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; back to making the character
let my_dwarf = Dwarf {
	name: String::from(&amp;quot;DanDwarf&amp;quot;)
};

my_dwarf.constitution_bonus(); &amp;#x2F;&amp;#x2F; Returns 2
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this way no matter how many Dwarves we create, every single one of them will have the &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; of &lt;code&gt;2&lt;&#x2F;code&gt; attached.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-a-halforc&quot;&gt;Creating a HalfOrc&lt;&#x2F;h2&gt;
&lt;p&gt;Now, let&#x27;s create a &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; and we&#x27;ll start by implementing the &lt;code&gt;constituion_bonus&lt;&#x2F;code&gt;, the Constitution bonus for a HalfOrc is &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;impl Constitution for HalfOrc {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	1
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the same as our Dwarf &lt;code&gt;impl&lt;&#x2F;code&gt; but instead returning a 2, it returns 1&lt;&#x2F;p&gt;
&lt;p&gt;Now we create the HalfOrc with:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_half_orc = HalfOrc {
	name: String::from(&amp;quot;OscarOrc&amp;quot;)
}

my_half_orc.constitution_bonus();&amp;#x2F;&amp;#x2F; Returns 1
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Pretty straightforward right? We bind &lt;code&gt;my_half_orc&lt;&#x2F;code&gt; to our &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; and name him &lt;code&gt;OscarOrc&lt;&#x2F;code&gt; and when we call the &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; and we know that it will return &lt;code&gt;1&lt;&#x2F;code&gt;, as we have defined in the &lt;code&gt;impl&lt;&#x2F;code&gt; block above.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;humans-and-elves&quot;&gt;Humans and Elves&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s define our last 2 races of Humans and Elves, but let&#x27;s say that both of these races have a constitution bonus of &lt;code&gt;0&lt;&#x2F;code&gt;.
Our first instinct might be to do the same as we did above and do this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; we can implement like this but this is repetitive
impl Constitution for Elf {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	0
	}
}

impl Constitution for Human {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	0
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is clearly repetitive and not ideal. Another thing to note is that most races actually have a constitution bonus of &lt;code&gt;0&lt;&#x2F;code&gt;
So how do we deal with this?&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s add a default value the &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait we first created.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; making `0` the default
pub triat Constitution {
	fn constitution_bonus(&amp;amp;self) -&amp;gt; u8 {
	0
	}
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this way unless we have a struct that implements this trait and overrides this default value it will always return &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We still have to implement the traits on the struct, but we don&#x27;t have to define how the constitution bonus works since it&#x27;s default value is &lt;code&gt;0&lt;&#x2F;code&gt; and Humans and Elves&#x27; &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; matches the default value.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
impl Constitution for Elf{
}

impl Constitution for Human{
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;creating-our-elf-and-human&quot;&gt;Creating our Elf and Human&lt;&#x2F;h2&gt;
&lt;p&gt;We know the drill here, we define both of these in the same way that we did for our &lt;code&gt;my_dwarf&lt;&#x2F;code&gt; and &lt;code&gt;my_half_orc&lt;&#x2F;code&gt;, the only difference is that since we have defined a default value on the &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait we have access to it automatically unless we further define the &lt;code&gt;consitution_bonus&lt;&#x2F;code&gt; like we did previously.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_elf = Elf{
	name:String::from(&amp;quot;ElleElf&amp;quot;)
};

my_elf.constituion_bonus(); &amp;#x2F;&amp;#x2F; Retuns 0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;let my_human = Human {
	name:String::from(&amp;quot;HarryHuman&amp;quot;)
};

my_human.constitution_bonus(); &amp;#x2F;&amp;#x2F; Returns 0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There it is, we have created 4 D&amp;amp;D characters and defined their &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt; in a couple of different ways using Triats.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s summarize what we did here, in a quick step-by-step so we can see how easy it actually is to use traits in this way.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Create a &lt;code&gt;struct&lt;&#x2F;code&gt; for each of the races.&lt;&#x2F;li&gt;
&lt;li&gt;Create a character with a variable &lt;code&gt;my_&amp;lt;race&amp;gt;&lt;&#x2F;code&gt;  and defined it&#x27;s type and name.&lt;&#x2F;li&gt;
&lt;li&gt;Create a &lt;code&gt;trait&lt;&#x2F;code&gt;, in our case &lt;code&gt;constitution_bonus&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Implement the &lt;code&gt;triat&lt;&#x2F;code&gt; on the &lt;code&gt;Dwarf&lt;&#x2F;code&gt; struct
&lt;ul&gt;
&lt;li&gt;define constitution bonus as &lt;code&gt;2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;calling &lt;code&gt;constitution_bonus()&lt;&#x2F;code&gt; on our character it returns &lt;code&gt;2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;if we create more &lt;code&gt;Dwarf&lt;&#x2F;code&gt; characters they&#x27;d all have a constitution bonus of &lt;code&gt;2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Implement the &lt;code&gt;trait&lt;&#x2F;code&gt; on the &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; struct
&lt;ul&gt;
&lt;li&gt;define constitution bonus as &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;calling &lt;code&gt;constitution_bonus()&lt;&#x2F;code&gt; on our character returns &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;if we create more &lt;code&gt;HalfOrc&lt;&#x2F;code&gt; characters they&#x27;d all have a constitution bonus of &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Add a default value to our &lt;code&gt;Constitution&lt;&#x2F;code&gt; trait&lt;&#x2F;li&gt;
&lt;li&gt;Implement the &lt;code&gt;trait&lt;&#x2F;code&gt; on &lt;code&gt;Elves&lt;&#x2F;code&gt; and &lt;code&gt;Humans&lt;&#x2F;code&gt;(with no additional definition)&lt;&#x2F;li&gt;
&lt;li&gt;Created our &lt;code&gt;Elves&lt;&#x2F;code&gt; and &lt;code&gt;Humans&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;calling &lt;code&gt;constitution_bonus()&lt;&#x2F;code&gt; on our elf and human characters returns &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;creating other races with no function definition in their implementation will always return &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Alright, as you can see there&#x27;s not a lot of tricky parts here, it&#x27;s all pretty straight forward, especially when laid out in this way where we can see how easy it is, in a few easy steps start using Traits in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Next we&#x27;ll dive into Traits 201, it will build on what we&#x27;ve learned here with Trait bounds. See you next time.&lt;&#x2F;p&gt;
&lt;p&gt;Update 2023-03-14:If you&#x27;re ready for &lt;a href=&quot;https:&#x2F;&#x2F;desmodrone.github.io&#x2F;posts&#x2F;traits-201&#x2F;&quot;&gt;Part 2&lt;&#x2F;a&gt;, it&#x27;s ready for you.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Rust Closures</title>
          <pubDate>Wed, 08 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/rust-closures/</link>
          <guid>https://desmodrone.github.io/posts/rust-closures/</guid>
          <description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;&#x2F;h2&gt;
&lt;p&gt;I&#x27;m new to Rust and programming in general, and while I&#x27;ve dabbled in different languages and technologies, I&#x27;ve never gone headfirst into any language to become proficient. I&#x27;m trying to change that now with Rust. Please forgive my inaccuracies or lack of understanding of more complex topics, but I&#x27;ll get there eventually. For now, I thought closures were an interesting topic, so I decided to write about this this topic first.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-are-closures&quot;&gt;What are closures?&lt;&#x2F;h2&gt;
&lt;p&gt;A closure can be thought of as a quick function that doesn&#x27;t need a name, or an anonymous function that can be saved in a variable or passed into other functions as arguments. A unique thing about closures is that they can capture their environment and this makes them a versatile tool that can be fun and efficient to use.&lt;&#x2F;p&gt;
&lt;p&gt;Closures are easy to identify because they use pipes &lt;code&gt;||&lt;&#x2F;code&gt; instead of the typical parentheses &lt;code&gt;()&lt;&#x2F;code&gt; that functions use. There are a few different ways you can use closures in Rust, but first, let&#x27;s look at how a closure is created.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;how-are-closures-created-in-rust&quot;&gt;How are closures created in Rust?&lt;&#x2F;h2&gt;
&lt;p&gt;Before we look at closures let us take a quick look at the syntax of how a function is defined in Rust. Below is a simple function definition that adds 1 to its parameter.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; function definition syntax
fn plus_one_v1 (x: u32) -&amp;gt; u32 { x + 1 }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you&#x27;re familiar with Rust&#x27;s functions this should be pretty easy to understand, so we won&#x27;t go through the details, if you&#x27;re not familiar with creating a function in Rust here&#x27;s a &lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;2V0JaMVjzws?t=465&quot;&gt;Let&#x27;s Get Rusty&lt;&#x2F;a&gt; tutorial on functions that will bring you up to speed.  Now let&#x27;s look at how we&#x27;d create a closure using similar syntax to a function. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F;closure definition syntax
let plus_one_v2 = | x: u32| -&amp;gt; u32 { x + 1 };
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see the syntax is very similar to a function other than we use the &lt;code&gt;let&lt;&#x2F;code&gt;  keyword to bind the closure to &lt;code&gt;plus_one_v2&lt;&#x2F;code&gt; , and use the equal sign before the pipes &lt;code&gt;||&lt;&#x2F;code&gt;.  One thing to note is that a lot of this syntax is optional for closure definitions, the Rust compiler is usually able to infer the types in closures. Keep in mind that when the Rust compiler infers the type, it will take the first type we pass through as the type it uses. So you can&#x27;t change the type later in your code and expect it to work. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;simplifying-syntax&quot;&gt;Simplifying Syntax&lt;&#x2F;h2&gt;
&lt;p&gt;Since the Rust compiler can infer the types, to declare this closure in the most succinct manner you could do so like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; closure definition stripped down
let plus_one_v2 = |x| x + 1;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s go step by step and see what we removed.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; closure syntax defined
let plus_one_v2 = | x: u32| -&amp;gt; u32 { x + 1 };

&amp;#x2F;&amp;#x2F; removing the return type and curly braces
let plus_one_v2 = | x: u32| -&amp;gt; x + 1;

&amp;#x2F;&amp;#x2F; removing the u32 type in closure
let plus_one_v2 = |x| x + 1;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again because the rust compiler can infer the type we can make this line of code much cleaner.&lt;&#x2F;p&gt;
&lt;p&gt;Just like in functions where the parentheses &lt;code&gt;()&lt;&#x2F;code&gt;  can be empty, we can leave the &lt;code&gt;||&lt;&#x2F;code&gt; empty or add variables and types.  Let&#x27;s look at another example.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; empty `||`
fn main() {
	let simple_closure = || println!(&amp;quot;A simple closure&amp;quot;);
	simple_closure();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we define a closure to the variable &lt;code&gt;simple_closure&lt;&#x2F;code&gt; and this has nothing in between &lt;code&gt;||&lt;&#x2F;code&gt;.  If we run this code it prints: &lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;A simple closure.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;passing-in-parameters&quot;&gt;Passing in Parameters&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at what happens when we add something in between the pipes &lt;code&gt;||&lt;&#x2F;code&gt; similar to how we would to the parenthesis &lt;code&gt;()&lt;&#x2F;code&gt; of a function. We define &lt;code&gt;x&lt;&#x2F;code&gt; as and &lt;code&gt;i32&lt;&#x2F;code&gt; which means that when we call &lt;code&gt;simple_closure&lt;&#x2F;code&gt; we can pass in an &lt;code&gt;i32&lt;&#x2F;code&gt; into it.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; pipes with an i32
fn main() {
	let simple_closure = |x: i32| println!(&amp;quot;{}&amp;quot;, x);

	simple_closure(3);
	simple_closure(3+16);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;3
19
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So far so good, I hope. This behavior here is just like a function, we&#x27;re not doing anything too different. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;capturing-the-environment&quot;&gt;Capturing the Environment&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at what makes closures special, &amp;quot;capture their environment&amp;quot;, meaning they can take variables that are outside of the closure.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; Capturing the environment
fn main() {
	let first = 12
	let second = 3

	let capture_closure = || println!(&amp;quot;{}&amp;quot;, first + second);
	capture_closure();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;15
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So what is going on here? We didn&#x27;t put anything in between the &lt;code&gt;||&lt;&#x2F;code&gt; but closures can just &#x27;take&#x27; the variables &lt;code&gt;first&lt;&#x2F;code&gt; and &lt;code&gt;second&lt;&#x2F;code&gt; and add them because closures can capture their environment -- pretty cool huh?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-3-closure-traits-fn-fnmut-and-fnonce&quot;&gt;The 3 closure traits (Fn, FnMut,  and FnOnce)&lt;&#x2F;h2&gt;
&lt;p&gt;Now, let&#x27;s dive a little deeper and take a look at the &lt;code&gt;Fn&lt;&#x2F;code&gt;, &lt;code&gt;FnMut&lt;&#x2F;code&gt;, and &lt;code&gt;FnOnce&lt;&#x2F;code&gt; traits and how they work with closures. This happens behind the scenes when using closures with variables but in order to understand closures and be able to use them to their full potential we must understand what is happening with these 3 traits.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fn&lt;&#x2F;code&gt;: using this with an upper case &lt;code&gt;F&lt;&#x2F;code&gt; means we are not mutating the captured variables and they are read-only.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;FnMut&lt;&#x2F;code&gt;: allows us to change captured variables, creating a mutable borrow of these captured variables.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;FnOnce&lt;&#x2F;code&gt;: this lets us move ownership into the closure. In essence, consuming the variable. &lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Again, Rust infers these traits when using closures with variables, different than when they&#x27;re being used with functions where they have to be explicitly defined, but we&#x27;ll look at that later. &lt;&#x2F;p&gt;
&lt;h3 id=&quot;fn-trait&quot;&gt;&lt;code&gt;Fn&lt;&#x2F;code&gt; Trait&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s take a quick look at what each of these looks like in code.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; using `Fn` trait
fn main() {
	let str1 = &amp;quot;Hello&amp;quot;.to_string();
	let closure = |x| println!(&amp;quot;{} {}&amp;quot;, str1, x);
	closure(&amp;quot;rustaceans!&amp;quot;)

}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we capturing the variable and printing it with the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait because we are immutably borrowing that variable and printing it to screen. which prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Hello rustaceans!
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can tell we didn&#x27;t actually have to define the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait it was implied by how it the code is constructed. &lt;&#x2F;p&gt;
&lt;h3 id=&quot;fnmut-trait&quot;&gt;&lt;code&gt;FnMut&lt;&#x2F;code&gt; Trait&lt;&#x2F;h3&gt;
&lt;p&gt;Here in the 2nd block of code with &lt;code&gt;clsr2&lt;&#x2F;code&gt; we are declaring a closure that actually mutates the &lt;code&gt;str1&lt;&#x2F;code&gt; variable, so here we are using the &lt;code&gt;FnMut&lt;&#x2F;code&gt; trait because we are mutating our variable. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {
	&amp;#x2F;&amp;#x2F; using Fn trait
	let mut str1 = &amp;quot;Hello&amp;quot;.to_string();
	let closure = |x| println!(&amp;quot;{} {}&amp;quot;, str1, x);
	closure(&amp;quot;rustaceans!&amp;quot;);

	&amp;#x2F;&amp;#x2F; using FnMut trait
	let mut closure2 = |x| str1.push_str(x);
	closure2(&amp;quot; welcome back, rustaceans!&amp;quot;); 
	println!(&amp;quot;{}&amp;quot;, str1);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This now prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Hello rustaceans!
Hello welcome back, rustaceans!
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;fnonce-trait&quot;&gt;&lt;code&gt;FnOnce&lt;&#x2F;code&gt; Trait&lt;&#x2F;h3&gt;
&lt;p&gt;In this last example, we take a look at the &lt;code&gt;FnOnce&lt;&#x2F;code&gt; trait&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn main() {
	&amp;#x2F;&amp;#x2F; using Fn trait
	let mut str1 = &amp;quot;Hello&amp;quot;.to_string();
	let closure = |x| println!(&amp;quot;{} {}&amp;quot;, str1, x);
	closure(&amp;quot;rustaceans!&amp;quot;);

	&amp;#x2F;&amp;#x2F; using FnMut trait
	let mut closure2 = |x| str1.push_str(x);
	closure2(&amp;quot; welcome back, rustaceans!&amp;quot;);
	println!(&amp;quot;{}&amp;quot;, str1);

	&amp;#x2F;&amp;#x2F; using FnOnce trait
	let closure3 = || drop(str1);
    println!(&amp;quot;before dropping str1&amp;quot;);
    closure3();
    println!(&amp;quot;str1 has been dropped&amp;quot;);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see the &lt;code&gt;FnOnce&lt;&#x2F;code&gt; trait in action here when using  &lt;code&gt;drop(str1)&lt;&#x2F;code&gt;.  However, if we try to call &lt;code&gt;str1&lt;&#x2F;code&gt; again, our code would not compile and give us an error message, so we don&#x27;t call it in this instance.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-move-keyword&quot;&gt;&lt;strong&gt;The &lt;code&gt;move&lt;&#x2F;code&gt; keyword&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;move&lt;&#x2F;code&gt; keyword comes in handy when you want to force a closure to take ownership of the values it captures, even though the closure doesn&#x27;t need it. &lt;code&gt;move&lt;&#x2F;code&gt; can specifically come into action when passing a closure into a new thread and thus moving the data so it&#x27;s owned by this new thread. Threads are something we can cover at a different time, but let&#x27;s look at this example on how to use the &lt;code&gt;move&lt;&#x2F;code&gt; keyword with closures:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!(&amp;quot;Before defining closure: {:?}&amp;quot;, list);

    thread::spawn(move || println!(&amp;quot;From thread: {:?}&amp;quot;, list))
        .join()
        .unwrap();
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A new thread is spawned and we force the closure to take ownership of the &lt;code&gt;list&lt;&#x2F;code&gt; by using the &lt;code&gt;move&lt;&#x2F;code&gt;  keyword.  In this way even if we implement the &lt;code&gt;Fn&lt;&#x2F;code&gt; or &lt;code&gt;FnMut&lt;&#x2F;code&gt; traits, ownership is moved to the closure allowing more flexibility in the closure. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;passing-closures-or-other-functions-as-inputs-to-functions&quot;&gt;&lt;strong&gt;Passing closures(or other functions) as inputs to functions&lt;&#x2F;strong&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now let&#x27;s look at a couple of different ways we can use closures as inputs to functions, building on what we saw above with the &lt;code&gt;Fn&lt;&#x2F;code&gt;, &lt;code&gt;FnMut&lt;&#x2F;code&gt;. &lt;&#x2F;p&gt;
&lt;p&gt;As mentioned outside of a function, a closure can decide by itself which trait to use, but inside of a function, you have to be explicit and define one of these traits. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&amp;#x2F;&amp;#x2F; using `Fn`
fn add_num&amp;lt;F&amp;gt;(func: F)
	where F: Fn(i32){
		func(7)
	}

fn main(){
	let num = 6;
	add_num(|x|println!(&amp;quot;{}&amp;quot;, num + x));
	
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This prints:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;13
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we are defining the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait to add two numbers and since we are not changing the number in the &lt;code&gt;add_num&lt;&#x2F;code&gt;  function and simply passing it through we can define the &lt;code&gt;Fn&lt;&#x2F;code&gt; trait without major fuss. &lt;&#x2F;p&gt;
&lt;p&gt;However, if we try to make our &lt;code&gt;num&lt;&#x2F;code&gt; mutable by incrementing it, we might run into some problems. Let&#x27;s see what happens.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn add_num&amp;lt;F&amp;gt;(func: F)
	where F: Fn(i32){
		func(7)
	}

fn main(){
	let mut num = 6; &amp;#x2F;&amp;#x2F; mutable to allow incrementation
	add_num(|x|{num +=x; println!(&amp;quot;{}&amp;quot;, num + x)}); 
	
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As expected we get an error message:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;error[E0594]: cannot assign to `num`, as it is a captured variable in a `Fn` closure
 --&amp;gt; src&amp;#x2F;main.rs:8:14
  |
1 | fn add_num&amp;lt;F&amp;gt;(func: F)
  |                     - change this to accept `FnMut` instead of `Fn`
...
8 |     add_num(|x|{num +=x; println!(&amp;quot;{}&amp;quot;, num + x)});
  |     ------- --- ^^^^^^^ cannot assign
  |     |       |
  |     |       in this closure
  |     expects `Fn` instead of `FnMut`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler actually tells us what we should be doing here (very nice), changing the &lt;code&gt;Fn&lt;&#x2F;code&gt; to &lt;code&gt;FnMut&lt;&#x2F;code&gt; .&lt;&#x2F;p&gt;
&lt;p&gt;If we update our code to in the &lt;code&gt;add_num&lt;&#x2F;code&gt; function to what is shown below, our problems will be solved:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn add_num&amp;lt;F&amp;gt;(mut func: F) &amp;#x2F;&amp;#x2F; add mut here
	where F: FnMut(i32){ &amp;#x2F;&amp;#x2F; change Fn to FnMut here
		func(7) 
	}

fn main(){
	let mut num = 6;
	add_num(|x|{num +=x; println!(&amp;quot;{}&amp;quot;, num + x)}); 	
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This now compiles and prints:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;20
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Phew, we covered a lot but there&#x27;s still more we can do with closures, like storing them in structs and using them in conjunction with iterators, but we&#x27;ll leave that for another time. For now, I hope I have been able to explain what a closure is, how to create a closure, and how to use its traits. This should help you get started with getting familiar with closures and understanding how to use them in your own code. &lt;&#x2F;p&gt;
&lt;p&gt;Please let me know if I got something wrong or was unclear on anything, I&#x27;m doing this to help me better learn these concepts, so any feedback is appreciated. &lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Hello World</title>
          <pubDate>Tue, 07 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://desmodrone.github.io/posts/hello-world/</link>
          <guid>https://desmodrone.github.io/posts/hello-world/</guid>
          <description>&lt;p&gt;Yes, the obligatory Hello World post...and code.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;fn main(){
    println!(&amp;quot;hello world!&amp;quot;)
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
      </item>
    </channel>
</rss>
