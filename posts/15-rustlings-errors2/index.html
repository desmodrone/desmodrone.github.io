<!DOCTYPE html>
<html lang="en-us">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <meta itemprop="name" content="desmo" />
  <meta itemprop="description" content="Random Ideas" />

  <link rel="apple-touch-icon" sizes="180x180" href="https://desmodrone.github.io/apple-touch-icon.png"/>
  <link rel="icon" type="image/png" sizes="32x32" href="https://desmodrone.github.io/favicon-32x32.png" />
  <link
    rel="icon"
    type="image/png"
    sizes="16x16"
    href="https://desmodrone.github.io/favicon-16x16.png"
  />
  <link
    rel="shortcut icon"
    href="https://desmodrone.github.io/favicon.ico"
  />
  <link rel="stylesheet" href="https://desmodrone.github.io/style.css"/>
  
  <title>15 Rustlings Errors Part 2 Solution</title>
  

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://desmodrone.github.io/rss.xml">
  

  <body id="page">

	
<header id="site-header" class="animated slideInUp faster">
  <div class="hdr-wrapper section-inner">
    <div class="hdr-left">
      <div class="site-branding">
        <a href="https:&#x2F;&#x2F;desmodrone.github.io">desmo</a>
      </div>
      <nav class="site-nav hide-in-mobile">
            
        
        <a href="https://desmodrone.github.io/posts">posts</a>
        
        <a href="https://desmodrone.github.io/about">about</a>
        
        <a href="https://desmodrone.github.io/work">work</a>
        
      </nav>
    </div>
    <div class="hdr-right hdr-icons">
      <span class="hdr-social hide-in-mobile">
        

<a href="https:&#x2F;&#x2F;twitter.com&#x2F;desmo_io" target="_blank" rel="noopener me"
   title="twitter">
  
  <svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg>
  
</a>

<a href="https:&#x2F;&#x2F;github.com&#x2F;desmodrone" target="_blank" rel="noopener me"
   title="github">
  
  <svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg>
  
</a>

<a href="mailto:erick@apexwins.com" target="_blank" rel="noopener me"
   title="email">
  
  <svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
  
</a>


      </span>
      <button id="menu-btn" class="hdr-btn" title="Menu">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
          class="feather feather-menu"
        >
          <line x1="3" y1="12" x2="21" y2="12"></line>
          <line x1="3" y1="6" x2="21" y2="6"></line>
          <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
      </button>
    </div>
  </div>
</header>
<div id="mobile-menu" class="animated fast">
  <ul>
    
    <li><a href="https://desmodrone.github.io/posts">posts</a></li>
    
    <li><a href="https://desmodrone.github.io/about">about</a></li>
    
    <li><a href="https://desmodrone.github.io/work">work</a></li>
    
  </ul>
</div>

	
	

		
<main class="site-main section-inner animated fadeIn faster">
  <article class="thin">
	<header class="post-header">
	  <div class="post-meta">
		
		<span>Aug 11, 2023</span>
		<small> - 
<span class="reading-time" title="Estimated read time">
  
  11 min read
  
</span>
</small>
		
            
	  </div>
	  <h1>15 Rustlings Errors Part 2 Solution</h1>
	</header>

	<div class="content">
        
	  <h1 id="error-handling-part-2">Error Handling Part 2</h1>
<p>We're back with the 2nd part of our Error handling post we'll cover exercises 3-6. If you haven't read <a href="https://desmodrone.github.io/posts/15-rustlings-errors1/">Error Handling Part 1</a> it's a good idea to go through that first before moving on to these.</p>
<h3 id="this-is-from-the-rustlings-readme">This is from the Rustlings README:</h3>
<p>Most errors aren’t serious enough to require the program to stop entirely.
Sometimes, when a function fails, it’s for a reason that you can easily interpret and respond to.
For example, if you try to open a file and that operation fails because the file doesn’t exist, you might want to create the file instead of terminating the process.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">Error Handling</a></li>
<li><a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">Generics</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/error/result.html">Result</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/boxing_errors.html">Boxing errors</a></li>
</ul>
<h2 id="errors4-rs">Errors4.rs</h2>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">&#x2F;&#x2F; errors4.rs
&#x2F;&#x2F; Execute `rustlings hint errors4` or use the `hint` watch subcommand for a hint.

&#x2F;&#x2F; I AM NOT DONE

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {
        &#x2F;&#x2F; Hmm...? Why is this only returning an Ok value?
        Ok(PositiveNonzeroInteger(value as u64))
    }
}

#[test]
fn test_creation() {
    assert!(PositiveNonzeroInteger::new(10).is_ok());
    assert_eq!(
        Err(CreationError::Negative),
        PositiveNonzeroInteger::new(-10)
    );
    assert_eq!(Err(CreationError::Zero), PositiveNonzeroInteger::new(0));
}
</code></pre>
<p>We don't get much for hints and description, other than a comment that asks <code>Hmm...? Why is this only reguring an Ok value?</code></p>
<p>Let's look at our Rust compiler errors and see if we get any additional hints on how to fix this.</p>
<h2 id="errors4-rs-errors">Errors4.rs errors</h2>
<pre><code>⚠️  Testing of exercises&#x2F;error_handling&#x2F;errors4.rs failed! Please try again. Here&#x27;s the output:

running 1 test
test test_creation ... FAILED

successes:

successes:

failures:

---- test_creation stdout ----
thread &#x27;test_creation&#x27; panicked at &#x27;assertion failed: `(left == right)`
  left: `Err(Negative)`,
 right: `Ok(PositiveNonzeroInteger(18446744073709551606))`&#x27;, exercises&#x2F;error_handling&#x2F;errors4.rs:25:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    test_creation

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>It looks like our code is compiling but panicking and we see that our test is failing. If we look at the actual test we see that <code>(left == right)</code> failed we're getting different values. The test is expecting <code>Err(Negative)</code> but instead it's seeing <code>Ok(PositiveNonzero...))</code></p>
<h2 id="errors4-rs-solution">Errors4.rs solution</h2>
<p>It looks like we have to handle our error's, as nothing is being done to take care of them in our code right now. Maybe an <code>if</code> or maybe a <code>match</code> statement will do the trick. Let's try.
Let's use a match statement first. If we look at the code and tests, we know that there is 3 different scenarios we have to account for:</p>
<ol>
<li>Negative <code>Err</code></li>
<li>Zero <code>Err</code></li>
<li>Positive <code>Ok</code></li>
</ol>
<p>so let's us <code>match</code> to handle each one of these cases.</p>
<ol>
<li>For <code>Negative</code> we create a simple <code>if</code> statement, saying that if our <code>v(alue)</code> is less than <code>0</code> we return an error</li>
<li>For <code>Zero</code> we simply have to match an actual <code>0</code></li>
<li>For positive, it can be anything positive meaning we can use the <code>_</code> wildcard underscore character</li>
</ol>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">match value {
	v if v &lt; 0 =&gt; Err(CreationError::Negative), &#x2F;&#x2F; v represents `value` here
	0 =&gt; Err(CreationError::Zero),
	_ =&gt; Ok(PositiveNonzeroInteger(value as u64)),
}
</code></pre>
<p>It would look like this in the context of our code.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {
        match value {
            v if v &lt; 0 =&gt; Err(CreationError::Negative),
            0 =&gt; Err(CreationError::Zero),
            _ =&gt; Ok(PositiveNonzeroInteger(value as u64)),
        }
    }
}

#[test]
fn test_creation() {
    assert!(PositiveNonzeroInteger::new(10).is_ok());
    assert_eq!(
        Err(CreationError::Negative),
        PositiveNonzeroInteger::new(-10)
    );
    assert_eq!(Err(CreationError::Zero), PositiveNonzeroInteger::new(0));
}
</code></pre>
<p>And this compiles 🎉 but can we use <code>if</code> in this as well?</p>
<h3 id="what-about-if">What about <code>if</code></h3>
<p>Let's take a stab at it.
So, again we have to deal with the 3 different scenarios here</p>
<ol>
<li>if our value is less than zero</li>
<li>if our value is equal to zero</li>
<li>if it's positive</li>
</ol>
<p>So writing that looks  like this:</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust"> if value &lt; 0 {
            Err(CreationError::Negative)
        } else if value == 0 {
            Err(CreationError::Zero)
        } else {
            Ok(PositiveNonzeroInteger(value as u64))
        }
</code></pre>
<p>Here's what it looks like in context of the full problem:</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {
        if value &lt; 0 {
            Err(CreationError::Negative)
        } else if value == 0 {
            Err(CreationError::Zero)
        } else {
            Ok(PositiveNonzeroInteger(value as u64))
        }
    }
}

#[test]
fn test_creation() {
    assert!(PositiveNonzeroInteger::new(10).is_ok());
    assert_eq!(
        Err(CreationError::Negative),
        PositiveNonzeroInteger::new(-10)
    );
    assert_eq!(Err(CreationError::Zero), PositiveNonzeroInteger::new(0));
}
</code></pre>
<p>and with that we have solved <code>errors4.rs</code> we have our code compiling:</p>
<pre><code>✅ Successfully tested exercises&#x2F;error_handling&#x2F;errors4.rs!

🎉 🎉  The code is compiling, and the tests pass! 🎉 🎉
</code></pre>
<p>Alright. On to <code>Errors5.rs</code></p>
<h2 id="errors5-rs">Errors5.rs</h2>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">&#x2F;&#x2F; errors5.rs

&#x2F;&#x2F; This program uses an altered version of the code from errors4.

&#x2F;&#x2F; This exercise uses some concepts that we won&#x27;t get to until later in the course, like `Box` and the
&#x2F;&#x2F; `From` trait. It&#x27;s not important to understand them in detail right now, but you can read ahead if you like.
&#x2F;&#x2F; For now, think of the `Box&lt;dyn ???&gt;` type as an &quot;I want anything that does ???&quot; type, which, given
&#x2F;&#x2F; Rust&#x27;s usual standards for runtime safety, should strike you as somewhat lenient!

&#x2F;&#x2F; In short, this particular use case for boxes is for when you want to own a value and you care only that it is a
&#x2F;&#x2F; type which implements a particular trait. To do so, The Box is declared as of type Box&lt;dyn Trait&gt; where Trait is the trait
&#x2F;&#x2F; the compiler looks for on any value used in that context. For this exercise, that context is the potential errors
&#x2F;&#x2F; which can be returned in a Result.

&#x2F;&#x2F; What can we use to describe both errors? In other words, is there a trait which both errors implement?

&#x2F;&#x2F; Execute `rustlings hint errors5` or use the `hint` watch subcommand for a hint.

&#x2F;&#x2F; I AM NOT DONE

use std::error;
use std::fmt;
use std::num::ParseIntError;

&#x2F;&#x2F; TODO: update the return type of `main()` to make this compile.
fn main() -&gt; Result&lt;(), Box&lt;dyn ???&gt;&gt; {
    let pretend_user_input = &quot;42&quot;;
    let x: i64 = pretend_user_input.parse()?;
    println!(&quot;output={:?}&quot;, PositiveNonzeroInteger::new(x)?);
    Ok(())
}

&#x2F;&#x2F; Don&#x27;t change anything below this line.

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {
        match value {
            x if x &lt; 0 =&gt; Err(CreationError::Negative),
            x if x == 0 =&gt; Err(CreationError::Zero),
            x =&gt; Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

&#x2F;&#x2F; This is required so that `CreationError` can implement `error::Error`.
impl fmt::Display for CreationError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let description = match *self {
            CreationError::Negative =&gt; &quot;number is negative&quot;,
            CreationError::Zero =&gt; &quot;number is zero&quot;,
        };
        f.write_str(description)
    }
}

impl error::Error for CreationError {}
</code></pre>
<p>This is an interesting one as it has a lot of comments above the code but it mainly provides hints about what <code>Box</code> can do. Our task is to determine the correct return type in the <code>Rusult&lt;(), Box&lt;dyn ???&gt;&gt;</code> part of the code. The easy thought is that it has to return an <code>Error</code> but is it that simple? Let's try, but first let's take a look at the errors.</p>
<h2 id="errors5-rs-errors">Errors5.rs errors</h2>
<pre><code>⚠️  Compiling of exercises&#x2F;error_handling&#x2F;errors5.rs failed! Please try again. Here&#x27;s the output:
error: expected identifier, found `&gt;&gt;`
  --&gt; exercises&#x2F;error_handling&#x2F;errors5.rs:26:36
   |
26 | fn main() -&gt; Result&lt;(), Box&lt;dyn ???&gt;&gt; {
   |                                    ^^ expected identifier

error: aborting due to previous error
</code></pre>
<p>Nothing to specific here but we see where we are missing our code and it's expecting an identifier.</p>
<h2 id="errors5-rs-solution">Errors5.rs solution</h2>
<p>So let's try simply entering <code>Error</code> because that's what we should be expecting to see correct?</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">&#x2F;&#x2F; TODO: update the return type of `main()` to make this compile.
fn main() -&gt; Result&lt;(), Box&lt;dyn ???&gt;&gt; {
    let pretend_user_input = &quot;42&quot;;
    let x: i64 = pretend_user_input.parse()?;
    println!(&quot;output={:?}&quot;, PositiveNonzeroInteger::new(x)?);
    Ok(())
}
</code></pre>
<p>Well, we still get some errors but we have some help.</p>
<pre><code>⚠️  Compiling of exercises&#x2F;error_handling&#x2F;errors5.rs failed! Please try again. Here&#x27;s the output:
error[E0405]: cannot find trait `Error` in this scope
  --&gt; exercises&#x2F;error_handling&#x2F;errors5.rs:26:33
   |
26 | fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
   |                                 ^^^^^ not found in this scope
   |
help: consider importing one of these items
   |
21 + use core::error::Error;
   |
21 + use crate::error::Error;
   |
21 + use std::error::Error;
</code></pre>
<p>So the compiler is telling us that that <code>Error</code> is not found in scope and gives us a bunch of different options to use in our <code>Box&lt;dyn &gt;</code>. But before we implement one of these let's continue looking at our code. I had missed this comment earlier:<code>// This is required so that `CreationError` can implement `error::Error`</code>. It looks like we might have a hint here too. This comment is telling us that this function is being created to allow us to use <code>error::Error</code> for <code>CreationError</code> which means that we could use <code>error::Error</code> as our error handler in the return type right? Let's try.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">&#x2F;&#x2F; TODO: update the return type of `main()` to make this compile.
fn main() -&gt; Result&lt;(), Box&lt;dyn error::Error&gt;&gt; {
    let pretend_user_input = &quot;42&quot;;
    let x: i64 = pretend_user_input.parse()?;
    println!(&quot;output={:?}&quot;, PositiveNonzeroInteger::new(x)?);
    Ok(())
}
</code></pre>
<p>It compiles! This is our output:</p>
<pre><code>✅ Successfully ran exercises&#x2F;error_handling&#x2F;errors5.rs!

🎉 🎉  The code is compiling! 🎉 🎉

Output:
====================
output=PositiveNonzeroInteger(42)

====================
</code></pre>
<h2 id="errors6-rs">Errors6.rs</h2>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">&#x2F;&#x2F; errors6.rs

&#x2F;&#x2F; Using catch-all error types like `Box&lt;dyn error::Error&gt;` isn&#x27;t recommended
&#x2F;&#x2F; for library code, where callers might want to make decisions based on the
&#x2F;&#x2F; error content, instead of printing it out or propagating it further. Here,
&#x2F;&#x2F; we define a custom error type to make it possible for callers to decide
&#x2F;&#x2F; what to do next when our function returns an error.

&#x2F;&#x2F; Execute `rustlings hint errors6` or use the `hint` watch subcommand for a hint.

&#x2F;&#x2F; I AM NOT DONE

use std::num::ParseIntError;

&#x2F;&#x2F; This is a custom error type that we will be using in `parse_pos_nonzero()`.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl ParsePosNonzeroError {
    fn from_creation(err: CreationError) -&gt; ParsePosNonzeroError {
        ParsePosNonzeroError::Creation(err)
    }
    &#x2F;&#x2F; TODO: add another error conversion function here.
    &#x2F;&#x2F; fn from_parseint...

}

fn parse_pos_nonzero(s: &amp;str) -&gt; Result&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; {
    &#x2F;&#x2F; TODO: change this to return an appropriate error instead of panicking
    &#x2F;&#x2F; when `parse()` returns an error.
    let x: i64 = s.parse().unwrap();
    PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)
}

&#x2F;&#x2F; Don&#x27;t change anything below this line.

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {
        match value {
            x if x &lt; 0 =&gt; Err(CreationError::Negative),
            x if x == 0 =&gt; Err(CreationError::Zero),
            x =&gt; Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_parse_error() {
        &#x2F;&#x2F; We can&#x27;t construct a ParseIntError, so we have to pattern match.
        assert!(matches!(
            parse_pos_nonzero(&quot;not a number&quot;),
            Err(ParsePosNonzeroError::ParseInt(_))
        ));
    }

    #[test]
    fn test_negative() {
        assert_eq!(
            parse_pos_nonzero(&quot;-555&quot;),
            Err(ParsePosNonzeroError::Creation(CreationError::Negative))
        );
    }

    #[test]
    fn test_zero() {
        assert_eq!(
            parse_pos_nonzero(&quot;0&quot;),
            Err(ParsePosNonzeroError::Creation(CreationError::Zero))
        );
    }

    #[test]
    fn test_positive() {
        let x = PositiveNonzeroInteger::new(42);
        assert!(x.is_ok());
        assert_eq!(parse_pos_nonzero(&quot;42&quot;), Ok(x.unwrap()));
    }
}
</code></pre>
<p>In this exercise we are defining a custom error type and we have 3 clear instructions.</p>
<ol>
<li>We have to add an error conversion function</li>
<li>Change the <code>parse_pos_nonzero</code> function to allow proper error handling</li>
<li>Don't change anything below code line 38 or after the <code>parse_pos_nonzero</code> function ends.</li>
</ol>
<h2 id="errors6-rs-errors">Errors6.rs errors</h2>
<pre><code>⚠️  Testing of exercises&#x2F;error_handling&#x2F;errors6.rs failed! Please try again. Here&#x27;s the output:

running 4 tests
test test::test_negative ... ok
test test::test_positive ... ok
test test::test_zero ... ok
test test::test_parse_error ... FAILED

successes:

successes:
    test::test_negative
    test::test_positive
    test::test_zero

failures:

---- test::test_parse_error stdout ----
thread &#x27;test::test_parse_error&#x27; panicked at &#x27;called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }&#x27;, exercises&#x2F;error_handling&#x2F;errors6.rs:33:28
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    test::test_parse_error

test result: FAILED. 3 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Our errors show us we have 3 passing test but the <code>test_parse_error</code> test is failing.</p>
<h2 id="errors6-rs-solution">Errors6.rs solution</h2>
<p>Let's first start by creating that 2nd function.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">
use std::num::ParseIntError;

&#x2F;&#x2F; This is a custom error type that we will be using in `parse_pos_nonzero()`.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl ParsePosNonzeroError {
    fn from_creation(err: CreationError) -&gt; ParsePosNonzeroError {
        ParsePosNonzeroError::Creation(err)
    }
    fn from_parseint(err: ParseIntError) -&gt; ParsePosNonzeroError {
        ParsePosNonzeroError::ParseInt(err)
    }

}
</code></pre>
<p>Here i'm creating a new function using the same structure as the <code>from_creation</code> and this should help us finish our custom error types. When we save though, nothing changes, we still get 3 passing tests, and one fail.</p>
<p>So let's move on to the next <code>todo</code> on our list.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">fn parse_pos_nonzero(s: &amp;str) -&gt; Result&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; {
    &#x2F;&#x2F; TODO: change this to return an appropriate error instead of panicking
    &#x2F;&#x2F; when `parse()` returns an error.
    let x: i64 = s.parse().unwrap();
    PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)
}
</code></pre>
<h3 id="parse-error-approach">Parse Error Approach</h3>
<p>So we know that we have to remove the <code>.unwrap()</code> method because this is what makes the code panic, and if we look at the hints we get this:</p>
<blockquote>
<p>Below the line that TODO asks you to change, there is an example of using the <code>map_err()</code> method on a <code>Result</code> to transform one type of error into another. Try using something similar on the <code>Result</code> from <code>parse()</code>. You might use the <code>?</code> operator to return early from the function, or you might use a <code>match</code> expression, or maybe there's another way! You can create another function inside <code>impl ParsePosNonzeroError</code> to use with <code>map_err()</code>. Read more about <code>map_err()</code> in the <code>std::result</code> documentation: https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err</p>
</blockquote>
<p>So let's try this approach.</p>
<ol>
<li>
<p>We attempt to parse <code>s</code> into an <code>i64</code>. If this fails, we convert the error and return early because of the <code>?</code> operator.</p>
</li>
<li>
<p>If parsing succeeds, we then attempt to create a <code>PositiveNonzeroInteger</code>. If this fails, we convert the error using <code>map_err()</code>, but since there's no <code>?</code> operator here, we don't return early (because this is the last line of the function and the resulting <code>Result</code> is directly returned).</p>
</li>
</ol>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">fn parse_pos_nonzero(s: &amp;str) -&gt; Result&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; {
    &#x2F;&#x2F; Try parsing the string into an i64.
    let x = s.parse::&lt;i64&gt;().map_err(ParsePosNonzeroError::from_parseint)?;

    &#x2F;&#x2F; Create a PositiveNonzeroInteger, and if this fails, transform the error.
    PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)
}
</code></pre>
<h3 id="using-match">Using Match</h3>
<p>We can also use matching to get our result, using something called a <code>turbofish</code> (unofficially) the full scoop on this this should be later, but for now let's say this <code>::&lt;&gt;</code> or <code>turbofish</code> (see it kinda looks like a fish) is used to help the compiler understand the exact type you intend when type inference might be insufficient or ambiguous.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">fn parse_pos_nonzero(s: &amp;str) -&gt; Result&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; {
    &#x2F;&#x2F; TODO: change this to return an appropriate error instead of panicking
    &#x2F;&#x2F; when `parse()` returns an error.
    let x = s.parse::&lt;i64&gt;();

    match x {
        Ok(val) =&gt; PositiveNonzeroInteger::new(val).map_err(ParsePosNonzeroError::from_creation),
        Err(e) =&gt; Err(ParsePosNonzeroError::from_parseint(e)),
    }
}
</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>In this second part of our exploration into Rust error handling, we delved into exercises 3 to 6 to understand and tackle various aspects of working with errors in Rust programming. We built upon the concepts introduced in the first part and extended our knowledge to handle more intricate scenarios.</p>
<p>We began with <strong>Errors4.rs</strong>, where we encountered a situation involving custom error types. By using the <code>match</code> expression, we effectively handled different error cases and returned appropriate results based on the input. This exercise illuminated the power of pattern matching in Rust's error handling mechanism.</p>
<p>Moving on to <strong>Errors5.rs</strong>, we tackled a case involving the <code>Box&lt;dyn Error&gt;</code> type. By correctly choosing the appropriate return type for the <code>main()</code> function, we demonstrated how Rust's error system allows for flexibility in dealing with various error types in a generic manner. This exercise reinforced the importance of choosing the right error type depending on the context of your program.</p>
<p>Finally, in <strong>Errors6.rs</strong>, we showcased our ability to create custom error types and handle complex error propagation scenarios. We introduced a custom error type <code>ParsePosNonzeroError</code> and skillfully converted different error types into this unified form using methods like <code>map_err()</code>. This exercise highlighted Rust's expressive error handling capabilities and provided insight into creating ergonomic APIs that clearly communicate errors to the caller.</p>
<p>Throughout this journey, we harnessed Rust's powerful error handling constructs, including <code>Result</code>, <code>match</code> expressions, <code>?</code> operator, <code>map_err()</code>, and custom error types. These exercises reinforced the idea that errors in Rust are not just exceptions but a fundamental part of the language that guides developers in creating robust and reliable software.</p>
<p>By mastering error handling in Rust, we equip ourselves with the tools to write code that elegantly handles failures and provides meaningful feedback to users. As we continue our Rust learning journey, these skills will prove invaluable in building resilient and dependable applications.</p>
<p>Continue to explore the rich Rust ecosystem, experiment with error handling in different scenarios, and always remember that Rust's error handling philosophy encourages us to embrace errors, not fear them.</p>

	</div>
	<hr class="post-end">
	<footer class="post-info">
    
	  <p>
		<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>
		
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/rust/">rust</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/options/">options</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/match/">match</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/while-let/">while let</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/rustlings/">rustlings</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/errors/">errors</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/result/">result</a></span>
		
		
    </p>
    
    <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>2825 Words</p>
    
    <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2023-08-11</p>
    
	</footer>
  </article>
    
  
  <div class="post-nav thin">
	
	
  </div>

  
</main>

	  </div>
	  
	  



<footer id="site-footer" class="section-inner thin animated fadeIn faster">
  <p>&copy; 2024 <a href="https:&#x2F;&#x2F;desmodrone.github.io">erick</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
  <p>Made with <a href="https://www.getzola.org" target="_blank" rel="noopener">Zola</a> &#183; Theme <a href="https://github.com/VersBinarii/hermit_zola" target="_blank" rel="noopener">Hermit_Zola</a>
	
	&#183; <a href="https://desmodrone.github.io/rss.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
	
  </p>
</footer>




	</div>
	
	<script src="https://desmodrone.github.io/js/main.js"></script>

	<!-- Math rendering -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body, { delimiters: [ {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}, {left: '\\[', right: '\\]', display: true}, {left: '\\(', right: '\\)', display: false}]});"></script>

    
		<link href="https://unpkg.com/highlightjs-badge/highlightjs/styles/monokai.css" rel="stylesheet">
		<!-- https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.1/build/styles/  for min version -->
		<script src="https://unpkg.com/highlightjs-badge/highlightjs/highlight.pack.js"></script>
		<script src="https://unpkg.com/highlightjs-badge/highlightjs-badge.min.js"></script>
		<script>
			var pres = document.querySelectorAll("pre>code");
			for (var i = 0; i < pres.length; i++) {
				hljs.highlightBlock(pres[i]);
			}
		</script>
		
			<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js"></script>
			<script>
				var options = {
					copyIconClass: "gg-clipboard",
					checkIconClass: "gg-check"
				};
				window.highlightJsBadge(options);
			</script>
		

	

	
	<script src="https://desmodrone.github.io/js/main.js"></script>

    
    

	
    <!-- Global Site Tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9MNTYXYNHK"></script>
    <script>
     window.dataLayer = window.dataLayer || [];
     function gtag(){dataLayer.push(arguments);}
     gtag('js', new Date());
     gtag('config', 'G-9MNTYXYNHK');
    </script>
    
  </body>
</html>
