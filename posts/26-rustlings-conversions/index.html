<!DOCTYPE html>
<html lang="en-us">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <meta itemprop="name" content="desmo" />
  <meta itemprop="description" content="Random Ideas" />

  <link rel="apple-touch-icon" sizes="180x180" href="https://desmodrone.github.io/apple-touch-icon.png"/>
  <link rel="icon" type="image/png" sizes="32x32" href="https://desmodrone.github.io/favicon-32x32.png" />
  <link
    rel="icon"
    type="image/png"
    sizes="16x16"
    href="https://desmodrone.github.io/favicon-16x16.png"
  />
  <link
    rel="shortcut icon"
    href="https://desmodrone.github.io/favicon.ico"
  />
  <link rel="stylesheet" href="https://desmodrone.github.io/style.css"/>
  
  <title>26 Rustlings Conversions</title>
  

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://desmodrone.github.io/rss.xml">
  

  <body id="page">

	
<header id="site-header" class="animated slideInUp faster">
  <div class="hdr-wrapper section-inner">
    <div class="hdr-left">
      <div class="site-branding">
        <a href="https:&#x2F;&#x2F;desmodrone.github.io">desmo</a>
      </div>
      <nav class="site-nav hide-in-mobile">
            
        
        <a href="https://desmodrone.github.io/posts">posts</a>
        
        <a href="https://desmodrone.github.io/about">about</a>
        
        <a href="https://desmodrone.github.io/work">work</a>
        
      </nav>
    </div>
    <div class="hdr-right hdr-icons">
      <span class="hdr-social hide-in-mobile">
        

<a href="https:&#x2F;&#x2F;twitter.com&#x2F;desmo_io" target="_blank" rel="noopener me"
   title="twitter">
  
  <svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg>
  
</a>

<a href="https:&#x2F;&#x2F;github.com&#x2F;desmodrone" target="_blank" rel="noopener me"
   title="github">
  
  <svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg>
  
</a>

<a href="mailto:erick@apexwins.com" target="_blank" rel="noopener me"
   title="email">
  
  <svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
  
</a>


      </span>
      <button id="menu-btn" class="hdr-btn" title="Menu">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
          class="feather feather-menu"
        >
          <line x1="3" y1="12" x2="21" y2="12"></line>
          <line x1="3" y1="6" x2="21" y2="6"></line>
          <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
      </button>
    </div>
  </div>
</header>
<div id="mobile-menu" class="animated fast">
  <ul>
    
    <li><a href="https://desmodrone.github.io/posts">posts</a></li>
    
    <li><a href="https://desmodrone.github.io/about">about</a></li>
    
    <li><a href="https://desmodrone.github.io/work">work</a></li>
    
  </ul>
</div>

	
	

		
<main class="site-main section-inner animated fadeIn faster">
  <article class="thin">
	<header class="post-header">
	  <div class="post-meta">
		
		<span>Dec 13, 2023</span>
		<small> - 
<span class="reading-time" title="Estimated read time">
  
  11 min read
  
</span>
</small>
		
            
	  </div>
	  <h1>26 Rustlings Conversions</h1>
	</header>

	<div class="content">
        
	  <h1 id="type-conversions">Type conversions</h1>
<p>Rust offers a multitude of ways to convert a value of a given type into another type.</p>
<p>The simplest form of type conversion is a type cast expression. It is denoted with the binary operator <code>as</code>. For instance, <code>println!(&quot;{}&quot;, 1 + 1.0);</code> would not compile, since <code>1</code> is an integer while <code>1.0</code> is a float. However, <code>println!(&quot;{}&quot;, 1 as f32 + 1.0)</code> should compile. The exercise <a href="https://desmodrone.github.io/posts/26-rustlings-conversions/using_as.rs"><code>using_as</code></a> tries to cover this.</p>
<p>Rust also offers traits that facilitate type conversions upon implementation. These traits can be found under the <a href="https://doc.rust-lang.org/std/convert/index.html"><code>convert</code></a> module.
The traits are the following:</p>
<ul>
<li><code>From</code> and <code>Into</code> covered in <a href="https://desmodrone.github.io/posts/26-rustlings-conversions/from_into.rs"><code>from_into</code></a></li>
<li><code>TryFrom</code> and <code>TryInto</code> covered in <a href="https://desmodrone.github.io/posts/26-rustlings-conversions/try_from_into.rs"><code>try_from_into</code></a></li>
<li><code>AsRef</code> and <code>AsMut</code> covered in <a href="https://desmodrone.github.io/posts/26-rustlings-conversions/as_ref_mut.rs"><code>as_ref_mut</code></a></li>
</ul>
<p>Furthermore, the <code>std::str</code> module offers a trait called <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> which helps with converting strings into target types via the <code>parse</code> method on strings. If properly implemented for a given type <code>Person</code>, then <code>let p: Person = &quot;Mark,20&quot;.parse().unwrap()</code> should both compile and run without panicking.</p>
<p>These should be the main ways <em><strong>within the standard library</strong></em> to convert data into your desired types.</p>
<h2 id="further-information">Further information</h2>
<p>These are not directly covered in the book, but the standard library has a great documentation for it.</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/convert/index.html">conversions</a></li>
<li><a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code> trait</a></li>
</ul>
<p>Let's get started!</p>
<h2 id="using-as-rs">Using_as.rs</h2>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">&#x2F;&#x2F; Type casting in Rust is done via the usage of the `as` operator.
&#x2F;&#x2F; Please note that the `as` operator is not only used when type casting.
&#x2F;&#x2F; It also helps with renaming imports.
&#x2F;&#x2F;
&#x2F;&#x2F; The goal is to make sure that the division does not fail to compile
&#x2F;&#x2F; and returns the proper type.
&#x2F;&#x2F; Execute `rustlings hint using_as` or use the `hint` watch subcommand for a hint.

&#x2F;&#x2F; I AM NOT DONE

fn average(values: &amp;[f64]) -&gt; f64 {
    let total = values.iter().sum::&lt;f64&gt;();
    total &#x2F; values.len()
}

fn main() {
    let values = [3.5, 0.3, 13.0, 11.7];
    println!(&quot;{}&quot;, average(&amp;values));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn returns_proper_type_and_value() {
        assert_eq!(average(&amp;[3.5, 0.3, 13.0, 11.7]), 7.125);
    }
}
</code></pre>
<p>our instructions tell us we can use <code>as</code> in a couple of different ways but in this case we're trying to make sure that the division doesn't fail to compile. Let's look at the errors.</p>
<h2 id="using-as-rs-errors">Using_as.rs Errors</h2>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">error[E0277]: cannot divide `f64` by `usize`
  --&gt; exercises&#x2F;conversions&#x2F;using_as.rs:13:11
   |
13 |     total &#x2F; values.len()
   |           ^ no implementation for `f64 &#x2F; usize`
   |
   = help: the trait `Div&lt;usize&gt;` is not implemented for `f64`
   = help: the following other types implement trait `Div&lt;Rhs&gt;`:
             &lt;f64 as Div&gt;
             &lt;f64 as Div&lt;&amp;f64&gt;&gt;
             &lt;&amp;&#x27;a f64 as Div&lt;f64&gt;&gt;
             &lt;&amp;f64 as Div&lt;&amp;f64&gt;&gt;

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
</code></pre>
<p>Here we're told that the trait<code>Div&lt;usize&gt;</code> is not implemented for <code>f64</code>, so I think I understand why this is happening and what the solution is but let's break it down a bit further.</p>
<h2 id="using-as-rs-solution">Using_as.rs Solution</h2>
<p>Rust is a strongly typed language, which means that it is very strict about how different types interact with each other. In this specific case, we have <code>total</code>, which is a <code>f64</code>, and <code>values.len()</code>, which is a <code>usize</code>. Rust does not implicitly convert between these types, as doing so can sometimes lead to unexpected behavior or loss of precision. Therefore, we need to explicitly convert types when they are not the same.</p>
<p>If we look again at <code>values</code> you might be thinking, <em>but all the values in defined in the array are <code>f64</code> so how does it end up a <code>usize</code>?</em></p>
<p>Well, when you call the <code>.len()</code> method on a slice (or an array), the returned type is <code>usize</code>, not <code>f64</code>. Let's break this down:</p>
<ol>
<li>
<p><strong>What is <code>usize</code>?</strong>:</p>
<ul>
<li><code>usize</code> is a type in Rust that is primarily used for indexing and for sizes. Its size is determined by the architecture of the machine on which your program is running. On a 32-bit system, <code>usize</code> is 32 bits, and on a 64-bit system, it's 64 bits.</li>
<li>It's the type returned by the <code>.len()</code> method because the length of a slice or an array (or any collection, generally) is logically a count of items, which is an integer, not a floating point.</li>
</ul>
</li>
<li>
<p><strong>Why <code>.len()</code> Returns <code>usize</code></strong>:</p>
<ul>
<li>The <code>.len()</code> method is designed to return the number of elements in a slice or an array. Since this is essentially a count of items and is used for indexing, it returns a <code>usize</code>. This is a design choice in Rust to ensure type safety in memory indexing and counting operations.</li>
</ul>
</li>
</ol>
<p>So, the solution is simple we simply add <code>as f64</code> to <code>values.len()</code> to convert the <code>usize</code> as <code>f64</code> and code should compile.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">fn average(values: &amp;[f64]) -&gt; f64 {
    let total = values.iter().sum::&lt;f64&gt;();
    total &#x2F; values.len() as f64 &#x2F;&#x2F; add `as f64`
}

fn main() {
    let values = [3.5, 0.3, 13.0, 11.7];
    println!(&quot;{}&quot;, average(&amp;values));
}
</code></pre>
<h2 id="from-into-rs">From_into.rs</h2>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">&#x2F;&#x2F; The From trait is used for value-to-value conversions.
&#x2F;&#x2F; If From is implemented correctly for a type, the Into trait should work conversely.
&#x2F;&#x2F; You can read more about it at https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;convert&#x2F;trait.From.html
&#x2F;&#x2F; Execute `rustlings hint from_into` or use the `hint` watch subcommand for a hint.

#[derive(Debug)]
struct Person {
    name: String,
    age: usize,
}

&#x2F;&#x2F; We implement the Default trait to use it as a fallback
&#x2F;&#x2F; when the provided string is not convertible into a Person object
impl Default for Person {
    fn default() -&gt; Person {
        Person {
            name: String::from(&quot;John&quot;),
            age: 30,
        }
    }
}

&#x2F;&#x2F; Your task is to complete this implementation
&#x2F;&#x2F; in order for the line `let p = Person::from(&quot;Mark,20&quot;)` to compile
&#x2F;&#x2F; Please note that you&#x27;ll need to parse the age component into a `usize`
&#x2F;&#x2F; with something like `&quot;4&quot;.parse::&lt;usize&gt;()`. The outcome of this needs to
&#x2F;&#x2F; be handled appropriately.
&#x2F;&#x2F;
&#x2F;&#x2F; Steps:
&#x2F;&#x2F; 1. If the length of the provided string is 0, then return the default of Person
&#x2F;&#x2F; 2. Split the given string on the commas present in it
&#x2F;&#x2F; 3. Extract the first element from the split operation and use it as the name
&#x2F;&#x2F; 4. If the name is empty, then return the default of Person
&#x2F;&#x2F; 5. Extract the other element from the split operation and parse it into a `usize` as the age
&#x2F;&#x2F; If while parsing the age, something goes wrong, then return the default of Person
&#x2F;&#x2F; Otherwise, then return an instantiated Person object with the results

&#x2F;&#x2F; I AM NOT DONE

impl From&lt;&amp;str&gt; for Person {
    fn from(s: &amp;str) -&gt; Person {
    }
}

fn main() {
    &#x2F;&#x2F; Use the `from` function
    let p1 = Person::from(&quot;Mark,20&quot;);
    &#x2F;&#x2F; Since From is implemented for Person, we should be able to use Into
    let p2: Person = &quot;Gerald,70&quot;.into();
    println!(&quot;{:?}&quot;, p1);
    println!(&quot;{:?}&quot;, p2);
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_default() {
        &#x2F;&#x2F; Test that the default person is 30 year old John
        let dp = Person::default();
        assert_eq!(dp.name, &quot;John&quot;);
        assert_eq!(dp.age, 30);
    }
    #[test]
    fn test_bad_convert() {
        &#x2F;&#x2F; Test that John is returned when bad string is provided
        let p = Person::from(&quot;&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }
    #[test]
    fn test_good_convert() {
        &#x2F;&#x2F; Test that &quot;Mark,20&quot; works
        let p = Person::from(&quot;Mark,20&quot;);
        assert_eq!(p.name, &quot;Mark&quot;);
        assert_eq!(p.age, 20);
    }
    #[test]
    fn test_bad_age() {
        &#x2F;&#x2F; Test that &quot;Mark,twenty&quot; will return the default person due to an error in parsing age
        let p = Person::from(&quot;Mark,twenty&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_comma_and_age() {
        let p: Person = Person::from(&quot;Mark&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_age() {
        let p: Person = Person::from(&quot;Mark,&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name() {
        let p: Person = Person::from(&quot;,1&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_age() {
        let p: Person = Person::from(&quot;,&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_invalid_age() {
        let p: Person = Person::from(&quot;,one&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma() {
        let p: Person = Person::from(&quot;Mike,32,&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma_and_some_string() {
        let p: Person = Person::from(&quot;Mike,32,man&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }
}
</code></pre>
<p>We have clear instructions in the comments that tell us to complete the implementation and we even have specific steps, we'll review those later, for now let's look at the errors, to make sure we're not missing anything.</p>
<h2 id="from-into-rs-errors">From_into.rs Errors</h2>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">⚠️  Compiling of exercises&#x2F;conversions&#x2F;from_into.rs failed! Please try again. Here&#x27;s the output:
error[E0308]: mismatched types
  --&gt; exercises&#x2F;conversions&#x2F;from_into.rs:41:25
   |
41 |     fn from(s: &amp;str) -&gt; Person {
   |        ----             ^^^^^^ expected `Person`, found `()`
   |        |
   |        implicitly returns `()` as its body has no tail or `return` expression

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
</code></pre>
<p>These errors are not providing much insight as we have a missing implementation</p>
<h2 id="from-into-rs-solution">From_into.rs Solution</h2>
<p>To solve this exercise, we need to implement the <code>From&lt;&amp;str&gt;</code> trait for the <code>Person</code> struct. The trait implementation should convert a string in the format <code>&quot;Name,Age&quot;</code> into a <code>Person</code> object. Let's go through the steps required:</p>
<ol>
<li>Check if the provided string is empty. If it is, return the default <code>Person</code>.</li>
<li>Split the string on commas.</li>
<li>Extract the name and age from the split string.</li>
<li>Handle any parsing errors for the age.</li>
</ol>
<p>Here's the complete implementation:</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">impl From&lt;&amp;str&gt; for Person {
    fn from(s: &amp;str) -&gt; Person {
        &#x2F;&#x2F; Step 1: Check if the string is empty
        if s.is_empty() {
            return Person::default();
        }

        &#x2F;&#x2F; Step 2: Split the string on the comma
        let parts: Vec&lt;&amp;str&gt; = s.split(&#x27;,&#x27;).collect();

        &#x2F;&#x2F; Check for the correct number of parts (name and age)
        if parts.len() != 2 {
            return Person::default();
        }

        &#x2F;&#x2F; Step 3: Extract name and age
        let name = parts[0].to_string();
        let age_str = parts[1];

        &#x2F;&#x2F; Step 4: Handle parsing errors for age
        if name.is_empty() || age_str.is_empty() {
            return Person::default();
        }

        match age_str.parse::&lt;usize&gt;() {
            Ok(age) =&gt; Person { name, age },
            Err(_) =&gt; Person::default(),
        }
    }
}

fn main() {
    let p1 = Person::from(&quot;Mark,20&quot;);
    let p2: Person = &quot;Gerald,70&quot;.into();
    println!(&quot;{:?}&quot;, p1);
    println!(&quot;{:?}&quot;, p2);
}
</code></pre>
<p>In this implementation:</p>
<ul>
<li>The string is split into two parts based on the comma.</li>
<li>If the number of parts isn't exactly 2 (name and age), or if either part is empty, the default <code>Person</code> is returned.</li>
<li>If the age part can't be parsed into a <code>usize</code>, the default <code>Person</code> is returned.</li>
<li>If all conditions are met, a new <code>Person</code> instance is created and returned.</li>
</ul>
<p>With these changes our code compiles! On to the next one.</p>
<h2 id="from-str-rs">From_str.rs</h2>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">&#x2F;&#x2F; from_str.rs
&#x2F;&#x2F; This is similar to from_into.rs, but this time we&#x27;ll implement `FromStr`
&#x2F;&#x2F; and return errors instead of falling back to a default value.
&#x2F;&#x2F; Additionally, upon implementing FromStr, you can use the `parse` method
&#x2F;&#x2F; on strings to generate an object of the implementor type.
&#x2F;&#x2F; You can read more about it at https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;str&#x2F;trait.FromStr.html
&#x2F;&#x2F; Execute `rustlings hint from_str` or use the `hint` watch subcommand for a hint.

use std::num::ParseIntError;
use std::str::FromStr;

#[derive(Debug, PartialEq)]
struct Person {
    name: String,
    age: usize,
}

&#x2F;&#x2F; We will use this error type for the `FromStr` implementation.
#[derive(Debug, PartialEq)]
enum ParsePersonError {
    &#x2F;&#x2F; Empty input string
    Empty,
    &#x2F;&#x2F; Incorrect number of fields
    BadLen,
    &#x2F;&#x2F; Empty name field
    NoName,
    &#x2F;&#x2F; Wrapped error from parse::&lt;usize&gt;()
    ParseInt(ParseIntError),
}

&#x2F;&#x2F; I AM NOT DONE

&#x2F;&#x2F; Steps:
&#x2F;&#x2F; 1. If the length of the provided string is 0, an error should be returned
&#x2F;&#x2F; 2. Split the given string on the commas present in it
&#x2F;&#x2F; 3. Only 2 elements should be returned from the split, otherwise return an error
&#x2F;&#x2F; 4. Extract the first element from the split operation and use it as the name
&#x2F;&#x2F; 5. Extract the other element from the split operation and parse it into a `usize` as the age
&#x2F;&#x2F;    with something like `&quot;4&quot;.parse::&lt;usize&gt;()`
&#x2F;&#x2F; 6. If while extracting the name and the age something goes wrong, an error should be returned
&#x2F;&#x2F; If everything goes well, then return a Result of a Person object
&#x2F;&#x2F;
&#x2F;&#x2F; As an aside: `Box&lt;dyn Error&gt;` implements `From&lt;&amp;&#x27;_ str&gt;`. This means that if you want to return a
&#x2F;&#x2F; string error message, you can do so via just using return `Err(&quot;my error message&quot;.into())`.

impl FromStr for Person {
    type Err = ParsePersonError;
    fn from_str(s: &amp;str) -&gt; Result&lt;Person, Self::Err&gt; {
    }
}

fn main() {
    let p = &quot;Mark,20&quot;.parse::&lt;Person&gt;().unwrap();
    println!(&quot;{:?}&quot;, p);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn empty_input() {
        assert_eq!(&quot;&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::Empty));
    }
    #[test]
    fn good_input() {
        let p = &quot;John,32&quot;.parse::&lt;Person&gt;();
        assert!(p.is_ok());
        let p = p.unwrap();
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 32);
    }
    #[test]
    fn missing_age() {
        assert!(matches!(
            &quot;John,&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn invalid_age() {
        assert!(matches!(
            &quot;John,twenty&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn missing_comma_and_age() {
        assert_eq!(&quot;John&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::BadLen));
    }

    #[test]
    fn missing_name() {
        assert_eq!(&quot;,1&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::NoName));
    }

    #[test]
    fn missing_name_and_age() {
        assert!(matches!(
            &quot;,&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn missing_name_and_invalid_age() {
        assert!(matches!(
            &quot;,one&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn trailing_comma() {
        assert_eq!(&quot;John,32,&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::BadLen));
    }

    #[test]
    fn trailing_comma_and_some_string() {
        assert_eq!(
            &quot;John,32,man&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::BadLen)
        );
    }
}
</code></pre>
<p>We have a similar exercise as before except that instead of using <code>from_into</code> we'll be we'll be using <code>FromStr</code>, similarly we have the instructions in the comments that tell us exactly what we need to be doing, and again we'll look at those in detail after we look at the errors.</p>
<h2 id="from-str-rs-errors">From_str.rs Errors</h2>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">error[E0308]: mismatched types
  --&gt; exercises&#x2F;conversions&#x2F;from_str.rs:48:29
   |
48 |     fn from_str(s: &amp;str) -&gt; Result&lt;Person, Self::Err&gt; {
   |        --------             ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result&lt;Person, ParsePersonError&gt;`, found `()`
   |        |
   |        implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `Result&lt;Person, ParsePersonError&gt;`
           found unit type `()`

error: aborting due to previous error

</code></pre>
<p>Here we see that the error is related to the compiler wanting an <code>enum</code> type or essentially a <code>Result</code> type but it found a <code>()</code> type because our solution isn't implemented yet.  So, let's fix that.</p>
<h2 id="from-str-rs-solution">From_str.rs Solution</h2>
<p>Before we implement a solution let's make sure we're all on the same page here with the <code>FromStr</code> trait.</p>
<h3 id="understanding-the-fromstr-trait">Understanding the FromStr Trait</h3>
<p><strong>Purpose of FromStr:</strong> The FromStr trait in Rust is used for converting a string into another type. In this case, we are converting a string into a Person struct.</p>
<p><strong>Why Use FromStr:</strong> Implementing FromStr allows you to use the parse method on strings, which simplifies the conversion process. This is particularly useful when you want to turn user input (which is often in string format) into more complex data types.</p>
<h3 id="breaking-down-the-implementation">Breaking Down the Implementation</h3>
<p><strong>Error Handling:</strong>
The FromStr trait requires you to define an error type. In this example, ParsePersonError is used to represent different kinds of errors that might occur during parsing (like empty input, incorrect format, etc.).
Using custom error types makes your code more robust and easier to debug.</p>
<p><strong>Parsing Logic:</strong>
The input string is split on commas, assuming the format <code>name,age</code>.
The code then checks if the input is correctly formatted and handles each part (name and age) separately.
The parse method is used to convert the age from a string to a <code>usize</code>. If this fails, the error is captured and returned.</p>
<p><strong>Creating the Person Object:</strong>
If all validations pass, a new Person object is created with the parsed name and age.
This object is then returned as a Result&lt;Person, ParsePersonError&gt;, indicating a successful parsing or an error.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">impl FromStr for Person {
    type Err = ParsePersonError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Person, Self::Err&gt; {
        &#x2F;&#x2F; Check if the input string is empty
        if s.is_empty() {
            return Err(ParsePersonError::Empty);
        }

        &#x2F;&#x2F; Split the input string on the comma
        let parts: Vec&lt;&amp;str&gt; = s.split(&#x27;,&#x27;).collect();
        &#x2F;&#x2F; Ensure that there are exactly two parts (name and age)
        if parts.len() != 2 {
            return Err(ParsePersonError::BadLen);
        }

        &#x2F;&#x2F; Extract the first part as the name
        let name = parts[0].to_string();
        &#x2F;&#x2F; Ensure that the name is not empty
        if name.is_empty() {
            return Err(ParsePersonError::NoName);
        }

        &#x2F;&#x2F; Parse the second part as age and handle any parsing errors
        let age = parts[1].parse::&lt;usize&gt;().map_err(ParsePersonError::ParseInt)?;

        &#x2F;&#x2F; Return a Person object if all is well
        Ok(Person { name, age })
    }
}

fn main() {
    let p = &quot;Mark,20&quot;.parse::&lt;Person&gt;().unwrap();
    println!(&quot;{:?}&quot;, p);
}
</code></pre>
<p>This code does the following:</p>
<ol>
<li><strong>Error Checking</strong>: It checks for empty input, an incorrect number of fields, and parsing errors for the age field.</li>
<li><strong>String Splitting and Parsing</strong>: It splits the input string by a comma, extracting the name and age, and attempts to parse the age as an <code>usize</code>.</li>
<li><strong>Error Handling</strong>: It uses custom error types to handle different error scenarios such as empty input, no name, or parsing errors.</li>
<li><strong>Person Creation</strong>: If all checks pass, it creates and returns a <code>Person</code> object.</li>
<li><strong>Testing with Main</strong>: The <code>main</code> function demonstrates how to parse a string to create a <code>Person</code> object, using the implemented <code>from_str</code> method.</li>
</ol>
<h3 id="why-this-example-is-important">Why This Example is Important</h3>
<ol>
<li><strong>Real-world Application</strong>: Parsing user input is a common requirement in many applications. Understanding how to do it properly in Rust is crucial for writing robust software.</li>
<li><strong>Learning Rust’s Conventions</strong>: Rust emphasizes safety and clear error handling. Implementing <code>FromStr</code> with comprehensive error checking is a great exercise in learning these aspects of Rust.</li>
<li><strong>Hands-on Practice</strong>: By working through this example, beginners get practical experience with common Rust concepts like traits, error handling, and generics.</li>
</ol>
<p>With the changes above our code is compiling and we can move on to our next exercise!</p>

	</div>
	<hr class="post-end">
	<footer class="post-info">
    
	  <p>
		<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>
		
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/rust/">rust</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/type-conversion/">type conversion</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/rustlings/">rustlings</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/from/">From</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/into/">Into</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/tryfrom/">TryFrom</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/tryinto/">TryInto</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/asref/">AsRef</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/asmut/">AsMut</a></span>
		
		<span class="tag"><a href="https://desmodrone.github.io/tags/fromstr/">FromStr</a></span>
		
		
    </p>
    
    <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>2824 Words</p>
    
    <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2023-12-13</p>
    
	</footer>
  </article>
    
  
  <div class="post-nav thin">
	
	
  </div>

  
</main>

	  </div>
	  
	  



<footer id="site-footer" class="section-inner thin animated fadeIn faster">
  <p>&copy; 2023 <a href="https:&#x2F;&#x2F;desmodrone.github.io">erick</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
  <p>Made with <a href="https://www.getzola.org" target="_blank" rel="noopener">Zola</a> &#183; Theme <a href="https://github.com/VersBinarii/hermit_zola" target="_blank" rel="noopener">Hermit_Zola</a>
	
	&#183; <a href="https://desmodrone.github.io/rss.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
	
  </p>
</footer>




	</div>
	
	<script src="https://desmodrone.github.io/js/main.js"></script>

	<!-- Math rendering -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body, { delimiters: [ {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}, {left: '\\[', right: '\\]', display: true}, {left: '\\(', right: '\\)', display: false}]});"></script>

    
		<link href="https://unpkg.com/highlightjs-badge/highlightjs/styles/monokai.css" rel="stylesheet">
		<!-- https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.1/build/styles/  for min version -->
		<script src="https://unpkg.com/highlightjs-badge/highlightjs/highlight.pack.js"></script>
		<script src="https://unpkg.com/highlightjs-badge/highlightjs-badge.min.js"></script>
		<script>
			var pres = document.querySelectorAll("pre>code");
			for (var i = 0; i < pres.length; i++) {
				hljs.highlightBlock(pres[i]);
			}
		</script>
		
			<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js"></script>
			<script>
				var options = {
					copyIconClass: "gg-clipboard",
					checkIconClass: "gg-check"
				};
				window.highlightJsBadge(options);
			</script>
		

	

	
	<script src="https://desmodrone.github.io/js/main.js"></script>

    
    

	
    <!-- Global Site Tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9MNTYXYNHK"></script>
    <script>
     window.dataLayer = window.dataLayer || [];
     function gtag(){dataLayer.push(arguments);}
     gtag('js', new Date());
     gtag('config', 'G-9MNTYXYNHK');
    </script>
    
  </body>
</html>
